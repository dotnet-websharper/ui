{
"version": 3,
"sourceRoot": "Source",
"sources": ["WebSharper.Web/ClientSideJson.fs", "WebSharper.Web/Control.fs"],
"sourcesContent": ["// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2014 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<CompiledName \"TypedJson\">]\nmodule WebSharper.Json\n\nopen System.Collections.Generic\nopen WebSharper\nopen WebSharper.JavaScript\n\ntype OptionalFieldKind =\n    /// The field doesn't have type option<'T>\n    | NotOption = 0\n    /// The field has type option<'T>\n    | NormalOption = 1\n    /// The field has type option<'T> and is marked [<OptionalField>]\n    | MarkedOption = 2\n\nlet ServerSideProvider = WebSharper.Core.Json.Provider.Create ()\n\n[<JavaScript>]\nmodule Provider =\n    let Id () = \n        ()\n        fun () -> id\n\n    let EncodeTuple (encs: (unit -> obj -> obj)[]) : (unit -> obj[] -> obj) =\n        ()\n        fun () args ->\n            box (Array.map2 (fun f x -> f () x) encs args)\n\n    let EncodeDateTime () =\n        ()\n        fun () (x: System.DateTime) ->\n            box (x.JS.ToISOString())\n\n    let EncodeList (encEl: unit -> 'T -> obj) : (unit -> list<'T> -> obj) =\n        ()\n        fun () (l: list<'T>) ->\n            let a : obj[] = [||]\n            let e = encEl()\n            l |> List.iter (fun x -> a.JS.Push (e x) |> ignore)\n            box a\n\n    let EncodeRecord (_: obj) (fields: (string * (unit -> obj -> obj) * OptionalFieldKind)[]) : (unit -> 'T -> obj) =\n        ()\n        fun () x ->\n            let o = New []\n            fields |> Array.iter (fun (name, enc, kind) ->\n                match kind with\n                | OptionalFieldKind.NotOption ->\n                    o?(name) <- enc () x?(name)\n                | OptionalFieldKind.NormalOption ->\n                    match x?(name) with\n                    | Some x -> o?(name) <- enc () x\n                    | None -> ()\n                | OptionalFieldKind.MarkedOption ->\n                    if JS.HasOwnProperty x name then\n                        o?(name) <- enc () x?(name)\n                | _ -> failwith \"Invalid field option kind\")\n            o\n\n    let EncodeUnion (_: obj) (discr: string) (cases: (string * (string * string * (unit -> obj -> obj) * OptionalFieldKind)[])[]) : (unit -> 'T -> obj) =\n        ()\n        fun () x ->\n            if JS.TypeOf x ===. JS.Object && x !=. null then\n                let o = New []\n                let tag = x?(\"$\")\n                let tagName, fields = cases.[tag]\n                if JS.TypeOf discr = JS.Kind.String then o?(discr) <- tagName\n                fields |> Array.iter (fun (from, ``to``, enc, kind) ->\n                    match from with\n                    | null -> // inline record\n                        let record = enc () (x?(\"$0\"))\n                        JS.ForEach record (fun f -> o?(f) <- record?(f); false)\n                    | from -> // normal args\n                        match kind with\n                        | OptionalFieldKind.NotOption ->\n                            o?(``to``) <- enc () (x?(from))\n                        | OptionalFieldKind.NormalOption ->\n                            match x?(from) with\n                            | Some x -> o?(``to``) <- enc () x\n                            | None -> ()\n                        | _ -> failwith \"Invalid field option kind\")\n                o\n            else box x // [<Constant>]\n\n    let EncodeArray (encEl: (unit -> 'T -> obj)) : (unit -> 'T[] -> obj) =\n        ()\n        fun () (a: 'T[]) ->\n            let e = encEl()\n            box (Array.map e a)\n\n    let EncodeSet (encEl: (unit -> 'T -> obj)) : (unit -> Set<'T> -> obj) =\n        ()\n        fun () (s: Set<'T>) ->\n            let a : obj[] = [||]\n            let e = encEl()\n            s |> Set.iter (fun x -> a.JS.Push (e x) |> ignore)\n            box a\n\n    let EncodeStringMap (encEl:(unit -> 'T -> obj)) : (unit -> Map<string, 'T> -> obj) =\n        ()\n        fun () (m: Map<string, 'T>) ->\n            let o = New []\n            let e = encEl()\n            m |> Map.iter (fun k v -> o?(k) <- e v)\n            o\n\n    let EncodeStringDictionary (encEl:(unit -> 'T -> obj)) : (unit -> Dictionary<string, 'T> -> obj) =\n        ()\n        fun () (d: Dictionary<string, 'T>) ->\n            let o = New []\n            let e = encEl()\n            for KeyValue(k, v) in d :> seq<_> do o?(k) <- e v\n            o\n\n    let DecodeTuple (decs: (unit -> obj -> obj)[]) : (unit -> obj -> obj[]) =\n        As (EncodeTuple decs)\n\n    let DecodeDateTime() =\n        ()\n        fun () (x: obj) ->\n            Date(x :?> string).Self\n\n    let DecodeList (decEl: (unit -> obj -> 'T)) : (unit -> obj -> list<'T>) =\n        ()\n        fun () (a : obj) ->\n            let e = decEl()\n            List.init (a :?> obj[]).Length (fun i -> e (a :?> obj[]).[i])\n\n    let DecodeSet (decEl: unit -> obj -> 'T) : (unit -> obj -> Set<'T>) =\n        ()\n        fun () (a : obj) ->\n            let e = decEl()\n            Set.ofArray(Array.map e (a :?> obj[]))\n\n    let DecodeRecord (t: obj) (fields: (string * (unit -> obj -> obj) * OptionalFieldKind)[]) : (unit -> obj -> 'T) =\n        ()\n        fun () (x: obj) ->\n            let o = if t ===. JS.Undefined then New [] else JS.New t\n            fields |> Array.iter (fun (name, dec, kind) ->\n                match kind with\n                | OptionalFieldKind.NotOption ->\n                    if JS.HasOwnProperty x name then\n                        o?(name) <- dec () x?(name)\n                    else failwith (\"Missing mandatory field: \" + name)\n                | OptionalFieldKind.NormalOption ->\n                    o?(name) <-\n                        if JS.HasOwnProperty x name\n                        then Some (dec () x?(name))\n                        else None\n                | OptionalFieldKind.MarkedOption ->\n                    if JS.HasOwnProperty x name then\n                        o?(name) <- (dec () x?(name))\n                | _ -> failwith \"Invalid field option kind\")\n            o\n\n    let DecodeUnion (t: obj) (discr: string) (cases: (string * (string * string * (unit -> obj -> obj) * OptionalFieldKind)[])[]) : (unit -> obj -> 'T) =\n        ()\n        fun () (x: obj) ->\n            if JS.TypeOf x ===. JS.Object && x !=. null then\n                let o = if t ===. JS.Undefined then New [] else JS.New t\n                let tag =\n                    // [<NamedUnionCases(discr)>]\n                    if JS.TypeOf discr = JS.Kind.String then\n                        let tagName = x?(discr)\n                        cases |> Array.findIndex (fun (name, _) -> name = tagName)\n                    else // [<NamedUnionCases>]\n                        let r = ref JS.Undefined\n                        JS.ForEach discr (fun k ->\n                            if JS.HasOwnProperty x k then r := discr?(k); true else false)\n                        !r\n                o?(\"$\") <- tag\n                cases.[tag] |> snd |> Array.iter (fun (from, ``to``, dec, kind) ->\n                    match from with\n                    | null -> // inline record\n                        let r = dec () x\n                        // eliminate tag field if record deserializer is identity\n                        if As<bool> ``to`` then \n                            JS.Delete r discr\n                        o?(\"$0\") <- r\n                    | from -> // normal args\n                        match kind with\n                        | OptionalFieldKind.NotOption ->\n                            o?(from) <- dec () (x?(``to``))\n                        | OptionalFieldKind.NormalOption ->\n                            o?(from) <-\n                                if JS.HasOwnProperty x ``to``\n                                then Some (dec () x?(``to``))\n                                else None\n                        | _ -> failwith \"Invalid field option kind\")\n                o\n            else x :?> 'T // [<Constant>]\n\n    let DecodeArray (decEl :(unit -> obj -> 'T)) : (unit -> obj -> 'T[]) =\n        As (EncodeArray (As decEl))\n\n    let DecodeStringMap (decEl :(unit -> obj -> 'T)) : (unit -> obj -> Map<string, 'T>) =\n        ()\n        fun () (o: obj) ->\n            let m = ref Map.empty\n            let decEl = decEl ()\n            JS.ForEach o (fun k -> m := Map.add k (decEl o?(k)) !m; false)\n            !m\n\n    let DecodeStringDictionary (decEl: unit -> obj -> 'T) : (unit -> obj -> Dictionary<string, 'T>) =\n        ()\n        fun () (o: obj) ->\n            let d = System.Collections.Generic.Dictionary()\n            let decEl = decEl ()\n            JS.ForEach o (fun k -> d.Add(k, decEl o?(k)); false)\n            d\n\nmodule Macro =\n\n    module M = WebSharper.Core.Metadata\n    open WebSharper.Core.AST\n    module JI = WebSharper.Core.Json.Internal\n    type private BF = System.Reflection.BindingFlags\n\n    type Parameters =\n        {\n            Warnings : ResizeArray<string>\n            Dependencies : ResizeArray<M.Node>\n            Compilation : M.ICompilation\n        }\n\n    [<AutoOpen>]\n    module private Internals =\n\n        let cString s = !~ (Literal.String s)\n        let inline cInt i = !~ (Int i)\n\n        let mainJsonModule =\n            TypeDefinition {\n                FullName = \"WebSharper.Json\"\n                Assembly = \"WebSharper.Main\"\n            }\n        let mJson (comp: M.ICompilation) f args =\n            let m = comp.GetClassInfo(mainJsonModule).Value.Methods.Keys |> Seq.find (fun m -> m.Value.MethodName = f)\n            Call(None, NonGeneric mainJsonModule, NonGeneric m, args)\n\n        let (|T|) (t: TypeDefinition) = t.Value.FullName\n        let (|C|_|) (t: Type) =\n            match t with \n            | ConcreteType { Entity = e; Generics = g} -> Some (e, g)\n            | _ -> None\n\n        let providerType = \n            TypeDefinition {\n                FullName = \"WebSharper.Json+Provider\"\n                Assembly = \"WebSharper.Web\"\n            }\n        let invoke (comp: M.ICompilation) isEnc n args = \n            let f = (if isEnc then \"Encode\" else \"Decode\") + n\n            let m = comp.GetClassInfo(providerType).Value.Methods.Keys |> Seq.find (fun m -> m.Value.MethodName = f)\n            Call(None, NonGeneric providerType, NonGeneric m, args)\n        let invokeId (comp: M.ICompilation) = \n            let m = comp.GetClassInfo(providerType).Value.Methods.Keys |> Seq.find (fun m -> m.Value.MethodName = \"Id\")\n            Call(None, NonGeneric providerType, NonGeneric m, [])\n\n        type EncodeResult = Choice<Expression, string, Type>\n\n        let (>>=) (x: EncodeResult) (f: Expression -> EncodeResult) =\n            match x with\n            | Choice1Of3 e -> f e\n            | _ -> x\n        let ok x = Choice1Of3 x : EncodeResult\n        let fail x = Choice2Of3 x : EncodeResult\n        let generic t = Choice3Of3 t : EncodeResult\n\n        let mapOk f x =\n            match x with\n            | Choice1Of3 x -> Choice1Of3 (f x) \n            | _ -> x\n\n        /// Returns None if MacroNeedsResolvedTypeArg.\n        let getEncoding name isEnc param (t: Type) : EncodeResult =\n            let warn msg = param.Warnings.Add msg\n            let addTypeDep td = param.Dependencies.Add (M.TypeNode td)\n            let comp = param.Compilation\n            let call = invoke comp isEnc\n            let ident = invokeId comp \n            let isIdent r =\n                match r with \n                | Choice1Of3 e when obj.ReferenceEquals(e, ident) -> true\n                | _ -> false\n            let rec encode t =\n                match t with\n                | ArrayType (t, 1) ->\n                    encode t >>= fun e ->\n                    ok (call \"Array\" [e])\n                | ArrayType _ ->\n                    fail \"JSON serialization for multidimensional arrays is not supported.\"\n                | VoidType\n                | C (T (\"Microsoft.FSharp.Core.Unit\"\n                                |\"System.Boolean\"\n                                |\"System.SByte\" | \"System.Byte\"\n                                |\"System.Int16\" | \"System.UInt16\"\n                                |\"System.Int32\" | \"System.UInt32\"\n                                |\"System.Int64\" | \"System.UInt64\"\n                                |\"System.Single\"| \"System.Double\"\n                                |\"System.String\"| \"System.Guid\"\n                                |\"WebSharper.Core.Json+Encoded\"), []) ->\n                    ok ident\n                | C (T \"Microsoft.FSharp.Collections.FSharpList`1\", [t]) ->\n                    encode t >>= fun e ->\n                    ok (call \"List\" [e])\n                | C (T \"Microsoft.FSharp.Collections.FSharpSet`1\", [t]) ->\n                    encode t >>= fun e ->\n                    ok (call \"Set\" [e])\n                | C (T \"Microsoft.FSharp.Collections.FSharpMap`2\",\n                                [C (T \"System.String\", []); t]) ->\n                    encode t >>= fun e -> \n                    ok (call \"StringMap\" [e])\n                | C (T \"System.Collections.Generic.Dictionary`2\",\n                                [C (T \"System.String\", []); t]) ->\n                    encode t >>= fun e ->\n                    ok (call \"StringDictionary\" [e])\n                | TupleType (ts, _) ->\n                    ((fun es -> ok (call \"Tuple\" [NewArray es])), ts)\n                    ||> List.fold (fun k t ->\n                        fun es -> encode t >>= fun e -> k (e :: es))\n                    <| []\n                | C (T \"System.DateTime\", []) ->\n                    ok (call \"DateTime\" [])\n                | C (td, args) ->                    \n                    let top = comp.AssemblyName.Replace(\".\",\"$\") + if isEnc then \"_JsonEncoder\" else \"_JsonDecoder\"\n                    let key = M.CompositeEntry [ M.StringEntry top; M.TypeEntry t ]\n                    match comp.GetMetadataEntries key with                    \n                    | M.StringEntry \"id\" :: _ ->\n                        ok ident\n                    | M.CompositeEntry [ M.TypeDefinitionEntry gtd; M.MethodEntry gm ] :: _ ->\n                        Lambda([], Call(None, NonGeneric gtd, NonGeneric gm, [])) |> ok\n                    | _ ->\n                        let gtd, gm, _ = comp.NewGenerated([top; \"j\"])\n                        let _, gv, va = comp.NewGenerated([top; \"_\" + \"v\"])\n                        comp.AddGeneratedCode(gv, Undefined)\n                        comp.AddMetadataEntry(key, M.CompositeEntry [ M.TypeDefinitionEntry gtd; M.MethodEntry gm ])\n                        ((fun es ->\n                            let enc = encRecType t args es\n                            if isIdent enc then\n                                comp.AddMetadataEntry(key, M.StringEntry \"id\")\n                                comp.AddGeneratedInline(gm, ident)\n                                enc\n                            else\n                                enc >>= fun e ->\n                                let v = Lambda([], Call (None, NonGeneric gtd, NonGeneric gv, []))\n                                let vn = Value (String va.Value.Head)\n                                let b = Lambda ([], Conditional(v, v, ItemSet(Global [top], vn, Application(e, [], NonPure, Some 0))))\n                                comp.AddGeneratedCode(gm, b)\n                                Lambda([], Call(None, NonGeneric gtd, NonGeneric gm, [])) |> ok\n                         ), args)\n                        ||> List.fold (fun k t es ->\n                            encode t >>= fun e -> k ((t, e) :: es))\n                        <| []\n                | ConcreteType _ -> failwith \"impossible\"\n                | FSharpFuncType _ -> \n                    fail (name + \": Cannot de/serialize a function value.\")\n                | ByRefType _ ->\n                    fail (name + \": Cannot de/serialize a byref value.\")\n                | LocalTypeParameter\n                | StaticTypeParameter _ \n                | TypeParameter _ ->\n                    generic t\n            // Encode a type that might be recursively defined\n            and encRecType t targs args =\n                let td = t.TypeDefinition\n                match comp.GetCustomTypeInfo td with\n                | M.EnumInfo _ -> ok ident\n                | M.FSharpRecordInfo fields ->\n                    let fieldEncoders =\n                        fields\n                        |> List.map (fun f ->\n                            if Option.isSome f.DateTimeFormat then\n                                warn (sprintf \"Warning: This record field has a custom DateTime format: %s.%s. \\\n                                    Client-side JSON serialization does not support custom DateTime formatting. \\\n                                    This field will be serialized using ISO format.\"\n                                    f.RecordFieldType.TypeDefinition.Value.FullName f.Name)\n                            let t, optionKind =\n                                match f.RecordFieldType with\n                                | ConcreteType { Entity = d; Generics = [p] } when d.Value.FullName = \"Microsoft.FSharp.Core.FSharpOption`1\" ->\n                                    if f.Optional then p, OptionalFieldKind.MarkedOption    \n                                    else p, OptionalFieldKind.NormalOption \n                                | t ->    \n                                    t, OptionalFieldKind.NotOption\n                            f.JSName, optionKind, encode (t.SubstituteGenerics (Array.ofList targs))\n                        )  \n                    let pr =\n                        match comp.GetClassInfo td with\n                        | Some cls -> \n                            addTypeDep td \n                            if cls.HasWSPrototype then\n                                GlobalAccess cls.Address.Value\n                            else Undefined\n                        | _ -> Undefined\n                    if pr = Undefined && fieldEncoders |> List.forall (fun (_, fo, fe) ->\n                        fo <> OptionalFieldKind.NormalOption && isIdent fe\n                    )\n                    then ok ident\n                    else\n                        ((fun es ->\n                            let es, tts = List.unzip es\n                            ok (call \"Record\" [pr; NewArray es])\n                            ), fieldEncoders)\n                        ||> List.fold (fun k (fn, fo, fe) es ->                     \n                                fe >>= fun e ->\n                                k ((NewArray [cString fn; e; cInt (int fo)], t) :: es))\n                        <| []\n                // TODO: handle nested case type (possible when using from C#)\n                | M.FSharpUnionInfo u ->\n                    let tryGetInlinableRecordInfo (uci: M.FSharpUnionCaseInfo) =\n                        match uci.Kind with \n                        | M.NormalFSharpUnionCase [f] when f.Name = \"Item\" ->\n                            let rec inl uft =\n                                match uft with\n                                | ConcreteType { Entity = fTd } as ft ->\n                                    match comp.GetCustomTypeInfo fTd with\n                                    | M.FSharpRecordInfo fRec -> Some (ft, fRec)\n                                    | _ -> None\n                                | TypeParameter i -> inl (targs.[i])\n                                | _ -> None\n                            inl f.UnionFieldType\n                        | _ -> None\n                    let isOption (t: Type) =\n                        match t with\n                        | ConcreteType { Entity = e } ->\n                            e.Value.FullName = \"Microsoft.FSharp.Core.FSharpOption`1\"\n                        | _ -> false\n                    let discr =\n                        match u.NamedUnionCases with\n                        | None -> JI.StandardField\n                        | Some None -> \n                            let allCases =\n                                u.Cases |> Seq.mapi (fun i uci ->\n                                    i,\n                                    match tryGetInlinableRecordInfo uci with\n                                    | Some (_, fRec) ->\n                                        fRec |> Seq.filter (fun rf -> not (isOption rf.RecordFieldType))\n                                        |> Seq.map (fun rf -> rf.JSName) |> Set.ofSeq\n                                    | None ->\n                                        match uci.Kind with \n                                        | M.NormalFSharpUnionCase fs ->\n                                            fs\n                                            |> List.choose (fun f ->\n                                                if isOption f.UnionFieldType then None else Some f.Name)\n                                            |> Set.ofList\n                                        | _ -> Set.empty\n                                )\n                                |> Map.ofSeq\n                            let findDistinguishingCase (cases: Map<int, Set<string>>) =\n                                cases\n                                |> Map.tryPick (fun t fs ->\n                                    let allOtherFields =\n                                        allCases\n                                        |> Seq.choose (fun (KeyValue(t', fs)) ->\n                                            if t = t' then None else Some fs)\n                                        |> Set.unionMany\n                                    let uniqueCases = fs - allOtherFields\n                                    if Set.isEmpty uniqueCases then\n                                        None\n                                    else Some (Seq.head uniqueCases, t)\n                                )\n                            let rec buildTable acc cases =\n                                if Map.isEmpty cases then acc else\n                                match findDistinguishingCase cases with\n                                | None -> failwithf \"No decoder for %s\" t.AssemblyQualifiedName\n                                | Some (name, tag) ->\n                                    buildTable\n                                        <| (name, tag) :: acc\n                                        <| Map.remove tag cases\n                            buildTable [] allCases |> JI.NoField\n                        | Some (Some n) -> JI.NamedField n\n                    let cases = u.Cases\n                    ((0, fun cases ->\n                        let cases = NewArray cases\n                        let discr =\n                            match discr with\n                            | JI.NoField discrFields ->\n                                discrFields\n                                |> List.map (fun (name, id) -> name, cInt id)\n                                |> Object\n                            | JI.StandardField -> cString \"$\"\n                            | JI.NamedField n -> cString n\n                        let tn =\n                            match comp.GetClassInfo td with\n                            | Some cls -> \n                                addTypeDep td\n                                if cls.HasWSPrototype then\n                                    GlobalAccess cls.Address.Value\n                                else\n                                    Undefined\n                            | _ -> Undefined\n                        ok (call \"Union\" [tn; discr; cases])\n                        ), cases)\n                    ||> List.fold (fun (i, k) case ->\n                        i + 1, fun es ->\n                            match tryGetInlinableRecordInfo case with\n                            | Some (ft, _) -> \n                                let tag =\n                                    match discr with\n                                    | JI.StandardField -> cInt i\n                                    | _ -> cString (match case.JsonName with Some n -> n | _ -> case.Name)\n                                let encF = encode ft \n                                let elimTag =\n                                    if isIdent encF then !~(Bool true) else !~Null\n                                encF >>= fun e ->\n                                k (NewArray [tag; NewArray [NewArray [!~Null; elimTag; e]]] :: es)\n                            | _ ->\n                            match case.Kind with\n                            | M.NormalFSharpUnionCase fields ->\n                                ((0, fun argNames ->\n                                    let tag =\n                                        match u.NamedUnionCases with\n                                        | None -> cInt i\n                                        | _ -> cString (match case.JsonName with Some n -> n | _ -> case.Name)\n                                    k (NewArray [tag; NewArray argNames] :: es)\n                                    ), fields)\n                                ||> List.fold (fun (j, k) f -> //(argName, argT, argFlags) ->\n                                    if Option.isSome f.DateTimeFormat then\n                                        warn (sprintf \"Warning: This union case field has a custom DateTime format: %s.%s [%s]. \\\n                                            Client-side JSON serialization does not support custom DateTime formatting. \\\n                                            This field will be serialized using ISO format.\"\n                                            f.UnionFieldType.TypeDefinition.Value.FullName case.Name f.Name)\n                                    let argT, optionKind =\n                                        match f.UnionFieldType with\n                                        | ConcreteType { Entity = d; Generics = [p] } when d.Value.FullName = \"Microsoft.FSharp.Core.FSharpOption`1\" ->\n                                            p, cInt (int OptionalFieldKind.NormalOption)\n                                        | t ->    \n                                            t, cInt (int OptionalFieldKind.NotOption)\n                                    j + 1, fun es ->\n                                        encode (argT.SubstituteGenerics (Array.ofList targs)) >>= fun e ->\n                                        k (NewArray [cString (\"$\" + string j); cString f.Name; e; optionKind] :: es))\n                                |> snd\n                                <| []\n                            | M.SingletonFSharpUnionCase ->\n                                let tag =\n                                    match u.NamedUnionCases with\n                                    | None -> cInt i\n                                    | _ -> cString (match case.JsonName with Some n -> n | _ -> case.Name)\n                                k (NewArray [tag; NewArray []] :: es)\n                            | M.ConstantFSharpUnionCase _ -> k (!~Null :: es)\n                    )\n                    |> snd\n                    <| []\n                | _ -> \n                    match comp.GetClassInfo td with\n                    | Some cls ->\n                        let fieldEncoders =\n                            cls.Fields.Values\n                            |> Seq.choose (fun (f, _, ft) ->\n                                let jsNameTypeAndOption =\n                                    let isOption name isMarked =\n                                        match ft with\n                                        | ConcreteType { Entity = d; Generics = [p] } when d.Value.FullName = \"Microsoft.FSharp.Core.FSharpOption`1\" ->\n                                            if isMarked then\n                                                Some (name, p, OptionalFieldKind.MarkedOption) \n                                            else\n                                                Some (name, p, OptionalFieldKind.NormalOption) \n                                        | ft ->    \n                                            Some (name, ft, OptionalFieldKind.NotOption)\n                                    match f with\n                                    | M.InstanceField n -> isOption n false\n                                    | M.IndexedField i -> isOption (string i) false\n                                    | M.OptionalField n -> isOption n true\n                                    | M.StaticField _ -> None\n                                jsNameTypeAndOption |> Option.map (fun (jsName, t, optionKind) ->\n                                    jsName, optionKind, encode (t.SubstituteGenerics (Array.ofList targs))\n                                )\n                            ) |> List.ofSeq\n                        let pr =\n                            match comp.GetClassInfo td with\n                            | Some cls -> \n                                addTypeDep td \n                                if cls.HasWSPrototype then\n                                    GlobalAccess cls.Address.Value\n                                else Undefined\n                            | _ -> Undefined\n                        if pr = Undefined && fieldEncoders |> List.forall (fun (_, fo, fe) ->\n                            fo <> OptionalFieldKind.NormalOption && isIdent fe\n                        )\n                        then ok ident\n                        else\n                            ((fun es ->\n                                let es, tts = List.unzip es\n                                ok (call \"Record\" [pr; NewArray es])\n                                ), fieldEncoders)\n                            ||> List.fold (fun k (fn, fo, fe) es ->                     \n                                    fe >>= fun e ->\n                                    k ((NewArray [cString fn; e; cInt (int fo)], t) :: es))\n                            <| []\n                    | _ ->\n                        fail (name + \": Type not supported: \" + t.TypeDefinition.Value.FullName)\n            encode t\n\n        let encodeLambda name param t =\n            getEncoding name true param t\n            |> mapOk (fun x -> Application(x, [], Pure, Some 0))\n\n        let encode name param t arg =\n            encodeLambda name param t\n            |> mapOk (fun x -> Application(x, [arg], Pure, Some 1))\n\n        let decodeLambda name param t =\n            getEncoding name false param t\n            |> mapOk (fun x -> Application(x, [], Pure, Some 0))\n\n        let decode name param t arg =\n            decodeLambda name param t\n            |> mapOk (fun x -> Application(x, [arg], Pure, Some 1))\n\n    let Encode param t arg =\n        // ENCODE()(arg)\n        encode \"Encode\" param t arg\n\n    let EncodeLambda warn t =\n        // ENCODE()\n        encodeLambda \"EncodeLambda\" warn t\n\n    let Serialize param t arg =\n        // JSON.stringify(ENCODE()(arg))\n        encode \"Serialize\" param t arg\n        |> mapOk (fun x -> mJson param.Compilation \"Stringify\" [x])\n\n    let SerializeLambda param t =\n        encodeLambda \"SerializeLambda\" param t\n        |> mapOk (fun x ->\n            let enc = Id.New(mut = false)\n            let arg = Id.New(mut = false)\n            // let enc = ENCODE() in fun arg -> JSON.stringify(enc(arg))\n            Let(enc, x,\n                Lambda([arg],\n                    mJson param.Compilation \"Stringify\" [Application(Var enc, [Var arg], Pure, Some 1)])))\n\n    let Decode param t arg =\n        // DECODE()(arg)\n        decode \"Decode\" param t arg\n\n    let DecodeLambda param t =\n        // DECODE()\n        decodeLambda \"DecodeLambda\" param t\n\n    let Deserialize param t arg =\n        // DECODE()(JSON.parse(arg))\n        decode \"Deserialize\" param t (mJson param.Compilation \"Parse\" [arg])\n\n    let DeserializeLambda param t =\n        decodeLambda \"DeserializeLambda\" param t\n        |> mapOk (fun x ->\n            let dec = Id.New(mut = false)\n            let arg = Id.New(mut = false)\n            // let dec = DECODE() in fun arg -> dec(JSON.parse(arg))\n            Let(dec, x,\n                Lambda([arg],\n                    Application(Var dec, [mJson param.Compilation \"Parse\" [Var arg]], Pure, Some 1))))\n\n    type SerializeMacro() =\n        inherit WebSharper.Core.Macro()\n\n        static let rec last = function\n            | [x] -> x\n            | x :: l -> last l\n            | _ -> failwith \"\"\n\n        override this.TranslateCall(c) =\n            let f =\n                match c.Method.Entity.Value.MethodName with\n                | \"Encode\" -> Encode\n                | \"Decode\" -> Decode\n                | \"Serialize\" -> Serialize\n                | \"Deserialize\" -> Deserialize\n                | _ -> failwith \"Invalid macro invocation\"\n            let param = \n                {\n                    Compilation = c.Compilation\n                    Warnings = ResizeArray()\n                    Dependencies = ResizeArray()\n                }\n            let res =\n                match f param c.Method.Generics.Head (last c.Arguments) with\n                | Choice1Of3 x -> WebSharper.Core.MacroOk x\n                | Choice2Of3 e -> WebSharper.Core.MacroError e\n                | Choice3Of3 t -> WebSharper.Core.MacroNeedsResolvedTypeArg t\n            let resWithWarnings =\n                if param.Warnings.Count > 0 then\n                    param.Warnings |> Seq.fold (fun res msg -> \n                        WebSharper.Core.MacroWarning (msg, res)) res\n                else res\n            if param.Dependencies.Count > 0 then\n                WebSharper.Core.MacroDependencies (List.ofSeq param.Dependencies, resWithWarnings)\n            else resWithWarnings    \nopen Macro\n\n/// Encodes an object in such a way that JSON stringification\n/// results in the same readable format as Sitelets.\n/// Client-side only.\n[<Macro(typeof<SerializeMacro>)>]\nlet Encode<'T> (x: 'T) = X<obj>\n\n/// Serializes an object to JSON using the same readable format as Sitelets.\n/// For plain JSON stringification, see Json.Stringify.\n[<Macro(typeof<SerializeMacro>)>]\nlet Serialize<'T> (x: 'T) =\n    ServerSideProvider.GetEncoder<'T>().Encode x\n    |> ServerSideProvider.Pack\n    |> Core.Json.Stringify\n\n/// Decodes an object parsed from the same readable JSON format as Sitelets.\n/// Client-side only.\n[<Macro(typeof<SerializeMacro>)>]\nlet Decode<'T> (x: obj) = X<'T>\n\n/// Deserializes a JSON string using the same readable format as Sitelets.\n/// For plain JSON parsing, see Json.Parse.\n[<Macro(typeof<SerializeMacro>)>]\nlet Deserialize<'T> (x: string) =\n    Core.Json.Parse x\n    |> ServerSideProvider.GetDecoder<'T>().Decode\n\n/// Test the shape of a JSON encoded value.\n/// Client-side only.\nlet (|Object|Array|Number|String|Boolean|Undefined|) (o: WebSharper.Core.Json.Encoded) =\n    match JS.TypeOf o with\n    | JS.Kind.Boolean -> Boolean (As<bool> o)\n    | JS.Kind.Number -> Number (As<float> o)\n    | JS.Kind.String -> String (As<string> o)\n    | JS.Kind.Undefined -> Undefined o\n    | JS.Kind.Function -> failwith \"\"\n    | JS.Kind.Object ->\n        if JS.InstanceOf o JS.Window?Array then\n            Array (As<WebSharper.JavaScript.Array<WebSharper.Core.Json.Encoded>> o)\n        else\n            Object (As<WebSharper.JavaScript.Object<WebSharper.Core.Json.Encoded>> o)\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.Web\n\nopen WebSharper\nopen WebSharper.Core\n\nmodule M = WebSharper.Core.Metadata\nmodule R = WebSharper.Core.AST.Reflection\n//module P = WebSharper.Core.JavaScript.Packager\n\n/// A server-side control that adds a runtime dependency on a given resource.\ntype Require (t: System.Type, [<System.ParamArray>] parameters: obj[]) =\n    inherit System.Web.UI.Control()\n\n    let t = AST.Reflection.ReadTypeDefinition t\n    let req = \n        [M.ResourceNode (t, \n            if parameters.Length = 0 then None else Some(M.ParameterObject.OfObj parameters))]\n\n    interface INode with\n        member this.Write(_, _) = ()\n        member this.IsAttribute = false\n\n    interface IRequiresResources with\n        member this.Encode(_, _) = []\n        member this.Requires = req :> _\n\n    override this.OnLoad _ =\n        this.ID <- ScriptManager.Find(base.Page).Register None this\n\n    override this.Render _ = ()\n\n/// A server-side control that adds a runtime dependency on a given resource.\ntype Require<'T when 'T :> Resources.IResource>() =\n    inherit Require(typeof<'T>)\n\n/// A base class for defining custom ASP.NET controls. Inherit from this class,\n/// override the Body property and use the new class as a Server ASP.NET\n/// control in your application.\n[<AbstractClass>]\ntype Control() =\n    inherit System.Web.UI.Control()\n\n    static let gen = System.Random()\n    [<System.NonSerialized>]\n    let mutable id = System.String.Format(\"ws{0:x}\", gen.Next().ToString())\n\n    override this.ID\n        with get () = id\n        and set x = id <- x\n\n    override this.OnLoad _ =\n        this.ID <- ScriptManager.Find(base.Page).Register (Some id) this\n\n    interface INode with\n        member this.IsAttribute = false\n        member this.Write (_, w) =\n            w.Write(\"\"\"<div id=\"{0}\"></div>\"\"\", this.ID)\n\n    [<JavaScript>]\n    abstract member Body : IControlBody\n\n    interface IControl with\n        [<JavaScript>]\n        member this.Body = this.Body\n        member this.Id = this.ID\n\n    member this.GetBodyNode() =\n        let t = this.GetType()\n        let t = if t.IsGenericType then t.GetGenericTypeDefinition() else t\n        let m = t.GetProperty(\"Body\").GetGetMethod()\n        M.MethodNode (R.ReadTypeDefinition t, R.ReadMethod m)\n\n    interface IRequiresResources with\n        member this.Requires =\n            this.GetBodyNode() |> Seq.singleton\n\n        member this.Encode(meta, json) =\n            [this.ID, json.GetEncoder(this.GetType()).Encode this]\n\n    override this.Render writer =\n        writer.WriteLine(\"<div id='{0}'></div>\", this.ID)\n\nopen WebSharper.JavaScript\nopen Microsoft.FSharp.Quotations\nopen Microsoft.FSharp.Quotations.Patterns\n\n/// Implements a web control based on a quotation-wrapped top-level body.\n/// Use the function ClientSide to create an InlineControl.\n\ntype private FSV = Reflection.FSharpValue\n\n[<CompiledName \"FSharpInlineControl\">]\ntype InlineControl<'T when 'T :> IControlBody>(elt: Expr<'T>) =\n    inherit Control()\n\n    [<System.NonSerialized>]\n    let elt = elt\n\n    let getLocation() =\n        let (|Val|_|) e : 't option =\n            match e with\n            | Quotations.Patterns.Value(:? 't as v,_) -> Some v\n            | _ -> None\n        let l =\n            elt.CustomAttributes |> Seq.tryPick (function\n                | NewTuple [ Val \"DebugRange\";\n                             NewTuple [ Val (file: string)\n                                        Val (startLine: int)\n                                        Val (startCol: int)\n                                        Val (endLine: int)\n                                        Val (endCol: int) ] ] ->\n                    Some (sprintf \"%s: %i.%i-%i.%i\" file startLine startCol endLine endCol)\n                | _ -> None)\n        defaultArg l \"(no location)\"\n\n    static let ctrlReq = M.TypeNode (R.ReadTypeDefinition typeof<InlineControl<IControlBody>>)\n\n    [<System.NonSerialized>]\n    let bodyAndReqs =\n        let declType, meth, args, fReqs, subs =\n            let elt =\n                match elt :> Expr with\n                | Coerce (e, _) -> e\n                | e -> e\n            let rec get subs expr =\n                match expr with\n                | PropertyGet(None, p, args) ->\n                    let m = p.GetGetMethod(true)\n                    let dt = R.ReadTypeDefinition p.DeclaringType\n                    let meth = R.ReadMethod m\n                    dt, meth, args, [M.MethodNode (dt, meth)], subs\n                | Call(None, m, args) ->\n                    let dt = R.ReadTypeDefinition m.DeclaringType\n                    let meth = R.ReadMethod m\n                    dt, meth, args, [M.MethodNode (dt, meth)], subs\n                | Let(var, value, body) ->\n                    get (subs |> Map.add var value) body\n                | e -> failwithf \"Wrong format for InlineControl at %s: expected global value or function access, got: %A\" (getLocation()) e\n            get Map.empty elt\n        let args, argReqs =\n            args\n            |> List.mapi (fun i value ->\n                let rec get expr =\n                    match expr with\n                    | Value (v, t) ->\n                        let v = match v with null -> WebSharper.Core.Json.Internal.MakeTypedNull t | _ -> v\n                        v, M.TypeNode (R.ReadTypeDefinition t)\n                    | TupleGet(v, i) ->\n                        let v, n = get v\n                        FSV.GetTupleField(v, i), n\n                    | Var v when subs.ContainsKey v ->\n                        get subs.[v]   \n                    | _ -> failwithf \"Wrong format for InlineControl at %s: argument #%i is not a literal or a local variable\" (getLocation()) (i+1)\n                get value\n            )\n            |> List.unzip\n        let args = Array.ofList args\n        let reqs = ctrlReq :: fReqs @ argReqs\n        args, (declType, meth, reqs)\n\n    let args = fst bodyAndReqs\n    let mutable funcName = [||]\n\n    [<JavaScript>]\n    override this.Body =\n        let f = Array.fold (?) JS.Window funcName\n        As<Function>(f).ApplyUnsafe(null, args) :?> _\n\n    interface IRequiresResources with\n        member this.Encode(meta, json) =\n            if funcName.Length = 0 then\n                let declType, meth, reqs = snd bodyAndReqs\n                let fail() =\n                    failwithf \"Error in InlineControl at %s: Couldn't find translation of method %s.%s. The method or type should have JavaScript attribute or a proxy, and the assembly needs to be compiled with WsFsc.exe\" \n                        (getLocation()) declType.Value.FullName meth.Value.MethodName\n                match meta.Classes.TryFind declType with\n                | None -> fail()\n                | Some cls ->\n                    match cls.Methods.TryFind meth with\n                    | Some (M.Static a, _, _) ->\n                        funcName <- Array.ofList (List.rev a.Value)\n                    | Some _ ->\n                        failwithf \"Error in InlineControl at %s: Method %s.%s must be static and not inlined\"\n                            (getLocation()) declType.Value.FullName meth.Value.MethodName\n                    | None -> fail()\n            [this.ID, json.GetEncoder(this.GetType()).Encode this]\n\n        member this.Requires =\n            let _, _, reqs = snd bodyAndReqs \n            this.GetBodyNode() :: reqs |> Seq.ofList\n\nopen System\nopen System.Reflection\nopen System.Linq.Expressions\n\n// TODO: test in arguments: needs .NET 4.5\n// open System.Runtime.CompilerServices\n//[<CallerFilePath; Optional>] sourceFilePath \n//[<CallerLineNumber; Optional>] sourceLineNumber\n[<CompiledName \"InlineControl\">]\ntype CSharpInlineControl(elt: System.Linq.Expressions.Expression<Func<IControlBody>>) =\n    inherit Control()\n\n    [<System.NonSerialized>]\n    let elt = elt\n\n    static let ctrlReq = M.TypeNode (R.ReadTypeDefinition typeof<InlineControl<IControlBody>>)\n\n    [<System.NonSerialized>]\n    let bodyAndReqs =\n        let reduce (e: Expression) = if e.CanReduce then e.Reduce() else e\n        let declType, meth, args, fReqs =\n            match reduce elt.Body with\n            | :? MemberExpression as e ->\n                match e.Member with\n                | :? PropertyInfo as p ->\n                    let m = p.GetGetMethod(true)\n                    let dt = R.ReadTypeDefinition p.DeclaringType\n                    let meth = R.ReadMethod m\n                    dt, meth, [], [M.MethodNode (dt, meth)]\n                | _ -> failwith \"member must be a property\"\n            | :? MethodCallExpression as e -> \n                let m = e.Method\n                let dt = R.ReadTypeDefinition m.DeclaringType\n                let meth = R.ReadMethod m\n                dt, meth, e.Arguments |> List.ofSeq, [M.MethodNode (dt, meth)]\n            | e -> failwithf \"Wrong format for InlineControl: expected global value or function access, got: %A\"  e\n        let args, argReqs =\n            args\n            |> List.mapi (fun i a -> \n                let rec get needType (a: Expression) =\n                    match reduce a with\n                    | :? ConstantExpression as e ->\n                        let v = match e.Value with null -> WebSharper.Core.Json.Internal.MakeTypedNull e.Type | _ -> e.Value\n                        v, if needType then M.TypeNode (R.ReadTypeDefinition e.Type) else M.EntryPointNode\n                    | :? MemberExpression as e ->\n                        let o = \n                            match e.Expression with\n                            | null -> null\n                            | ee -> fst (get false ee)\n                        match e.Member with\n                        | :? FieldInfo as f ->\n                            f.GetValue(o), if needType then M.TypeNode (R.ReadTypeDefinition f.FieldType) else M.EntryPointNode\n                        | :? PropertyInfo as p ->\n                            if p.GetIndexParameters().Length > 0 then\n                                failwithf \"Wrong format for InlineControl in argument #%i, indexed property not allowed\" (i+1)\n                            p.GetValue(o, null), if needType then M.TypeNode (R.ReadTypeDefinition p.PropertyType) else M.EntryPointNode\n                        | m -> failwithf \"Wrong format for InlineControl in argument #%i, member access not allowed: %s\" (i+1) (m.GetType().Name)\n                    | a -> failwithf \"Wrong format for InlineControl in argument #%i, expression type: %s\" (i+1) (a.GetType().Name)\n                get true a\n            )\n            |> List.unzip\n        let args = Array.ofList args\n        let reqs = ctrlReq :: fReqs @ argReqs\n        args, (declType, meth, reqs)\n\n    let args = fst bodyAndReqs\n    let mutable funcName = [||]\n\n    [<JavaScript>]\n    override this.Body =\n        let f = Array.fold (?) JS.Window funcName\n        As<Function>(f).ApplyUnsafe(null, args) :?> _\n\n    interface IRequiresResources with\n        member this.Encode(meta, json) =\n            if funcName.Length = 0 then\n                let declType, meth, reqs = snd bodyAndReqs\n                let fail() =\n                    failwithf \"Error in InlineControl: Couldn't find translation of method %s.%s. The method or type should have JavaScript attribute or a proxy, and the project file needs to include Zafir.CSharp.targets\" \n                        declType.Value.FullName meth.Value.MethodName\n                match meta.Classes.TryFind declType with\n                | None -> fail()\n                | Some cls ->\n                    match cls.Methods.TryFind meth with\n                    | Some (M.Static a, _, _) ->\n                        funcName <- Array.ofList (List.rev a.Value)\n                    | Some _ -> \n                        failwithf \"Error in InlineControl: Method %s.%s must be static and not inlined\"\n                            declType.Value.FullName meth.Value.MethodName\n                    | None -> fail()\n            [this.ID, json.GetEncoder(this.GetType()).Encode this]\n\n        member this.Requires =\n            let _, _, reqs = snd bodyAndReqs \n            this.GetBodyNode() :: reqs |> Seq.ofList\n\nnamespace WebSharper\n\n[<AutoOpen>]\nmodule WebExtensions =\n\n    open Microsoft.FSharp.Quotations\n\n    /// Embed the given client-side control body in a server-side control.\n    /// The client-side control body must be either a module-bound or static value,\n    /// or a call to a module-bound function or static method, and all arguments\n    /// must be either literals or references to local variables.\n    let ClientSide (e: Expr<#IControlBody>) =\n        new WebSharper.Web.InlineControl<_>(e)\n"],
"names": [],
"mappings": "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"
}
