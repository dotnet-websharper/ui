{
"version": 3,
"sourceRoot": "Source",
"sources": ["WebSharper.Main/Macro.fs", "WebSharper.Main/JavaScript.Pervasives.fs", "WebSharper.Main/Json.fs", "WebSharper.Main/Remoting.fs", "WebSharper.Main/Html.fs", "WebSharper.Main/Utils.fs", "WebSharper.Main/Concurrency.fs", "WebSharper.Main/Enumerator.fs", "WebSharper.Main/CollectionInternals.fs", "WebSharper.Main/Object.fs", "WebSharper.Main/IntrinsicFunctions.fs", "WebSharper.Main/Array.fs", "WebSharper.Main/ArrayModule.fs", "WebSharper.Main/Array2DModule.fs", "WebSharper.Main/Async.fs", "WebSharper.Main/Char.fs", "WebSharper.Main/CommonExtensions.fs", "WebSharper.Main/DateTime.fs", "WebSharper.Main/Delegate.fs", "WebSharper.Main/Dictionary.fs", "WebSharper.Main/Exception.fs", "WebSharper.Main/ExtraTopLevelOperators.fs", "WebSharper.Main/HashSet.fs", "WebSharper.Main/Interfaces.fs", "WebSharper.Main/LazyExtensions.fs", "WebSharper.Main/List.fs", "WebSharper.Main/ListModule.fs", "WebSharper.Main/Nullable.fs", "WebSharper.Main/Operators.fs", "WebSharper.Main/OperatorIntrinsics.fs", "WebSharper.Main/OptionModule.fs", "WebSharper.Main/Queue.fs", "WebSharper.Main/Random.fs", "WebSharper.Main/ResultModule.fs", "WebSharper.Main/RuntimeHelpers.fs", "WebSharper.Main/SeqModule.fs", "WebSharper.Main/Stack.fs", "WebSharper.Main/String.fs", "WebSharper.Main/Task.fs", "WebSharper.Main/Unchecked.fs", "WebSharper.Main/Primitives.fs"],
"sourcesContent": ["// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2014 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n/// Defines macros used by proxy definitions.\n[<CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]\nmodule WebSharper.Macro\n\nopen System.Collections.Generic\nopen System.Text.RegularExpressions\n\nopen WebSharper\nopen WebSharper.Core\nopen WebSharper.Core.AST\n\nmodule M = WebSharper.Core.Metadata\nmodule I = IgnoreSourcePos\n\nlet scalarTypes =\n    integralTypes\n    + Set [\n        \"System.Double\"\n        \"System.Single\"\n        \"System.String\" \n        \"System.TimeSpan\"\n        \"System.DateTime\"\n    ]\n\nlet comparableTypes =\n    scalarTypes\n    + Set [\n        \"System.Char\"\n    ]\n\nlet isIn (s: string Set) (t: Type) = \n    match t with\n    | ConcreteType t ->\n        s.Contains t.Entity.Value.FullName\n    | _ ->\n        false\n\nlet traitCallOp (c: MacroCall) args =\n    match c.Method.Generics with\n    | [t; u; v] ->\n        TraitCall(\n            [ t; u ], \n            NonGeneric (\n                Method {\n                    MethodName = c.Method.Entity.Value.MethodName\n                    Parameters = [ t; u ]\n                    ReturnType = v\n                    Generics = 0\n                }\n            ),\n            args\n        )\n    | _ ->\n        failwith \"F# Operator value expecting 3 type arguments\"\n    \nlet utilsModule =\n    TypeDefinition {\n        FullName = \"WebSharper.Utils\"\n        Assembly = \"WebSharper.Main\"\n    }\nlet utils (comp: M.ICompilation) f args = \n    let m = comp.GetClassInfo(utilsModule).Value.Methods.Keys |> Seq.find (fun m -> m.Value.MethodName = f)\n    Call(None, NonGeneric utilsModule, NonGeneric m, args)\n\nlet translateOperation (c: MacroCall) (t: Type) args leftNble rightNble op =\n    match args with\n    | [x; y] ->\n        let a, b, lambda =\n            if leftNble || rightNble then\n                let a = Id.New \"a\"\n                let b = Id.New \"b\"\n                Var a, Var b, fun res -> CurriedLambda([a; b], res)\n            else\n                x, y, id\n        let res =\n            if op = BinaryOperator.``/`` then\n                if isIn smallIntegralTypes t\n                then (a ^/ b) ^>> !~(Int 0)\n                elif isIn bigIntegralTypes t\n                then Application(Global [\"Math\"; \"trunc\"], [a ^/ b], Pure, Some 1)\n                elif isIn scalarTypes t\n                then a ^/ b\n                else traitCallOp c [a; b]\n            else\n                if isIn scalarTypes t then\n                    Binary(a, op, y)\n                else traitCallOp c [a; b]\n        match leftNble, rightNble with\n        | false, false -> res\n        | true , false -> utils c.Compilation \"nullableOpL\" [ x; y; lambda res ]\n        | false, true  -> utils c.Compilation \"nullableOpR\" [ x; y; lambda res ]\n        | true , true  -> utils c.Compilation \"nullableOp\"  [ x; y; lambda res ]\n        |> MacroOk\n    | _ -> MacroError \"arithmetic macro error\"\n\n[<Sealed>]\ntype Arith() =\n    inherit Macro()\n    override this.TranslateCall(c) =\n        let opName = c.Method.Entity.Value.MethodName\n        let leftNble = opName.StartsWith \"op_Qmark\"\n        let rightNble = opName.EndsWith \"Qmark\"\n        let simpleOpName = if leftNble || rightNble then opName.Replace(\"Qmark\", \"\") else opName\n        let op =\n            match simpleOpName with\n            | BinaryOpName op -> op\n            | \"op_Plus\" -> BinaryOperator.``+``\n            | \"op_Minus\" -> BinaryOperator.``-``\n            | \"op_Divide\" -> BinaryOperator.``/``\n            | \"op_Percent\" -> BinaryOperator.``%``\n            | n -> failwithf \"unrecognized operator for Arith macro: %s\" n\n        match c.Method.Generics with\n        | t :: _ ->\n            translateOperation c t c.Arguments leftNble rightNble op\n        | _ -> MacroError \"arithmetic macro error\"\n\ntype Comparison =\n    | ``<``  = 0\n    | ``<=`` = 1\n    | ``>``  = 2\n    | ``>=`` = 3\n    | ``=``  = 4\n    | ``<>`` = 5\n\nlet toBinaryOperator cmp =\n    match cmp with\n    | Comparison.``<``  -> BinaryOperator.``<``\n    | Comparison.``<=`` -> BinaryOperator.``<=``\n    | Comparison.``>``  -> BinaryOperator.``>``\n    | Comparison.``>=`` -> BinaryOperator.``>=``\n    | Comparison.``=``  -> BinaryOperator.``===``\n    | _                 -> BinaryOperator.``!==``\n\nlet opUncheckedTy, equalsMeth, compareMeth =\n    match <@ Unchecked.equals 1 1 @> with\n    | FSharp.Quotations.Patterns.Call (_, mi, _) ->\n        let cmi = mi.DeclaringType.GetMethod(\"Compare\")\n        Reflection.ReadTypeDefinition mi.DeclaringType,\n        Reflection.ReadMethod mi,\n        Reflection.ReadMethod cmi\n    | _ -> failwith \"Expecting a Call pattern\"\n\nlet makeComparison cmp x y =\n    let eq x y = Call (None, NonGeneric opUncheckedTy, NonGeneric equalsMeth, [x; y]) \n    let c b i = Binary (Call(None, NonGeneric opUncheckedTy, NonGeneric compareMeth, [x; y]), b, Value(Int i))\n    match cmp with\n    | Comparison.``<``  -> c BinaryOperator.``===`` -1\n    | Comparison.``<=`` -> c BinaryOperator.``<=`` 0\n    | Comparison.``>``  -> c BinaryOperator.``===`` 1\n    | Comparison.``>=`` -> c BinaryOperator.``>=`` 0\n    | Comparison.``=``  -> eq x y\n    | _                 -> Unary (UnaryOperator.``!``, eq x y)\n\nlet cInt i = Value (Int i)\nlet cString s = Value (Literal.String s)\n\nlet isComparison = function\n    | BinaryOperator.``<`` | BinaryOperator.``>`` | BinaryOperator.``<=`` \n    | BinaryOperator.``>=`` | BinaryOperator.``==`` | BinaryOperator.``!=`` -> true\n    | _ -> false\n\nlet isOperation = function\n    | BinaryOperator.``%`` | BinaryOperator.``*`` | BinaryOperator.``+``\n    | BinaryOperator.``-`` | BinaryOperator.``/``\n    | BinaryOperator.``<<`` | BinaryOperator.``>>`` | BinaryOperator.``|``\n    | BinaryOperator.``&`` | BinaryOperator.``^``\n    | BinaryOperator.``&&`` | BinaryOperator.``||`` -> true\n    | _ -> false\n\nlet toComparison = function\n    | BinaryOperator.``<`` -> Comparison.``<``\n    | BinaryOperator.``>`` -> Comparison.``>``\n    | BinaryOperator.``<=`` -> Comparison.``<=``\n    | BinaryOperator.``>=`` -> Comparison.``>=``\n    | BinaryOperator.``==`` -> Comparison.``=``\n    | BinaryOperator.``!=`` -> Comparison.``<>``\n    | _ -> failwith \"Operation wasn't a comparison\"\n\nlet translateComparison (c: M.ICompilation) t args leftNble rightNble cmp =\n    match args with\n    | [x; y] ->\n        let a, b, lambda =\n            if leftNble || rightNble then\n                let a = Id.New \"a\"\n                let b = Id.New \"b\"\n                Var a, Var b, fun res -> CurriedLambda([a; b], res)\n            else\n                x, y, id\n        let comp x y =\n            Binary (x, toBinaryOperator cmp, y)\n        let res =\n            if isIn comparableTypes t then\n                comp a b\n            else\n                // optimization for checking against argumentless union cases \n                let tryGetSingletonUnionCaseTag (x: Expression) =\n                    match x with\n                    | I.NewUnionCase(ct, case, []) ->\n                        match c.GetCustomTypeInfo ct.Entity with\n                        | M.FSharpUnionInfo ui when not ui.HasNull ->\n                            ui.Cases |> Seq.mapi (fun i c ->\n                                if c.Name = case && c.Kind = M.SingletonFSharpUnionCase then Some i else None\n                            ) |> Seq.tryPick id         \n                        | _ -> None\n                    | _ -> None\n                    \n                match tryGetSingletonUnionCaseTag x, tryGetSingletonUnionCaseTag y with\n                | Some i, Some j -> comp (cInt i) (cInt j)\n                | Some i, _ -> comp (cInt i) (y.[cString \"$\"])\n                | _, Some j -> comp (x.[cString \"$\"]) (cInt j)\n                | _ -> makeComparison cmp a b\n        match leftNble, rightNble with\n        | false, false -> res\n        | true , false -> utils c \"nullableCmpL\" [ x; y; lambda res ]\n        | false, true  -> utils c \"nullableCmpR\" [ x; y; lambda res ]\n        | true , true  -> \n            match cmp with\n            | Comparison.``<=`` \n            | Comparison.``>=`` \n            | Comparison.``=`` \n                -> utils c \"nullableCmpE\" [ x; y; lambda res ]\n            | _ -> utils c \"nullableCmp\"  [ x; y; lambda res ] \n        |> MacroOk\n    | _ ->\n        MacroError \"comparisonMacro error\"\n\n[<Sealed>]\ntype Comp() =\n    inherit Macro()\n    override this.TranslateCall(c) =\n        let opName = c.Method.Entity.Value.MethodName\n        let leftNble = opName.StartsWith \"op_Qmark\"\n        let rightNble = opName.EndsWith \"Qmark\"\n        let simpleOpName = if leftNble || rightNble then opName.Replace(\"Qmark\", \"\") else opName\n        let cmp =\n            match simpleOpName with\n            | BinaryOpName op -> toComparison op\n            | \"op_Equals\" -> Comparison.``=``\n            | \"op_LessGreater\" -> Comparison.``<>``\n            | \"op_Greater\" -> Comparison.``>``\n            | \"op_Less\" -> Comparison.``<``\n            | \"op_GreaterEquals\" -> Comparison.``>=``\n            | \"op_LessEquals\" -> Comparison.``<=``\n            | n -> failwithf \"unrecognized operator for for Comp macro: %s\" n\n        match c.Method.Generics with\n        | t :: _ ->\n            translateComparison c.Compilation t c.Arguments leftNble rightNble cmp\n        | _ ->\n            MacroError \"comparisonMacro error\"\n\nlet formatExceptionTy, formatExceptionCtor =\n    match <@ new System.FormatException() @> with\n    | FSharp.Quotations.Patterns.NewObject (ci, _) ->\n        Reflection.ReadTypeDefinition ci.DeclaringType,\n        Reflection.ReadConstructor ci\n    | _ -> failwith \"Expected constructor call\"\n\nlet parseInt x =\n    Application(Global [\"parseInt\"], [x], Pure, Some 1)\nlet toNumber x =\n    Application(Global [\"Number\"], [x], Pure, Some 1)\n\n[<Sealed>]\ntype NumericMacro() =\n    inherit Macro()\n\n    let exprParse parsed tru fls =\n        let id = Id.New(mut = false)\n        Let (id, parsed,\n            Conditional(Application(Global [\"isNaN\"], [Var id], Pure, Some 1),\n                tru id,\n                fls id\n            )\n        )\n\n    override this.TranslateCall(c) =\n        let name = c.DefiningType.Entity.Value.FullName\n\n        let ex =\n            Ctor(\n                NonGeneric formatExceptionTy,\n                formatExceptionCtor,\n                [Value (String \"Input string was not in a correct format.\")]\n            )\n\n        let isNble t =\n            match t with\n            | VoidType -> true\n            | ConcreteType { Entity = td } when td.Value.FullName = \"System.Nullable`1\" -> true\n            | _ -> false\n\n        match c.Method.Entity.Value.MethodName with\n        | BinaryOpName op when isOperation op ->\n            let leftNble, rightNble =\n                match c.Method.Generics with\n                | [lt; rt] -> isNble lt, isNble rt\n                | _ -> false, false\n            translateOperation c (ConcreteType c.DefiningType) c.Arguments leftNble rightNble op\n        | BinaryOpName op when isComparison op ->\n            let leftNble, rightNble =\n                match c.Method.Generics with\n                | [lt; rt] -> isNble lt, isNble rt\n                | _ -> false, false\n            let cmp = toComparison op\n            translateComparison c.Compilation (ConcreteType c.DefiningType) c.Arguments leftNble rightNble cmp\n        | UnaryOpName op ->\n            match c.Arguments with\n            | [x] -> Unary (op, x) |> MacroOk\n            | _ -> MacroError \"numericMacro error\"\n        | \"op_Increment\" ->\n            match c.Arguments with\n            | [x] ->\n                MacroOk (Binary(x, BinaryOperator.``+``, Value (Int 1)))\n            | _ -> MacroError \"numericMacro error\"\n        | \"op_Decrement\" ->\n            match c.Arguments with\n            | [x] ->\n                MacroOk (Binary(x, BinaryOperator.``-``, Value (Int 1)))\n            | _ -> MacroError \"numericMacro error\"\n        | \"ToString\" ->\n            match c.This with\n            | Some self ->\n                // TODO refactor to separate method\n                if c.DefiningType.Entity.Value.AssemblyQualifiedName = \"System.Char, mscorlib\" then\n                    self\n                else \n                    Application(Global [\"String\"], [self], Pure, Some 1)\n                |> MacroOk \n            | _ -> MacroError \"numericMacro error\"\n        | \"Parse\" ->\n            match c.Arguments with\n            | [x] ->\n                if name = \"System.Single\" || name = \"System.Double\" then\n                    exprParse\n                    <| toNumber x\n                    <| fun _ -> ex\n                    <| fun id -> Var id\n                    |> MacroOk\n                else MacroError \"numericMacro error\"\n            | _ -> MacroError \"numericMacro error\"\n        | \"TryParse\" ->\n            match c.Arguments with\n            | [x; y] ->\n                if name = \"System.Single\" || name = \"System.Double\" then\n                    exprParse\n                    <| toNumber x\n                    <| fun _ -> Value (Bool false)\n                    <| fun id ->\n                        Expression.Sequential [\n                            SetRef y (Var id)\n                            Value (Bool true)\n                        ]\n                    |> MacroOk\n                else MacroError \"numericMacro error\"\n            | _ -> MacroError \"numericMacro error\"\n        | _ -> MacroFallback\n\nlet charTy, charParse =\n    let t = typeof<System.Char>\n    Reflection.ReadTypeDefinition t,\n    Reflection.ReadMethod (t.GetMethod \"Parse\")\n\n[<Sealed>]\ntype Char() =\n    inherit Macro()\n    override this.TranslateCall(c) =\n        match c.Arguments with\n        | [x] ->\n            match c.Method.Generics with\n            | t :: _ ->\n                let fromNum() = \n                    Application(Global [\"String\"; \"fromCharCode\"], [x], Pure, Some 1)\n                    |> MacroOk\n                if isIn integralTypes t then fromNum() else\n                    match t with\n                    | ConcreteType d ->\n                        match d.Entity.Value.FullName with\n                        | \"System.String\" ->\n                            Call (None, NonGeneric charTy, NonGeneric charParse, [x])\n                            |> MacroOk\n                        | \"System.Char\" -> MacroOk x\n                        | \"System.Double\"\n                        | \"System.Single\" -> fromNum()\n                        | _ -> MacroError \"charMacro error\"\n                    | _ ->\n                        MacroError \"charMacro error\"\n            | _ ->\n                MacroError \"charMacro error\"\n        | _ ->\n            MacroError \"charMacro error\"\n\n[<Sealed>]\ntype Range() =\n    inherit Macro()\n    override this.TranslateCall(c) =\n        match c.Method.Generics with\n        | t :: _ ->\n            match t with\n            | ConcreteType d ->\n                match d.Entity.Value.FullName with\n                | \"System.Char\" -> \n                    utils c.Compilation \"charRange\" c.Arguments |> MacroOk   \n                | _ -> MacroFallback\n            | _ -> MacroFallback\n        | _ -> MacroError \"Range macro error\"\n\n[<Sealed>]\ntype Conversion() =\n    inherit Macro()\n    override this.TranslateCall(c) =\n        let isNble =\n            c.DefiningType.Entity.Value.FullName = \"Microsoft.FSharp.Linq.NullableModule\"\n        let m = c.Method\n        let x = c.Arguments.Head\n        let a, withNbleSupport = \n            if isNble then\n                let a = Id.New \"a\"\n                Var a, fun res -> utils c.Compilation \"nullableConv\" [ x; Lambda([a], res) ] \n            else \n                x, id\n        let (|OptNbleTypeDef|_|) t =\n            match t with\n            | ConcreteType { Entity = tt; Generics = g } ->\n                if tt.Value.FullName = \"System.Nullable`1\" then\n                    match g.Head with\n                    | ConcreteType { Entity = tt } -> Some tt\n                    | _ -> None\n                else Some tt\n            | _ -> None\n            \n        match m.Generics.Head, m.Entity.Value.ReturnType with\n        | OptNbleTypeDef ft, OptNbleTypeDef tt ->\n            NumericConversion ft tt a |> withNbleSupport |> MacroOk\n        | TypeParameter _, OptNbleTypeDef tt ->\n            let tn = tt.Value.FullName\n            let warnAboutChar res =\n                MacroWarning (\"Unsafe generic conversion for client-side, make sure input cannot be a char\", MacroOk res)\n            if integralTypes.Contains tn then\n                parseInt a |> withNbleSupport |> warnAboutChar\n            elif scalarTypes.Contains tn then\n                toNumber a |> withNbleSupport |> warnAboutChar\n            elif tn = \"System.Char\" then\n                Application(Global [\"String\"; \"fromCharCode\"], [a], Pure, Some 1) |> warnAboutChar\n            else\n                MacroError (\"Conversion macro error: generic to \" + tn)\n        | f, t -> MacroError (sprintf \"Conversion macro error: %O to %O\" f t)\n\n[<Sealed>]\ntype String() =\n    inherit Macro()\n    override this.TranslateCall(c) =\n        match c.Arguments with\n        | [x] ->\n            match c.Method.Generics with\n            | t :: _ ->\n                match t with\n                | ConcreteType d ->\n                    match d.Entity.Value.FullName with\n                    | \"System.Char\" ->\n                        x\n                    | \"System.DateTime\" ->\n                        Application(ItemGet(New(Global [ \"Date\" ], [x]), Value (Literal.String \"toLocaleString\"), Pure), [], Pure, None)\n                    | _ ->\n                        Application(Global [\"String\"], [x], Pure, Some 1)   \n                | _ -> \n                    Application(Global [\"String\"], [x], Pure, Some 1)   \n                |> MacroOk \n            | _ ->\n                MacroError \"stringMacro error\"\n        | [] ->\n            // when unit argument is erased\n            MacroOk (Value (Literal.String \"\"))\n        | _ ->\n            MacroError \"stringMacro error\"\n\nlet fsharpListDef =\n    TypeDefinition {\n        Assembly = \"FSharp.Core\"\n        FullName = \"Microsoft.FSharp.Collections.FSharpList`1\"  \n    }\n\nlet listModuleDef =\n    TypeDefinition {\n        Assembly = \"FSharp.Core\"\n        FullName = \"Microsoft.FSharp.Collections.ListModule\"\n    }\n\nlet listOfArrayDef =\n    Method {\n        MethodName = \"OfArray\"\n        Parameters = [ ArrayType (TypeParameter 0, 1) ]\n        ReturnType = GenericType fsharpListDef [ TypeParameter 0 ]\n        Generics = 1      \n    }\n\nlet getFieldsList q =\n    let ``is (=>)`` (td: TypeDefinition) (m: Method) =\n        td.Value.FullName = \"WebSharper.JavaScript.Pervasives\"\n        && m.Value.MethodName = \"op_EqualsGreater\"\n    let rec getFieldsListTC l q =\n        let trItem i =\n            match IgnoreExprSourcePos i with    \n            | NewArray [I.Value (String n); v] -> n, v \n            | Call (_, td, m, [I.Value (String n); v])\n                when ``is (=>)`` td.Entity m.Entity -> n, v\n            | _ -> failwith \"Wrong type of array passed to New\"\n        match IgnoreExprSourcePos q with\n        | NewUnionCase (_, _, [I.NewArray [I.Value (String n); v]; t]) ->\n            getFieldsListTC ((n, v) :: l) t         \n        | NewUnionCase (_, _, [I.Call (_, td, m, [I.Value (String n); v]); t])\n            when ``is (=>)`` td.Entity m.Entity ->\n            getFieldsListTC ((n, v) :: l) t         \n        | NewUnionCase (_, _, []) -> Some (l |> List.rev) \n        | Call(None, td, m, [ I.NewArray items ]) when td.Entity = listModuleDef && m.Entity = listOfArrayDef ->\n            items |> List.map trItem |> Some\n        | NewArray (items) ->\n            items |> List.map trItem |> Some\n        | _ -> None\n    getFieldsListTC [] q\n\n[<Sealed>]\ntype New() =\n    inherit Macro()\n    override this.TranslateCall(c) =\n        match c.Arguments with\n        | [x] -> \n            match getFieldsList x with\n            | Some xl ->\n                MacroOk <| Object (xl |> List.map (fun (n, v) -> n, v))\n            | _ -> MacroFallback\n        | _ -> MacroError \"New macro Error\"\n\n//type FST = Reflection.FSharpType\n\nmodule JSRuntime =\n    let private runtime = [\"Runtime\"; \"IntelliFactory\"]\n    let private runtimeFunc f p args = Application(GlobalAccess (Address (f :: runtime)), args, p, Some (List.length args))\n    let GetOptional value = runtimeFunc \"GetOptional\" Pure [value]\n    let SetOptional obj field value = runtimeFunc \"SetOptional\" NonPure [obj; field; value]\n    let CreateFuncWithArgs f = runtimeFunc \"CreateFuncWithArgs\" Pure [f]\n    let CreateFuncWithArgsRest length f = runtimeFunc \"CreateFuncWithArgsRest\" Pure [length; f]\n    let CreateFuncWithThis f = runtimeFunc \"CreateFuncWithThis\" Pure [f]\n\n[<Sealed>]\ntype FuncWithArgs() =\n    inherit Macro()\n    override this.TranslateCtor(c) =\n        match c.Arguments with\n        | [func] ->\n            match c.DefiningType.Generics.[0] with\n            | TupleType _ ->\n                JSRuntime.CreateFuncWithArgs func |> MacroOk\n            | _ ->\n                MacroError \"Wrong type argument on FuncWithArgs: 'TArgs must be a tuple\"\n        | _ ->\n            MacroError \"funcWithArgsMacro error\"\n\n[<Sealed>]\ntype FuncWithArgsRest() =\n    inherit Macro()\n    override this.TranslateCtor(c) =\n        match c.Arguments with\n        | [func] ->\n            match c.DefiningType.Generics.[0] with\n            | TupleType (ts, _) ->\n                JSRuntime.CreateFuncWithArgsRest (Value (Int (List.length ts))) func |> MacroOk\n            | _ ->\n                MacroError \"Wrong type argument on FuncWithArgsRest: 'TArgs must be a tuple\"\n        | _ ->\n            MacroError \"funcWithArgsMacro error\"\n\n[<Sealed>]\ntype FuncWithThis() =\n    inherit Macro()\n    override this.TranslateCtor(c) =\n        match c.Arguments with\n        | [func] ->\n            match c.DefiningType.Generics.[0] with\n            | FSharpFuncType _ ->\n                JSRuntime.CreateFuncWithThis func |> MacroOk\n            | ConcreteType td when \n                (\n                    let n = td.Entity.Value.FullName\n                    n = \"WebSharper.JavaScript.Function\" || n.StartsWith \"WebSharper.JavaScript.FuncWith\" \n                ) ->\n                JSRuntime.CreateFuncWithThis func |> MacroOk\n            | _ ->\n                MacroError \"Wrong type argument on FuncWithThis: 'TFunc must be an F# function or JavaScript function type\"\n        | _ ->\n            MacroError \"funcWithArgsMacro error\"\n\nlet ApplItem(on, item, args) = Application(ItemGet(on, Value (AST.String item), Pure), args, NonPure, None)\n\n[<Sealed>]\ntype JSThisCall() =\n    inherit Macro()\n    override __.TranslateCall(c) =\n        match c.This with\n        | Some func ->\n            MacroOk (ApplItem(func, \"call\", c.Arguments))\n        | _ -> MacroError \"JSCall macro error\"\n\n[<Sealed>]\ntype JSParamsCall() =\n    inherit Macro()\n    override __.TranslateCall(c) =\n        match c.This, List.rev c.Arguments with\n        | Some func, pars :: revArgs ->\n            let args = ApplItem(NewArray (List.rev revArgs), \"concat\", [pars])\n            MacroOk (ApplItem(func, \"apply\", [Undefined; args]))\n        | _ -> MacroError \"JSParamsCall macro error\"\n\n[<Sealed>]\ntype JSThisParamsCall() =\n    inherit Macro()\n    override __.TranslateCall(c) =\n        match c.This, c.Arguments with\n        | Some func, this :: afterThis ->\n            match List.rev afterThis with\n            | pars :: revArgs ->    \n                let args = ApplItem(NewArray (List.rev revArgs), \"concat\", [pars])\n                MacroOk (ApplItem(func, \"apply\", [this; args]))\n            | _ -> MacroError \"JSThisParamsCall macro error\"\n        | _ -> MacroError \"JSThisParamsCall macro error\"\n\n[<Sealed>]\ntype GetJS() =\n    inherit Macro()\n    override __.TranslateCall(c) =\n        match c.Arguments with\n        | [ obj ] -> MacroOk obj\n        | [ obj; I.NewArray items ] ->\n            if items |> List.forall (function I.Value _ -> true | _ -> false) then\n                items |> List.fold (fun x i -> ItemGet(x, i, NonPure)) obj |> MacroOk\n            else MacroFallback\n        | [ _; _ ] -> MacroFallback\n        | _ -> MacroError (sprintf \"GetJS macro error, arguments: %+A\" c.Arguments)\n\n/// Set of helpers to parse format string\n/// Source: https://github.com/fsharp/fsharp/blob/master/src/fsharp/FSharp.Core/printf.fs\nmodule private FormatString =\n    [<System.Flags>]\n    type FormatFlags = \n        | None = 0\n        | LeftJustify = 1\n        | PadWithZeros = 2\n        | PlusForPositives = 4\n        | SpaceForPositives = 8\n\n    let inline hasFlag flags (expected : FormatFlags) = (flags &&& expected) = expected\n    let inline isLeftJustify flags = hasFlag flags FormatFlags.LeftJustify\n    let inline isPadWithZeros flags = hasFlag flags FormatFlags.PadWithZeros\n    let inline isPlusForPositives flags = hasFlag flags FormatFlags.PlusForPositives\n    let inline isSpaceForPositives flags = hasFlag flags FormatFlags.SpaceForPositives\n\n    /// Used for width and precision to denote that user has specified '*' flag\n    [<Literal>]\n    let StarValue = -1\n    /// Used for width and precision to denote that corresponding value was omitted in format string\n    [<Literal>]\n    let NotSpecifiedValue = -2\n\n    [<NoComparison; NoEquality>]\n    type FormatSpecifier =\n        {\n            TypeChar : char\n            Precision : int\n            Width : int\n            Flags : FormatFlags\n        }\n        member this.IsStarPrecision = this.Precision = StarValue\n        member this.IsPrecisionSpecified = this.Precision <> NotSpecifiedValue\n        member this.IsStarWidth = this.Width = StarValue\n        member this.IsWidthSpecified = this.Width <> NotSpecifiedValue\n\n    let inline isDigit c = c >= '0' && c <= '9'\n    let intFromString (s : string) pos = \n        let rec go acc i =\n            if isDigit s.[i] then \n                let n = int s.[i] - int '0'\n                go (acc * 10 + n) (i + 1)\n            else acc, i\n        go 0 pos\n\n    let parseFlags (s : string) i : FormatFlags * int = \n        let rec go flags i = \n            match s.[i] with\n            | '0' -> go (flags ||| FormatFlags.PadWithZeros) (i + 1)\n            | '+' -> go (flags ||| FormatFlags.PlusForPositives) (i + 1)\n            | ' ' -> go (flags ||| FormatFlags.SpaceForPositives) (i + 1)\n            | '-' -> go (flags ||| FormatFlags.LeftJustify) (i + 1)\n            | _ -> flags, i\n        go FormatFlags.None i\n\n    let parseWidth (s : string) i : int * int = \n        if s.[i] = '*' then StarValue, (i + 1)\n        elif isDigit (s.[i]) then intFromString s i\n        else NotSpecifiedValue, i\n\n    let parsePrecision (s : string) i : int * int = \n        if s.[i] = '.' then\n            if s.[i + 1] = '*' then StarValue, i + 2\n            elif isDigit (s.[i + 1]) then intFromString s (i + 1)\n            else failwith \"invalid precision value\"\n        else NotSpecifiedValue, i\n    \n    let parseTypeChar (s : string) i : char * int = \n        s.[i], (i + 1)\n\n    type Part =\n        | StringPart of string\n        | FormatPart of FormatSpecifier\n\n    /// modified version of FSharp.Core findNextFormatSpecifier, parses whole format string\n    let parseAll (s : string) = \n        let parts = ResizeArray() \n        let rec go i (buf : System.Text.StringBuilder) =\n            if i >= s.Length then \n                if buf.Length > 0 then parts.Add (StringPart (string buf))\n            else\n                let c = s.[i]\n                if c = '%' then\n                    if i + 1 < s.Length then\n                        let f, i1 = parseFlags s (i + 1)\n                        let w, i2 = parseWidth s i1\n                        let p, i3 = parsePrecision s i2\n                        let typeChar, i4 = parseTypeChar s i3\n                        // shortcut for the simpliest case\n                        // if typeChar is not % or it has star as width\\precision - resort to long path\n                        if typeChar = '%' && not (w = StarValue || p = StarValue) then \n                            buf.Append('%') |> ignore\n                            go i4 buf\n                        else \n                            if buf.Length > 0 then parts.Add (StringPart (string buf))\n                            parts.Add (\n                                FormatPart {\n                                    TypeChar  = typeChar\n                                    Precision = p\n                                    Width     = w\n                                    Flags     = f\n                                }\n                            )\n                            go i4 (buf.Clear())\n                    else\n                        failwith \"Missing format specifier\"\n                else \n                    buf.Append(c) |> ignore\n                    go (i + 1) buf\n        go 0 (System.Text.StringBuilder())\n        parts.ToArray()\n\nlet flags =\n    System.Reflection.BindingFlags.Public\n    ||| System.Reflection.BindingFlags.NonPublic\n\nlet stringModule = \n    TypeDefinition {\n        FullName = \"Microsoft.FSharp.Core.StringModule\"\n        Assembly = \"FSharp.Core\"\n    }\nlet stringProxy (comp: M.ICompilation) f args =\n    let m = comp.GetClassInfo(stringModule).Value.Methods.Keys |> Seq.find (fun m -> m.Value.MethodName = f)\n    Call(None, NonGeneric stringModule, NonGeneric m, args)\n\nlet cCall e f args = Application (ItemGet(e, !~ (Literal.String f), Pure), args, Pure, None)\nlet cCallG a args = Application (Global a, args, Pure, None)\n\n//type FST = Reflection.FSharpType\n\nlet (^+) (a: Expression) (b: Expression) =\n    match a, b with\n    | I.Value (String av), I.Value (String bv) -> Value (AST.String (av + bv))\n    | I.Value av, I.Value bv -> Value (AST.String (av.Value.ToString() + bv.Value.ToString()))\n    | _ -> a ^+ b\n\nlet createPrinter (comp: M.ICompilation) (ts: Type list) fs =\n    let parts = FormatString.parseAll fs\n    let args = ts |> List.map (fun t -> Id.New(mut = false), Some t)\n        \n    let rArgs = ref args\n    let nextVar() =\n        match !rArgs with\n        | (a, t) :: r ->\n            rArgs := r\n            Var a, t\n        | _ -> failwithf \"wrong number of Printer type arguments found: %d\" (List.length ts)  \n        \n    let withPadding (f: FormatString.FormatSpecifier) t =\n        if f.IsWidthSpecified then\n            let width = if f.IsStarWidth then nextVar() |> fst else cInt f.Width\n            let s = t (nextVar())\n            if FormatString.isLeftJustify f.Flags then\n                stringProxy comp \"PadRight\" [s; width]\n            else\n                if FormatString.isPadWithZeros f.Flags then\n                    utils comp \"padNumLeft\" [s; width]\n                else\n                    stringProxy comp \"PadLeft\" [s; width]\n        else t (nextVar())\n        \n    let numberToString (f: FormatString.FormatSpecifier) t =\n        withPadding f (fun (n, _) ->\n            if FormatString.isPlusForPositives f.Flags then utils comp \"plusForPos\" [n; t n]\n            elif FormatString.isSpaceForPositives f.Flags then utils comp \"spaceForPos\" [n; t n]\n            else t n\n        )\n\n    let prettyPrint (t: Type) o = \n        let rec pp (t: Type) (o: Expression) = \n            match t with\n            | TupleType (ts, _) ->\n                seq {\n                    yield cString \"(\"\n                    for i = 0 to ts.Length - 1 do \n                        yield pp ts.[i] o.[cInt i] \n                        if i < ts.Length - 1 then yield cString \", \"\n                    yield cString \")\"\n                }\n                |> Seq.reduce (^+)\n            | ArrayType (a, r) ->\n                let x = Id.New(mut = false)\n                match r with \n                | 1 -> utils comp \"printArray\" [ Lambda([x], pp a (Var x)) ; o ]\n                | 2 -> utils comp \"printArray2D\" [ Lambda([x], pp a (Var x)) ; o ]\n                | _ -> utils comp \"prettyPrint\" [o]\n            | VoidType -> cString \"null\" \n            | FSharpFuncType _ -> cString \"<fun>\"\n            | ConcreteType ct ->\n                match comp.GetCustomTypeInfo ct.Entity with\n                | M.FSharpRecordInfo fields ->\n                    let td, m = \n                        let key = M.CompositeEntry [ M.StringEntry \"Printf\"; M.TypeEntry t ]\n                        match comp.GetMetadataEntries key with\n                        | M.CompositeEntry [ M.TypeDefinitionEntry gtd; M.MethodEntry gm ] :: _ ->\n                            gtd, gm\n                        | _ ->\n                            let gtd, gm, _ = comp.NewGenerated([ \"GeneratedPrintf\"; \"p\"])\n                            comp.AddMetadataEntry(key, M.CompositeEntry [ M.TypeDefinitionEntry gtd; M.MethodEntry gm ])\n                            let body = \n                                let x = Id.New(mut = false)\n                                Lambda([x], \n                                    seq {\n                                        yield cString \"{\"\n                                        let fields = Array.ofList fields\n                                        let gs = ct.Generics |> Array.ofList\n                                        for i = 0 to fields.Length - 1 do\n                                            let f = fields.[i]\n                                            let ftypRes = f.RecordFieldType.SubstituteGenerics gs\n                                            let item =\n                                                if f.Optional then\n                                                    JSRuntime.GetOptional (ItemGet(Var x, cString f.JSName, Pure))\n                                                else \n                                                    (Var x).[cString f.JSName]\n                                            yield cString (f.Name + \" = \") ^+ pp ftypRes item\n                                            if i < fields.Length - 1 then yield cString \"; \"\n                                        yield cString \"}\"\n                                    }\n                                    |> Seq.reduce (^+)\n                                ) \n                            comp.AddGeneratedCode(gm, body) |> ignore\n                            gtd, gm\n                    Call(None, NonGeneric td, NonGeneric m, [o])\n                | M.FSharpUnionInfo u ->\n                    if ct.Entity.Value.FullName = \"Microsoft.FSharp.Collections.FSharpList`1\" then\n                        let x = Id.New(mut = false)\n                        utils comp \"printList\" [ Lambda([x], pp ct.Generics.[0] (Var x)) ; o ]    \n                    else\n                        let td, m =\n                            let key = M.CompositeEntry [ M.StringEntry \"Printf\"; M.TypeEntry t ]\n                            match comp.GetMetadataEntries key with\n                            | M.CompositeEntry [ M.TypeDefinitionEntry gtd; M.MethodEntry gm ] :: _ ->\n                                gtd, gm\n                            | _ ->\n                                let gtd, gm, _ = comp.NewGenerated([ comp.AssemblyName.Replace(\".\",\"$\") + \"_GeneratedPrintf\"; \"p\" ])\n                                comp.AddMetadataEntry(key, M.CompositeEntry [ M.TypeDefinitionEntry gtd; M.MethodEntry gm ])\n                                let gs = ct.Generics |> Array.ofList\n                                let body =\n                                    let x = Id.New(mut = false)\n                                    Lambda([x],                                         \n                                        let caseInfo =\n                                            u.Cases |> Seq.mapi (fun tag c ->\n                                                match c.Kind with\n                                                | M.ConstantFSharpUnionCase cVal -> \n                                                    if cVal = Null then Choice3Of3 () \n                                                    else Choice1Of3 (cVal, cString c.Name)\n                                                | M.SingletonFSharpUnionCase ->\n                                                    Choice2Of3(tag, cString c.Name)    \n                                                | M.NormalFSharpUnionCase fs -> \n                                                    Choice2Of3(\n                                                        tag,\n                                                        match fs.Length with\n                                                        | 0 -> cString c.Name\n                                                        | 1 ->\n                                                            let ityRes = fs.[0].UnionFieldType.SubstituteGenerics gs \n                                                            cString (c.Name + \" \") ^+ pp ityRes (Var x).[cString \"$0\"]\n                                                        | _ -> \n                                                            seq {\n                                                                yield cString (c.Name + \" (\")\n                                                                for i = 0 to fs.Length - 1 do\n                                                                    let ityRes = fs.[i].UnionFieldType.SubstituteGenerics gs\n                                                                    yield pp ityRes (Var x).[cString (\"$\" + string i)]\n                                                                    if i < fs.Length - 1 then yield cString \", \"\n                                                                yield cString \")\"\n                                                            }\n                                                            |> Seq.reduce (^+)\n                                                    )\n                                            )\n                                        let withoutNullCheck =\n                                            caseInfo\n                                            |> Seq.fold (fun s cInfo ->\n                                                match s with\n                                                | None -> \n                                                    match cInfo with\n                                                    | Choice1Of3 (_, e) \n                                                    | Choice2Of3 (_, e) -> Some e\n                                                    | Choice3Of3 () -> None\n                                                | Some s -> \n                                                    match cInfo with\n                                                    | Choice1Of3 (cVal, e) -> Some <| Conditional (Var x ^== Value cVal, e, s)\n                                                    | Choice2Of3 (tag, e) -> Some <| Conditional ((Var x).[cString \"$\"] ^== cInt tag, e, s)\n                                                    | Choice3Of3 () -> Some s\n                                            ) None |> Option.get\n                                        if caseInfo |> Seq.exists (function Choice3Of3 () -> true | _ -> false) then\n                                            Conditional(Var x ^== Value Null, cString \"null\", withoutNullCheck)    \n                                        else withoutNullCheck    \n                                    )\n                                comp.AddGeneratedCode(gm, body) |> ignore\n                                gtd, gm\n                        Call(None, NonGeneric td, NonGeneric m, [o])\n                | _ ->\n                    utils comp \"prettyPrint\" [o]\n            | _ -> utils comp \"prettyPrint\" [o]\n        pp t o\n\n    let inner = \n        if Array.isEmpty parts then cString \"\" else\n        parts\n        |> Seq.map (function\n            | FormatString.StringPart s -> cString s\n            | FormatString.FormatPart f ->\n                match f.TypeChar with\n                | 'b'\n                | 'O' -> \n                    withPadding f (fun (o, _) -> cCallG [\"String\"] [o])\n                | 'A' -> \n                    withPadding f (function \n                        | o, Some t -> \n                            prettyPrint t o\n                        | o, _ -> utils comp \"prettyPrint\" [o]\n                    )\n                | 'c' -> \n                    withPadding f (fun (s, _) -> s)   \n                | 's' -> \n                    withPadding f (fun (s, _) -> utils comp \"toSafe\" [s])\n                | 'd' | 'i' ->\n                    numberToString f (fun n -> cCallG [\"String\"] [n])\n                | 'x' ->                                           \n                    numberToString f (fun n -> cCall n \"toString\" [cInt 16])\n                | 'X' ->                                           \n                    numberToString f (fun n -> cCall (cCall n \"toString\" [cInt 16]) \"toUpperCase\" [])\n                | 'o' ->                                           \n                    numberToString f (fun n -> cCall n \"toString\" [cInt 8])\n                | 'e' ->\n                    numberToString f (fun n -> cCall n \"toExponential\" []) \n                | 'E' ->\n                    numberToString f (fun n -> cCall (cCall n \"toExponential\" []) \"toUpperCase\" []) \n                | 'f' | 'F' | 'M' ->\n                    numberToString f (fun n ->\n                        let prec =\n                            if f.IsPrecisionSpecified then\n                                if f.IsStarPrecision then nextVar() |> fst else cInt f.Precision\n                            else cInt 6 // Default precision\n                        cCall n \"toFixed\" [prec]\n                    )\n                | c -> failwithf \"Failed to parse format string: '%%%c' is not supported.\" c\n        )\n        |> Seq.reduce (^+)\n    \n    let k = Id.New(mut = false) \n    Lambda([k],\n        args |> List.rev |> List.fold (fun c (a, _) -> Lambda([a], c)) (Var k).[[inner]]\n    )\n  \nlet objty, objArrTy =\n    let t = typeof<System.Object>\n    let arrt = typeof<System.Object []>\n    Reflection.ReadTypeDefinition t,\n    Reflection.ReadTypeDefinition arrt\n  \n[<Sealed>]\ntype PrintF() =\n    inherit Macro()\n    override this.TranslateCtor(c) =\n        let rec getFunctionArgs f =\n            match f with\n            | FSharpFuncType(a, r) -> \n                a :: getFunctionArgs r\n            | _ -> \n                []\n        match c.Arguments with\n        | [I.Value (Literal.String fs)] ->\n            let ts = c.DefiningType.Generics.Head |> getFunctionArgs |> List.map (fun t -> t.SubstituteGenericsToSame(NonGenericType objty))\n            createPrinter c.Compilation ts fs |> MacroOk\n        | _ -> MacroError \"printfMacro error\"\n\n[<JavaScript>]\ntype private EquatableEqualityComparer<'T when 'T :> System.IEquatable<'T>>() =\n    inherit System.Collections.Generic.EqualityComparer<'T>()\n    override this.Equals(x, y) = (x :> System.IEquatable<_>).Equals(y)\n    override this.GetHashCode(x) = (box x).GetHashCode()\n\n[<JavaScript>]\ntype private BaseEqualityComparer<'T>() =\n    inherit System.Collections.Generic.EqualityComparer<'T>()\n    override this.Equals(x, y) = obj.Equals(box x, box y)\n    override this.GetHashCode(x) = (box x).GetHashCode()\n\nlet rec isImplementing (comp: M.ICompilation) typ intf =\n    comp.GetClassInfo typ\n    |> Option.map (fun cls ->\n        cls.Implementations |> Seq.exists (fun (KeyValue ((i, _), _)) -> i = intf)\n        || cls.BaseClass |> Option.exists (fun b -> isImplementing comp b intf |> Option.exists id) \n    )\n\n[<Sealed>]\ntype EqualityComparer() =\n    inherit Macro()\n\n    static let ieqTy =\n        TypeDefinition {\n            Assembly = \"mscorlib\"\n            FullName = \"System.IEquatable`1\"\n        } \n\n    static member GetDefault(comp: M.ICompilation, t: Type) =\n        if t.IsParameter then MacroNeedsResolvedTypeArg t else\n        match t with\n        | ConcreteType ct ->\n            match isImplementing comp ct.Entity ieqTy with\n            | Some isEquatable ->\n                let td : TypeDefinitionInfo =\n                    { Assembly = \"WebSharper.Main\"\n                      FullName =\n                        if isEquatable then\n                            \"WebSharper.MacroModule+EquatableEqualityComparer`1\"\n                        else\n                            \"WebSharper.MacroModule+BaseEqualityComparer`1\" }\n                Ctor (\n                    { Entity = Hashed td; Generics = [t] },\n                    Constructor { CtorParameters = [] },\n                    []\n                ) |> MacroOk\n            | _ -> MacroError \"\"\n        | _ -> MacroError \"Type form not recognized\"\n\n    override this.TranslateCall(c) =\n        match c.Method.Entity.Value.MethodName with\n        | \"get_Default\" -> EqualityComparer.GetDefault(c.Compilation, c.DefiningType.Generics.[0])\n        | _ -> MacroError \"Not implemented\"\n\n[<JavaScript>]\ntype private ComparableComparer<'T when 'T :> System.IComparable<'T>>() =\n    inherit System.Collections.Generic.Comparer<'T>()\n    override this.Compare(x, y) = (x :> System.IComparable<'T>).CompareTo(y)\n\n[<JavaScript>]\ntype private BaseComparer<'T when 'T : comparison>() =\n    inherit System.Collections.Generic.Comparer<'T>()\n    override this.Compare(x, y) = compare x y\n\n[<Sealed>]\ntype Comparer() =\n    inherit Macro()\n\n    static let icmpTy =\n        TypeDefinition {\n            Assembly = \"mscorlib\"\n            FullName = \"System.IComparable`1\"\n        } \n\n    static member GetDefault(comp: M.ICompilation, t: Type) =\n        if t.IsParameter then MacroNeedsResolvedTypeArg t else\n        match t with\n        | ConcreteType ct ->\n            match isImplementing comp ct.Entity icmpTy with\n            | Some isEquatable ->\n                let td : TypeDefinitionInfo =\n                    { Assembly = \"WebSharper.Main\"\n                      FullName =\n                        if isEquatable then\n                            \"WebSharper.MacroModule+ComparableComparer`1\"\n                        else\n                            \"WebSharper.MacroModule+BaseComparer`1\" }\n                Ctor(\n                    {Entity = Hashed td; Generics = [t]},\n                    Hashed<ConstructorInfo> { CtorParameters = [] },\n                    [])\n                |> MacroOk\n            | _ -> MacroError \"\"\n        | _ -> MacroError \"Type form not recognized\"\n\n    override this.TranslateCall(c) =\n        match c.Method.Entity.Value.MethodName with\n        | \"get_Default\" -> Comparer.GetDefault(c.Compilation, c.DefiningType.Generics.[0])\n        | _ -> MacroError \"Not implemented\"\n\n/// Returns 0 for number types, undefined for others.\n/// TODO: this is wrong for non-number value types!\n/// TODO: also always returns undefined when called generically.\n[<Sealed>]\ntype DefaultOf() =\n    inherit Macro()\n\n    override __.TranslateCall(c) =\n        let t = c.Method.Generics.[0]\n        if t.IsParameter then MacroNeedsResolvedTypeArg t else\n        match t with\n        | ConcreteType td when\n            (td.Entity.Value.Assembly.StartsWith \"mscorlib\" &&\n                match td.Entity.Value.FullName with\n                | \"System.SByte\"\n                | \"System.Byte\"\n                | \"System.Int16\"\n                | \"System.UInt16\"\n                | \"System.Int32\"\n                | \"System.UInt32\"\n                | \"System.Int64\"\n                | \"System.UInt64\"\n                | \"System.Decimal\"\n                | \"System.Single\"\n                | \"System.Double\"\n                | \"System.DateTime\"\n                | \"System.TimeSpan\" -> true\n                | _ -> false)\n            -> MacroOk (Value (Int 0))\n        | ConcreteType td -> \n            match c.Compilation.GetCustomTypeInfo td.Entity with\n            | M.StructInfo ->\n                let cdef = Hashed { CtorParameters = [] }\n                MacroOk (Ctor(td, cdef, []))\n            | _ ->\n                MacroOk (Value (Null))\n        | _ ->\n            MacroOk (Value (Null))\n\n[<Sealed>]\ntype DefaultToUndefined() =\n    inherit Macro()\n\n    static let tr =\n        { new Transformer() with\n            override this.TransformCall(thisObj, typ, meth, args) =\n                if Option.isNone thisObj && IsDefaultValue typ.Entity meth.Entity && List.isEmpty args then\n                    Undefined\n                else\n                    base.TransformCall(thisObj, typ, meth, args)  \n        }.TransformExpression\n\n    override __.TranslateCall(c) =\n        MacroOk <| tr c.Arguments.[0]\n\n[<Sealed>]\ntype TypeTest() =\n    inherit Macro()\n\n    override __.TranslateCall(c) =\n        TypeCheck(c.Arguments.Head, c.Method.Generics.Head) |> MacroOk\n\n[<Sealed>]\ntype InlineJS() =\n    inherit Macro()\n\n    override __.TranslateCall(c) =\n        match c.Arguments.Head with\n        | I.Value (String inl) ->\n            let args =\n                match c.Arguments with\n                | [_] -> [] \n                | [_; I.NewArray args] -> args\n                | _ -> failwith \"InlineJS error: arguments cannot be passed as an array\"\n            c.Compilation.ParseJSInline(inl, args) |> MacroOk\n        | _ -> failwith \"InlineJS error: first argument must be a constant string\"\n\nlet stringTy, lengthMeth, padLeft, padRight =\n    let t = typeof<System.String>\n    Reflection.ReadTypeDefinition t,\n    Reflection.ReadMethod (t.GetMethod \"get_Length\"),\n    Reflection.ReadMethod (t.GetMethod(\"PadLeft\", [|typeof<int>|])),\n    Reflection.ReadMethod (t.GetMethod(\"PadRight\", [|typeof<int>|]))\n\n[<Sealed>]\ntype StringFormat() =\n    inherit Macro()\n\n    let regExp = Regex(\"(?:(.*?){(0|[1-9]\\d*)(?:,(-?[1-9]\\d*|0))?(?::(.*?))?})|(.+)$\", RegexOptions.Singleline)\n\n    let safeToString expr =\n        Conditional(\n            expr ^== (Value Literal.Null),\n            cString \"\",\n            cCallG [\"String\"] [expr]\n        )\n\n    override __.TranslateCall(c) =\n        match c.DefiningType.Entity.Value.FullName, c.Method.Entity.Value.MethodName with\n        | \"System.String\", \"Format\" ->\n            match c.Arguments with\n            | (I.Value (String format)) :: args when args.Length < 4 ->\n                let args =\n                    match c.Method.Entity.Value.Parameters with\n                    | [_; x] ->\n                        try \n                            if x.TypeDefinition = objty then\n                                NewArray [args.[0]]\n                            else\n                                args.[0]\n                        with _ ->\n                            // Array type has no typedef\n                            args.[0]\n                    | [_; x1; x2] -> NewArray [args.[0]; args.[1]]\n                    | [_; x1; x2; x3] -> NewArray [args.[0]; args.[1]; args.[2]]\n                    | _ -> failwith \"Wrong number of arguments for String.Format\"\n\n                let warning = ref None\n                let argsId = Id.New(mut = false)\n               \n                let parts =\n                    regExp.Matches(format)\n                    |> Seq.cast<Match>\n                    |> Array.ofSeq\n\n                let body =\n                    if Array.isEmpty parts then cString \"\" else\n                    parts\n                    |> Seq.map (fun m ->\n                        if m.Groups.[5].Value <> \"\" then\n                            Value (Literal.String m.Groups.[5].Value)\n                        else\n                            let prefix = m.Groups.[1].Value\n                            let prefix s = Value (Literal.String prefix) ^+ s\n                            let idx = int m.Groups.[2].Value\n\n                            let r =\n                                Application(Global [\"WebSharper\"; \"Arrays\"; \"get\"], [Var argsId; cInt idx], Pure, Some 2)\n                                |> safeToString\n\n                            let spec = m.Groups.[4].Value\n                            if spec <> \"\" then\n                                warning := Some (sprintf \"String format specifiers are not supported: %s\" spec)\n\n                            if m.Groups.[3].Value <> \"\" then\n                                let w1 = int m.Groups.[3].Value\n                                let w2 = abs w1\n\n                                let expr =\n                                    Conditional(\n                                        cInt w2 ^> Call (None, NonGeneric stringTy, NonGeneric lengthMeth, [r]),\n                                        (\n                                            if w1 > 0 then\n                                                Call (None, NonGeneric stringTy, NonGeneric padLeft, [r; cInt w2])\n                                            else\n                                                Call (None, NonGeneric stringTy, NonGeneric padRight, [r; cInt w2])\n                                        ),\n                                        r\n                                    )\n                                prefix expr\n                            else prefix r\n                    )\n                    |> Seq.reduce (^+)\n\n                let result = Let(argsId, args, body)\n\n                let warningRes = !warning |> Option.map (fun w -> MacroWarning(w, MacroOk result))\n\n                defaultArg warningRes (MacroOk result)\n            \n            | _ -> MacroFallback\n        | _ -> MacroError \"proxy is for System.String.Format\"", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n/// Defines operators and functions that are automatically available whenever\n/// `WebSharper` is open.\n[<AutoOpen>]\nmodule WebSharper.JavaScript.Pervasives\n\nopen WebSharper\nmodule M = WebSharper.Macro\n\n/// Casts an object to the desired type.\n[<Inline \"$x\">]\nlet As<'T> (x: obj) = X<'T>\n\n[<Inline \"$x * $y\">]\nlet ( *. ) x y = X<obj>\n\n[<Inline \"$x / $y\">]\nlet ( /. ) x y = X<obj>\n\n[<Inline \"$x % $y\">]\nlet ( %. ) x y = X<obj>\n\n[<Inline \"$x + $y\">]\nlet ( +. ) x y = X<obj>\n\n[<Inline \"$x - $y\">]\nlet ( -. ) x y = X<obj>\n\n[<Inline \"$x << $y\">]\nlet ( <<. ) x y = X<obj>\n\n[<Inline \"$x >> $y\">]\nlet ( >>. ) x y = X<obj>\n\n[<Inline \"$x >>> $y\">]\nlet ( >>>. ) x y = X<obj>\n\n[<Inline \"$x < $y\">]\nlet ( <. ) x y = X<bool>\n\n[<Inline \"$x > $y\">]\nlet ( >. ) x y = X<bool>\n\n[<Inline \"$x >= $y\">]\nlet ( >=. ) x y = X<bool>\n\n[<Inline \"$x <= $y\">]\nlet ( <=. ) x y = X<bool>\n\n[<Inline \"$x == $y\">]\nlet ( ==. ) x y = X<bool>\n\n[<Inline \"$x === $y\">]\nlet ( ===. ) x y = X<bool>\n\n[<Inline \"$x != $y\">]\nlet ( !=. ) x y = X<bool>\n\n[<Inline \"$x !== $y\">]\nlet ( !==. ) x y = X<bool>\n\n[<Inline \"$x | $y\">]\nlet ( |. ) x y = X<obj>\n\n[<Inline \"$x & $y\">]\nlet ( &. ) x y = X<obj>\n\n[<Inline \"$x ^ $y\">]\nlet ( ^. ) x y = X<obj>\n\n[<Inline \"$obj[$field]\">]\nlet ( ? ) (obj: obj) (field: string) = X<'T>\n\n[<Inline \"void ($obj[$key] = $value)\">]\nlet ( ?<- ) (obj: obj) (key: string) (value: obj) = X<unit>\n\n[<Inline \"[$x,$y]\">]\nlet ( => ) (x: string) (y: obj) = (x, y)\n\ntype JS =\n    /// Parses and inlines JavaScript code\n    [<Macro(typeof<M.InlineJS>)>]\n    static member Inline<'T> (inlineString: string, [<System.ParamArray>] args: obj[]) = X<'T>\n\n[<JavaScript>]\nlet private NewFromSeq<'T> (fields: seq<string * obj>) : 'T =\n    let r = JS.Inline \"{}\"\n    for (k, v) in fields do\n        (?<-) r k v\n    As r\n\n/// Constructs a new object as if an object literal was used.\n[<Macro(typeof<M.New>); Inline>]\nlet New<'T> (fields: seq<string * obj>) = NewFromSeq<'T> fields\n\n/// Constructs an proxy to a remote object instance.\n[<Constant null>]\nlet Remote<'T> = X<'T>\n\n/// Gets JavaScript properties in sequence dynamically from an object.\n[<JavaScript; Macro(typeof<M.GetJS>)>]\nlet GetJS<'T> (x: obj) (items: seq<string>) =\n    let mutable x = x\n    for i in items do\n        x <- x?(i)\n    As<'T> x    \n\n/// Erases generic parameters inside this expression during WebSharper translation.\n/// You can get use this to translate `defaultof` inside a generic function.\n[<Macro(typeof<M.DefaultToUndefined>)>]\nlet DefaultToUndefined<'T> (x: 'T) = x\n\nmodule Optional =\n    /// Converts an F# option value to a JavaScript erased option\n    [<Inline>]\n    let ofOption x =\n        match x with\n        | None -> Undefined\n        | Some v -> Defined v\n\n    /// Converts a JavaScript erased option to an F# option value\n    [<Inline>]\n    let toOption x =\n        match x with\n        | Undefined -> None\n        | Defined v -> Some v\n\nmodule Union =\n// {{ generated by genInterop.fsx, do not modify\n    /// Converts an F# Choice value to a JavaScript erased union\n    [<Inline \"$x.$1\">]\n    let ofChoice2 (x: Choice<'T1, 'T2>) = X<Union<'T1, 'T2>>\n    /// Converts a JavaScript erased union to an F# Choice value\n    [<Inline>]\n    let toChoice2 x =\n        match x with\n        | Union1Of2 v -> Choice1Of2 v\n        | Union2Of2 v -> Choice2Of2 v\n    /// Converts an F# Choice value to a JavaScript erased union\n    [<Inline \"$x.$1\">]\n    let ofChoice3 (x: Choice<'T1, 'T2, 'T3>) = X<Union<'T1, 'T2, 'T3>>\n    /// Converts a JavaScript erased union to an F# Choice value\n    [<Inline>]\n    let toChoice3 x =\n        match x with\n        | Union1Of3 v -> Choice1Of3 v\n        | Union2Of3 v -> Choice2Of3 v\n        | Union3Of3 v -> Choice3Of3 v\n    /// Converts an F# Choice value to a JavaScript erased union\n    [<Inline \"$x.$1\">]\n    let ofChoice4 (x: Choice<'T1, 'T2, 'T3, 'T4>) = X<Union<'T1, 'T2, 'T3, 'T4>>\n    /// Converts a JavaScript erased union to an F# Choice value\n    [<Inline>]\n    let toChoice4 x =\n        match x with\n        | Union1Of4 v -> Choice1Of4 v\n        | Union2Of4 v -> Choice2Of4 v\n        | Union3Of4 v -> Choice3Of4 v\n        | Union4Of4 v -> Choice4Of4 v\n    /// Converts an F# Choice value to a JavaScript erased union\n    [<Inline \"$x.$1\">]\n    let ofChoice5 (x: Choice<'T1, 'T2, 'T3, 'T4, 'T5>) = X<Union<'T1, 'T2, 'T3, 'T4, 'T5>>\n    /// Converts a JavaScript erased union to an F# Choice value\n    [<Inline>]\n    let toChoice5 x =\n        match x with\n        | Union1Of5 v -> Choice1Of5 v\n        | Union2Of5 v -> Choice2Of5 v\n        | Union3Of5 v -> Choice3Of5 v\n        | Union4Of5 v -> Choice4Of5 v\n        | Union5Of5 v -> Choice5Of5 v\n    /// Converts an F# Choice value to a JavaScript erased union\n    [<Inline \"$x.$1\">]\n    let ofChoice6 (x: Choice<'T1, 'T2, 'T3, 'T4, 'T5, 'T6>) = X<Union<'T1, 'T2, 'T3, 'T4, 'T5, 'T6>>\n    /// Converts a JavaScript erased union to an F# Choice value\n    [<Inline>]\n    let toChoice6 x =\n        match x with\n        | Union1Of6 v -> Choice1Of6 v\n        | Union2Of6 v -> Choice2Of6 v\n        | Union3Of6 v -> Choice3Of6 v\n        | Union4Of6 v -> Choice4Of6 v\n        | Union5Of6 v -> Choice5Of6 v\n        | Union6Of6 v -> Choice6Of6 v\n    /// Converts an F# Choice value to a JavaScript erased union\n    [<Inline \"$x.$1\">]\n    let ofChoice7 (x: Choice<'T1, 'T2, 'T3, 'T4, 'T5, 'T6, 'T7>) = X<Union<'T1, 'T2, 'T3, 'T4, 'T5, 'T6, 'T7>>\n    /// Converts a JavaScript erased union to an F# Choice value\n    [<Inline>]\n    let toChoice7 x =\n        match x with\n        | Union1Of7 v -> Choice1Of7 v\n        | Union2Of7 v -> Choice2Of7 v\n        | Union3Of7 v -> Choice3Of7 v\n        | Union4Of7 v -> Choice4Of7 v\n        | Union5Of7 v -> Choice5Of7 v\n        | Union6Of7 v -> Choice6Of7 v\n        | Union7Of7 v -> Choice7Of7 v\n// }}\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nmodule WebSharper.Json\n\nopen WebSharper.JavaScript\nmodule Js = WebSharper.Core.Json\nmodule Re = WebSharper.Core.Resources\n\ntype Resource() =\n    interface Re.IResource with\n        member this.Render ctx =\n            let name = if ctx.DebuggingEnabled then \"Json.js\" else \"Json.min.js\"\n            let ren = Re.Rendering.GetWebResourceRendering(ctx, typeof<Resource>, name)\n            fun html ->\n                let html = html Re.Scripts\n                html.WriteLine \"<!--[if lte IE 7.0]>\"\n                ren.Emit(html, Re.Js)\n                html.WriteLine \"<![endif]-->\"\n\n[<Inline \"$obj[$field]\">]\nlet ( ? ) (obj: obj) (field: string) = X<'T>\n\n[<Inline \"void ($obj[$key] = $value)\">]\nlet ( ?<- ) (obj: obj) (key: string) (value: obj) = X<unit>\n\n[<Inline \"$x\">]\nlet As<'T> (x: obj) = X<'T>\n\n[<Inline \"JSON.parse($json)\">]\n[<Require(typeof<Resource>)>]\nlet Parse (json: string) = X<obj>\n\n[<Inline \"JSON.stringify($obj)\">]\n[<Require(typeof<Resource>)>]\nlet Stringify (obj: obj) = X<string>\n\n/// Lookups an object by its FQN.\n[<JavaScript>]\nlet lookup<'T> (x: string []) : obj =\n    let k = x.Length\n    let mutable r = JS.Global\n    let mutable i = 0\n    while i < k do\n        let n  = x.[i]\n        let rn = (?) r n\n        if JS.TypeOf rn <> JS.Undefined then\n            r <- rn\n            i <- i + 1\n        else\n            failwith (\"Invalid server reply. Failed to find type: \" + n)\n    r\n\n/// Does a shallow generic mapping over an object.\n[<JavaScript>]\nlet shallowMap (f: obj -> obj) (x: obj) : obj =\n    if x :? System.Array then\n        As (Array.map f (As x))\n    else\n        match JS.TypeOf x with\n        | JS.Object ->\n            let r = New []\n            JS.ForEach x (fun y -> (?<-) r y (f ((?) x y)); false)\n            r\n        | _ ->\n            x\n\n[<JavaScript>]\n[<Require(typeof<Resource>)>]\nlet Activate<'T> (json: obj) : 'T =\n    let types = As<obj[]> ((?) json \"$TYPES\")\n    for i = 0 to types.Length - 1 do\n        types.[i] <- lookup (As types.[i])\n    let rec decode (x: obj) : obj =\n        if x = null then x else\n            match JS.TypeOf x with\n            | JS.Object ->\n                if x :? System.Array then\n                    shallowMap decode x\n                else\n                    let o  = shallowMap decode ((?) x \"$V\")\n                    let ti = (?) x \"$T\"\n                    if JS.TypeOf ti = JS.Kind.Undefined then o else\n                        let t = types.[ti]\n                        if t ===. JS.Global?WebSharper?List?T then\n                            box (List.ofArray (As<obj[]> o))\n                        else\n                            let r = JS.New types.[ti]\n                            JS.ForEach o (fun k -> (?<-) r k ((?) o k); false)\n                            r\n            | _ ->\n                x\n    As (decode ((?) json \"$DATA\"))\n\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nmodule WebSharper.Remoting\n\nopen WebSharper.JavaScript\n\nmodule R = WebSharper.Core.Remoting\n\n[<JavaScript>]\nlet mutable EndPoint = \"?\"\n\n[<JavaScript>]\nlet UseHttps() =\n    try\n        if not (JS.Window.Location.Href.StartsWith \"https://\") then\n            EndPoint <- JS.Window.Location.Href.Replace(\"http://\", \"https://\")\n            true\n        else false\n    with _ ->\n        // This function is intended to be callable from the top-level in a module,\n        // which means that it will be (unnecessarily) called on the server too\n        // and throw NotImplementedException. Just silence it.\n        false\n\ntype Data = string\ntype Headers = obj\ntype Url = string\n\n[<JavaScript>]\ntype IAjaxProvider =\n    [<Name \"Async\">]\n    abstract member Async : Url -> Headers -> Data -> (Data -> unit) -> (exn -> unit) -> unit\n\n    [<Name \"Sync\">]\n    abstract member Sync : Url -> Headers -> Data -> Data\n\n[<Direct @\"\n    var xhr = new XMLHttpRequest();\n    var csrf = document.cookie.replace(new RegExp('(?:(?:^|.*;)\\\\s*csrftoken\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$'), '$1');\n    xhr.open('POST', $url, $async);\n    if ($async == true) {\n        xhr.withCredentials = true;\n    }\n    for (var h in $headers) {\n        xhr.setRequestHeader(h, $headers[h]);\n    }\n    if (csrf) {\n        xhr.setRequestHeader('x-csrftoken', csrf);\n    }\n    function k() {\n        if (xhr.status == 200) {\n            $ok(xhr.responseText)\n        } else if ($csrf && xhr.status == 403 && xhr.responseText == 'CSRF') {\n            $csrf();\n        } else {\n            var msg = 'Response status is not 200: ';\n            $err(new Error(msg + xhr.status));\n        }\n    }\n    if ('onload' in xhr) {\n        xhr.onload = xhr.onerror = xhr.onabort = k;\n    } else {\n        xhr.onreadystatechange = function () {\n            if (xhr.readyState == 4) {\n                k();\n            }\n        };\n    }\n    xhr.send($data);\n\">]\nlet private ajax (async: bool) (url: Url) (headers: Headers) (data: Data)\n    (ok: Data -> unit) (err: exn -> unit) (csrf: unit -> unit) = ()\n\ntype XhrProvider [<JavaScript>] () =\n    interface IAjaxProvider with\n\n        [<JavaScript>]\n        member this.Async url headers data ok err =\n            ajax true url headers data ok err\n                (fun () -> ajax true url headers data ok err JS.Undefined)\n\n        [<JavaScript>]\n        member this.Sync url headers data =\n            let res = ref Unchecked.defaultof<_>\n            ajax false url headers data\n                (fun x -> res := x)\n                (fun e -> raise e)\n                (fun () ->\n                    ajax false url headers data\n                        (fun x -> res := x)\n                        (fun e -> raise e)\n                        JS.Undefined)\n            !res\n\n[<JavaScript>]\nlet mutable AjaxProvider = XhrProvider() :> IAjaxProvider\n\n[<JavaScript>]\nlet private makeHeaders (m: string) =\n    New [\n        \"content-type\" => \"application/json\"   \n        \"x-websharper-rpc\" => m\n    ]\n\n[<JavaScript>]\nlet private makePayload (data: obj []) =\n    Json.Stringify data\n\n[<JavaScript>]\ntype IRemotingProvider =\n    [<Name \"Sync\">]\n    abstract member Sync : string -> obj[] -> obj\n    [<Name \"Async\">]\n    abstract member Async : string -> obj[] -> Async<obj>\n    [<Name \"Task\">]\n    abstract member Task : string -> obj[] -> System.Threading.Tasks.Task<obj>\n    [<Name \"Send\">]\n    abstract member Send : string -> obj[] -> unit\n\n[<JavaScript>]\n[<Name \"WebSharper.Remoting.AjaxRemotingProvider\">]\ntype AjaxRemotingProvider() =\n    abstract EndPoint : string\n    override this.EndPoint = EndPoint\n\n    abstract AsyncBase : string * obj[] -> Async<obj> \n    override this.AsyncBase(m, data) = \n        async {\n            let headers = makeHeaders m\n            let payload = makePayload data\n            let! token = Async.CancellationToken\n            return! Async.FromContinuations (fun (ok, err, cc) ->\n                let waiting = ref true\n                let reg =\n                    token.Register(fun () ->\n                        if !waiting then\n                            waiting := false\n                            cc (new System.OperationCanceledException(token))\n                    )\n                let ok (x: Data) = \n                    if !waiting then\n                        waiting := false\n                        (reg :> System.IDisposable).Dispose()\n                        ok (Json.Activate (Json.Parse x))\n                let err (e: exn) =\n                    if !waiting then\n                        waiting := false\n                        (reg :> System.IDisposable).Dispose()\n                        err e\n                AjaxProvider.Async this.EndPoint headers payload ok err)\n        }\n\n    interface IRemotingProvider with\n        member this.Sync m data : obj =\n            let data = AjaxProvider.Sync this.EndPoint (makeHeaders m) (makePayload data)\n            Json.Activate (Json.Parse data)\n\n        member this.Async m data : Async<obj> =\n            this.AsyncBase(m, data)\n\n        member this.Task m data : System.Threading.Tasks.Task<obj> =\n            this.AsyncBase(m, data) |> Async.StartAsTask   \n\n        member this.Send m data =\n            Async.Start (Async.Ignore (this.AsyncBase(m, data)))\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen WebSharper\nopen WebSharper.JavaScript\nopen WebSharper.JQuery\nmodule M = WebSharper.Core.Metadata\nmodule J = WebSharper.Core.Json\n\n/// An interface that has to be implemented by controls\n/// that depend on resources.\ntype IRequiresResources =\n    abstract member Requires : seq<M.Node>\n    abstract member Encode : M.Info * J.Provider -> list<string * J.Encoded>\n\n/// HTML content that can be used as the Body of a web Control.\n/// Can be zero, one or many DOM nodes.\ntype IControlBody =\n    /// Replace the given node with the HTML content.\n    /// The node is guaranteed to be present in the DOM.\n    /// Called exactly once on startup on an IControl's Body.\n    [<JavaScript; Name \"ReplaceInDom\">]\n    abstract ReplaceInDom : Dom.Node -> unit\n\n/// An interface that has to be implemented by controls that\n/// are subject to activation, ie. server-side controls that\n/// contain client-side elements.\ntype IControl =\n    inherit IRequiresResources\n    [<JavaScript; Name \"Body\">]\n    abstract member Body : IControlBody\n    abstract member Id : string\n\n[<AutoOpen>]\nmodule HtmlContentExtensions =\n\n    [<JavaScript>]\n    type private SingleNode(node: Dom.Node) =\n        interface IControlBody with\n            member this.ReplaceInDom(old) =\n                node.ParentNode.ReplaceChild(node, old) |> ignore\n\n    [<JavaScript>]\n    type IControlBody with\n        /// Create HTML content comprised of a single DOM node.\n        static member SingleNode (node: Dom.Node) =\n            new SingleNode(node) :> IControlBody\n\nmodule Activator =\n\n    /// The identifier of the meta tag holding the controls.\n    [<Literal>]\n    let META_ID = \"websharper-data\"\n\n    [<Direct \"typeof document !== 'undefined'\">]\n    let private hasDocument () = false\n\n    [<JavaScript>]\n    let private Activate() =\n        if hasDocument () then\n            let meta = JS.Document.GetElementById(META_ID)\n            if (As meta) then\n                JQuery.Of(JS.Document).Ready(fun () ->\n                    let text = meta.GetAttribute(\"content\")\n                    let obj = Json.Activate (Json.Parse text)\n                    JS.GetFields obj\n                    |> Array.iter (fun (k, v) ->\n                        let p = (As<IControl> v).Body\n                        let old = JS.Document.GetElementById k\n                        p.ReplaceInDom old)\n                ).Ignore\n\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n/// Defines macros used by proxy definitions.\nmodule private WebSharper.Utils\n\nopen WebSharper.JavaScript\n\n[<JavaScript>]\nlet toSafe (s: string) =\n    if s ==. null then \"\" else s  \n\n[<JavaScript>]\nlet plusForPos (n: obj, s) =\n    if 0 <=. n then \"+\" + s else s     \n\n[<JavaScript>]\nlet spaceForPos (n: obj, s) =\n    if 0 <=. n then \" \" + s else s      \n\n[<Inline \"$s.substr(1)\">]\nlet skip1 (s: string) = X<string>\n\n[<JavaScript>]\nlet padNumLeft (s: string, l) =\n    let f = (As<string[]> s).[0]\n    if f = \" \" || f = \"+\" || f = \"-\" then\n        f + (skip1 s).PadLeft(l - 1, '0')\n    else s.PadLeft(l, '0')\n\n[<JavaScript>]\nlet printList (p: obj -> string, o: obj list) =\n    \"[\" + (o |> Seq.map p |> String.concat \"; \") + \"]\" \n\n[<JavaScript>]\nlet printArray (p: obj -> string, o: obj[]) =\n    if o ===. null then \"null\" else\n    \"[|\" + (o |> Array.map p |> String.concat \"; \") + \"|]\" \n\n[<JavaScript>]\nlet printArray2D (p: obj -> string, o: obj[,]) =\n    if o ===. null then \"null\" else\n     \"[[\" + (\n        seq {\n            let l2 = Array2D.length2 o\n            for i in 0 .. Array2D.length1 o - 1 ->\n                seq { for j in 0 .. l2 - 1 -> p o.[i, j] } \n                |> String.concat \"; \"\n        }\n        |> String.concat \"][\"\n     ) + \"]]\" \n\n[<JavaScript>]\nlet rec prettyPrint (o: obj) =\n    let printObject (o: obj) =\n        let s = string o\n        if s = \"[object Object]\" then\n            \"{\" + (JS.GetFields o |> Array.map (fun (k, v) -> k + \" = \" + prettyPrint v) |> String.concat \"; \") + \"}\"\n        else s\n    if o ===. null then \"null\" else\n    let t = JS.TypeOf o\n    if t  ==. JS.String then\n        \"\\\"\" + As o + \"\\\"\"\n    elif t  ==. JS.Object then\n        if o :? System.Array then\n            \"[|\" + (As o |> Array.map prettyPrint |> String.concat \"; \") + \"|]\"\n        else printObject o\n    else string o\n\n[<JavaScript>]\n[<Name \"WebSharper.Operators.charRange\">]\nlet charRange (min: char) (max: char) : seq<char> =\n    let minv = int min\n    let count = 1 + int max - minv\n    if count <= 0 then Seq.empty\n    else Seq.init count (fun x -> char (x + minv))\n\n[<JavaScript>]\n[<Name \"WebSharper.Nullable.op\">]\nlet nullableOp (a: obj) (b: obj) f = if a ==. null || b ==. null then null else f a b\n\n[<JavaScript>]\n[<Name \"WebSharper.Nullable.opL\">]\nlet nullableOpL (a: obj) (b: obj) f = if a ==. null then null else f a b\n\n[<JavaScript>]\n[<Name \"WebSharper.Nullable.opR\">]\nlet nullableOpR (a: obj) (b: obj) f = if b ==. null then null else f a b\n\n[<JavaScript>]\n[<Name \"WebSharper.Nullable.cmp\">]\nlet nullableCmp (a: obj) (b: obj) f = if a ==. null || b ==. null then false else f a b\n\n[<JavaScript>]\n[<Name \"WebSharper.Nullable.cmpE\">]\nlet nullableCmpE (a: obj) (b: obj) f =\n    if a ==. null then\n        b ==. null\n    elif b ==. null then \n        false \n    else f a b\n\n[<JavaScript>]\n[<Name \"WebSharper.Nullable.cmpL\">]\nlet nullableCmpL (a: obj) (b: obj) f = if a ==. null then false else f a b\n\n[<JavaScript>]\n[<Name \"WebSharper.Nullable.cmpR\">]\nlet nullableCmpR (a: obj) (b: obj) f = if b ==. null then false else f a b\n\n[<JavaScript>]\n[<Name \"WebSharper.Nullable.conv\">]\nlet nullableConv (a: obj) f = if a ==. null then null else f a", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n/// Implements concurrency primitives.\nmodule internal WebSharper.Concurrency\n\nopen WebSharper\nopen WebSharper.JavaScript\n\ntype private OCE = System.OperationCanceledException\n\n[<JavaScript; Prototype false>]\ntype Result<'T> =\n    | Ok of 'T\n    | No of exn\n    | Cc of OCE\n  \n[<JavaScript; Prototype false>]\ntype CT =\n    { \n        [<Name \"c\">] mutable IsCancellationRequested : bool \n        [<Name \"r\">] Registrations : (unit -> unit)[]\n    }\n\n[<Inline \"$arr.push($item)\">]\nlet private push arr item = X<int>\n\n[<JavaScript>]\nlet internal noneCT =           \n    { \n        IsCancellationRequested = false\n        Registrations = [||]\n    }\n\n[<JavaScript>]\nlet internal Register (ct: CT) (callback: unit -> unit) =\n    if ct ===. noneCT then\n        { new System.IDisposable with\n            member this.Dispose() = ()\n        }\n    else\n        let i = push ct.Registrations callback - 1\n        { new System.IDisposable with\n            member this.Dispose() = ct.Registrations.[i] <- ignore\n        }\n\n[<JavaScript; Prototype false>]\ntype AsyncBody<'T> =\n    {\n        k  : Result<'T> -> unit\n        ct : CT\n    }\n\ntype Concurrent<'T>     = AsyncBody<'T> -> unit\nand private C<'T>       = Concurrent<'T>\n\ntype private Queue<'T>  = System.Collections.Generic.Queue<'T>\ntype Milliseconds       = int\n\ntype private Scheduler [<JavaScript>]() =\n    let mutable idle    = true\n    let robin           = Queue<unit->unit>()\n\n    [<JavaScript>]\n    let rec tick () =\n        let t = System.DateTime.Now\n        let mutable loop = true\n        while loop do\n            match robin.Count with\n            | 0 ->\n                idle <- true\n                loop <- false\n            | _ ->\n                robin.Dequeue()()\n                if System.DateTime.Now - t > System.TimeSpan.FromMilliseconds 40. then\n                    JS.SetTimeout tick 0 |> ignore\n                    loop <- false\n\n    [<JavaScript>]\n    member this.Fork(action: unit -> unit) =\n        robin.Enqueue action\n        if idle then\n            idle <- false\n            JS.SetTimeout tick 0 |> ignore\n\n[<JavaScript>]\nlet private scheduler = Scheduler()\n\n[<JavaScript>]\nlet internal defCTS = ref(new System.Threading.CancellationTokenSource())\n\n[<Inline>]\nlet fork action = scheduler.Fork action\n\n[<JavaScript>]\nlet private cancel c = c.k (Cc (new OCE(As<System.Threading.CancellationToken> c.ct)))\n\n[<JavaScript>]\nlet private checkCancel r =\n    ()\n    fun c -> if c.ct.IsCancellationRequested then cancel c else r c\n\n[<JavaScript; Pure>]\nlet Return (x: 'T) : C<'T> =\n    ()\n    fun c -> c.k (Ok x)\n\n[<JavaScript; Pure>]\nlet Zero =\n    Return ()\n\n[<JavaScript; Pure>]\nlet Bind (r: C<'T>, f: 'T -> C<'R>) =\n    checkCancel <| fun c ->\n        r { \n            k = function \n                | Ok x -> fork (fun () -> try f x c with e -> c.k (No e))\n                | res  -> fork (fun () -> c.k (As res)) // error or cancellation\n            ct = c.ct\n        }\n\n[<JavaScript; Pure>]\nlet Combine (a: C<unit>, b: C<'T>) : C<'T> = \n    Bind (a, fun _ -> b)\n\n[<Inline>]\nlet Ignore (r: C<'T>): C<unit> = As<C<unit>> r\n\n[<JavaScript; Pure>]\nlet Delay (mk: unit -> C<'T>) : C<'T> =\n    ()\n    fun c ->\n        try mk () c with e -> c.k (No e)\n\n[<JavaScript; Pure>]\nlet TryFinally (run: C<'T>, f: unit -> unit) : C<'T> =\n    ()\n    fun c ->\n        run {\n            k = fun r -> \n                try f ()\n                    c.k r \n                with e -> c.k (No e)\n            ct = c.ct\n        }\n\n[<JavaScript; Pure>]\nlet TryWith (r: C<'T>, f: exn -> C<'T>) : C<'T> =\n    ()\n    fun c ->\n        r {\n            k = function\n                | Ok x -> c.k (Ok x)\n                | No e as res -> try f e c with e -> c.k (As res)\n                | res -> c.k (As res)\n            ct = c.ct\n        }\n\n[<JavaScript; Pure>]\nlet Catch (r : C<'T>) : C<Choice<'T, exn>> =\n    ()\n    fun c ->\n        try r {\n                k = function \n                    | Ok x -> c.k (Ok (Choice1Of2 x))\n                    | No e -> c.k (Ok (Choice2Of2 e))\n                    | res  -> c.k (As res)\n                ct = c.ct\n            }\n        with e -> c.k (Ok (Choice2Of2 e))\n\n[<JavaScript; Pure>]\nlet GetCT : C<CT> =\n    ()\n    fun c -> c.k (Ok c.ct)\n\n[<JavaScript; Pure>]\nlet FromContinuations (subscribe: ('T -> unit) * (exn -> unit) * (OCE -> unit) -> unit) : C<'T> =\n    ()\n    fun c ->\n        let continued = ref false\n        let once cont : unit =\n            if !continued then failwith \"A continuation provided by Async.FromContinuations was invoked multiple times\" else\n            continued := true\n            fork cont   \n        subscribe (\n            fun a -> once (fun () -> c.k (Ok a))\n        ,   fun e -> once (fun () -> c.k (No e))\n        ,   fun e -> once (fun () -> c.k (Cc e))\n        )\n\n[<JavaScript>]\nlet StartWithContinuations (c: C<'T>, s: 'T -> unit, f: exn -> unit, cc: OCE -> unit, ctOpt) =\n    let ct = defaultArg ctOpt (As !defCTS)\n    if not ct.IsCancellationRequested then\n        c {\n            k = function\n                | Ok x -> s x\n                | No e -> f e\n                | Cc e -> cc e\n            ct = ct\n        }\n\n[<JavaScript>]\nlet UncaughtAsyncError (e: exn) =\n    Console.Log (\"WebSharper: Uncaught asynchronous exception\", e)\n\n[<JavaScript>]\nlet Start (c: C<unit>, ctOpt) =\n    let ct = defaultArg ctOpt (As !defCTS)\n    fork (fun () -> \n        if not ct.IsCancellationRequested then\n            c {\n                k = function\n                    | No e -> UncaughtAsyncError e\n                    | _ -> ()\n                ct = ct\n            }\n    )\n\n[<JavaScript>]\nlet StartImmediate (c: C<unit>, ctOpt) =\n    let ct = defaultArg ctOpt (As !defCTS)\n    if not ct.IsCancellationRequested then\n        c {\n            k = function\n                | No e -> UncaughtAsyncError e\n                | _ -> ()\n            ct = ct\n        }\n\n#nowarn \"40\"\n\n[<JavaScript; Pure>]\nlet AwaitEvent (e: IEvent<'T>, ca: option<unit -> unit>) : C<'T> =\n    ()\n    fun c ->\n        let mutable sub = JS.Undefined<System.IDisposable>\n        let mutable creg = JS.Undefined<System.IDisposable>\n        sub <-\n            e.Subscribe (fun x -> \n                sub.Dispose()\n                creg.Dispose()\n                fork (fun () -> c.k (Ok x))        \n            )\n        creg <-\n            Register c.ct (fun () -> \n                match ca with\n                | Some ca ->\n                    ca()\n                | _ ->\n                    sub.Dispose()\n                    fork (fun () -> cancel c)    \n            ) \n\n[<JavaScript; Pure>]\nlet AwaitTask (t: System.Threading.Tasks.Task) : C<unit> =\n    FromContinuations (fun (ok, err, cc) ->\n        if t.Status = System.Threading.Tasks.TaskStatus.Created then\n            t.Start()\n        t.ContinueWith(fun t ->\n            if t.IsCanceled then\n                cc (OCE())\n            elif t.IsFaulted then\n                err t.Exception\n            else\n                ok()   \n        ) |> ignore\n    )\n\n[<JavaScript; Pure>]\nlet AwaitTask1 (t: System.Threading.Tasks.Task<'T>) : C<'T> =\n    FromContinuations (fun (ok, err, cc) ->\n        if t.Status = System.Threading.Tasks.TaskStatus.Created then\n            t.Start()\n        t.ContinueWith(fun (t: System.Threading.Tasks.Task<'T>) ->\n            if t.IsCanceled then\n                cc (OCE())\n            elif t.IsFaulted then\n                err t.Exception\n            else\n                ok t.Result  \n        ) |> ignore\n    )\n\n[<JavaScript>]\nlet StartAsTask (c: C<'T>, ctOpt) =\n    let tcs = System.Threading.Tasks.TaskCompletionSource<'T>()\n    StartWithContinuations (c, tcs.SetResult, tcs.SetException, (fun _ -> tcs.SetCanceled()), ctOpt)\n    tcs.Task\n\n[<JavaScript; Pure>]\nlet Sleep (ms: Milliseconds) : C<unit> =\n    ()\n    fun c ->\n        let mutable pending = JS.Undefined<JS.Handle>\n        let mutable creg = JS.Undefined<System.IDisposable>\n        pending <-\n            JS.SetTimeout (fun () -> \n                creg.Dispose()\n                fork (fun () -> c.k (Ok ()))\n            ) ms\n        creg <-\n            Register c.ct (fun () -> \n                JS.ClearTimeout pending\n                fork (fun () -> cancel c)\n            )\n\n[<JavaScript; Pure>]\nlet Parallel (cs: seq<C<'T>>) : C<'T[]> =\n    let cs = Array.ofSeq cs\n    if cs.Length = 0 then Return [||] else\n    fun c ->\n        let n = Array.length cs\n        let o = ref n\n        let a = As<'T[]>(JavaScript.Array(n))\n        let accept i x =\n            match !o, x with\n            | 0, _     -> ()\n            | 1, Ok x  -> a.[i] <- x; o := 0; c.k (Ok a)\n            | n, Ok x  -> a.[i] <- x; o := n - 1\n            | n, res   -> o := 0; c.k (As res)\n        Array.iteri (fun i run ->\n            fork (fun () -> run { k = accept i; ct = c.ct }))\n            cs\n\n[<JavaScript; Pure>]\nlet StartChild (r : C<'T>, t: Milliseconds option) : C<C<'T>> =\n    ()\n    fun c ->\n        let inTime = ref true\n        let cached = ref None\n        let queue  = Queue()\n        let tReg =\n            match t with\n            | Some timeout ->\n                JS.SetTimeout (fun () ->\n                    inTime := false\n                    let err = No (System.TimeoutException())\n                    while queue.Count > 0 do\n                        queue.Dequeue() err\n                ) timeout |> Some     \n            | _ -> None\n        fork (fun _ ->\n            if not c.ct.IsCancellationRequested then\n                r {\n                    k = fun res ->\n                        if !inTime then\n                            cached := Some res\n                            match tReg with\n                            | Some r -> JS.ClearTimeout r\n                            | _ -> ()\n                            while queue.Count > 0 do\n                                queue.Dequeue() res\n                    ct = c.ct\n                }\n        )\n        let r2 c2 =            \n            if !inTime then\n                match cached.Value with\n                | Some x    -> c2.k x\n                | None      -> queue.Enqueue c2.k\n            else c2.k (No (System.TimeoutException()))\n        c.k (Ok r2)\n\n[<JavaScript; Pure>]\nlet OnCancel (action: unit -> unit) : C<System.IDisposable> =\n    ()\n    fun c -> c.k (Ok (Register c.ct action))\n\n[<JavaScript; Pure>]\nlet TryCancelled (run: C<'T>, comp: OCE -> unit) : C<'T> =\n    ()\n    fun c ->\n        run {\n            k = function\n                | Cc e as res ->\n                    comp e\n                    c.k res\n                | res -> c.k res\n            ct = c.ct\n        }\n\n[<JavaScript; Pure>]\nlet Using (x: 'U, f: 'U -> C<'T>) =\n    TryFinally (f x, fun () -> (x :> System.IDisposable).Dispose())\n\n[<JavaScript; Pure>]\nlet rec While (g: unit -> bool, c: C<unit>) : C<unit> = \n    if g() then \n        Bind (c, fun () -> While (g, c)) \n    else\n        Return ()\n\n[<JavaScript; Pure>]\nlet rec For (s: seq<'T>, b: 'T -> C<unit>) =\n    Using (s.GetEnumerator(), fun ie -> \n        While ((fun () -> ie.MoveNext()), \n            Delay (fun () -> b ie.Current)))\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n/// Provides an `IEnumerator` implementation.\nmodule private WebSharper.Enumerator\n\nopen WebSharper.JavaScript\ntype IE<'T> = System.Collections.Generic.IEnumerator<'T>\n\n/// Represents an unfolding enumerator.\n[<Sealed>]\ntype T<'S,'T> [<JavaScript>] (s: 'S, c: 'T, n: T<'S,'T> -> bool, d: T<'S,'T> -> unit) =\n    [<Inline; JavaScript>] \n    member this.MoveNext() = n this\n    member this.State with [<Inline; JavaScript>] get() = s and [<Inline; JavaScript>] set (v: 'S) = this?s <- v\n    member this.Current with [<Inline; JavaScript>] get() = c and [<Inline; JavaScript>] set (v: 'T) = this?c <- v\n\n    interface System.Collections.IEnumerator with\n        [<JavaScript>] \n        member this.MoveNext() = n this\n        [<JavaScript>]\n        member this.Current with get() = box c\n        member this.Reset() = failwith \"IEnumerator.Reset not supported\"\n\n    interface System.Collections.Generic.IEnumerator<'T> with\n        [<JavaScript>]\n        member this.Current with get() = c\n\n    interface System.IDisposable with\n        [<JavaScript>] \n        member this.Dispose() = if As d then d this\n\n/// Constructs a new `IEnumerator` by unfolding a function.\n[<Inline>]\n[<JavaScript>]\nlet New<'S,'T> (state: 'S) (next: T<'S,'T> -> bool) =\n    As<IE<'T>> (new T<'S,'T>(state, As null, next, As JS.Undefined)) \n\n[<Inline>]\n[<JavaScript>]\nlet NewDisposing<'S,'T> (state: 'S) dispose (next: T<'S,'T> -> bool) =\n    As<IE<'T>> (new T<'S,'T>(state, As null, next, dispose))\n\n[<Inline \"$x.GetEnumerator()\">]\nlet getEnumerator (x: obj) : IE<'T> = X\n\n[<JavaScript>]\nlet ArrayEnumerator (s: obj[]) =\n    New 0 (fun e ->\n        let i = e.State\n        if i < s.Length then\n            e.Current <- As s.[i]\n            e.State <- i + 1\n            true\n        else\n            false)\n\n[<JavaScript>]\nlet StringEnumerator (s: string) =\n    New 0 (fun e ->\n        let i = e.State\n        if i < s.Length then\n            e.Current <- As s.[i]\n            e.State <- i + 1\n            true\n        else\n            false)\n\n[<JavaScript>]\nlet Get (x: seq<'T>) : IE<'T> =\n    if x :? System.Array then\n        ArrayEnumerator (As x)\n    elif JS.TypeOf x = JS.String then\n        StringEnumerator (As x)\n    else\n        getEnumerator x\n\n[<Inline \"'GetEnumerator0' in $x ? $x.GetEnumerator0() : $x.GetEnumerator()\">]\nlet getEnumerator0 (x: obj) : System.Collections.IEnumerator = X\n\n[<JavaScript>]\nlet Get0 (x: System.Collections.IEnumerable) : System.Collections.IEnumerator =\n    if x :? System.Array then\n        As (ArrayEnumerator (As x))\n    elif JS.TypeOf x = JS.String then\n        As (StringEnumerator (As x))\n    else\n        getEnumerator0 x\n\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n/// Provides seq/list/array proxies\n[<JavaScript>]\nmodule internal WebSharper.CollectionInternals\n\nopen WebSharper.JavaScript\n\n[<Name \"WebSharper.Arrays.splitInto\">]\nlet ArraySplitInto count (arr: 'T[]) =\n    if count <= 0 then failwith \"Count must be positive\"\n    let len = arr.Length\n    if len = 0 then\n        [| |]\n    else\n        let count = min count len\n        let res = Array.zeroCreate count : 'T[][]\n        let minChunkSize = len / count\n        let mutable startIndex = 0\n        for i = 0 to len % count - 1 do\n            res.JS.[i] <- Array.sub arr startIndex (minChunkSize + 1)\n            startIndex <- startIndex + minChunkSize + 1\n        for i = len % count to count - 1 do\n            res.JS.[i] <-  Array.sub arr startIndex minChunkSize\n            startIndex <- startIndex + minChunkSize\n        res\n\n[<Name \"WebSharper.Arrays.contains\">]\nlet ArrayContains (item: 'T) (arr: 'T[])  =\n    let mutable c = true\n    let mutable i = 0\n    let l = arr.Length\n    while c && i < l do\n        if arr.JS.[i] = item then\n            c <- false\n        else\n            i <- i + 1\n    not c\n\n[<Name \"WebSharper.Arrays.tryFindBack\">]\nlet ArrayTryFindBack f (arr: _ []) =\n    let mutable res = None\n    let mutable i = Array.length arr - 1\n    while i >= 0 && Option.isNone res do\n        let r = arr.JS.[i]\n        if f r then res <- Some r\n        i <- i - 1\n    res\n\n[<Name \"WebSharper.Arrays.tryFindIndexBack\">]\nlet ArrayTryFindIndexBack f (arr: _ []) =\n    let mutable res = None\n    let mutable i = Array.length arr - 1\n    while i >= 0 && Option.isNone res do\n        if f arr.[i] then res <- Some i\n        i <- i - 1\n    res\n\n[<Name \"WebSharper.Arrays.mapFold\">]\nlet ArrayMapFold<'T, 'S, 'R> (f: 'S -> 'T -> 'R * 'S) (zero: 'S) (arr: 'T[]) : 'R[] * 'S =\n    let r = JavaScript.Array(Array.length arr)\n    let mutable acc = zero\n    for i = 0 to Array.length arr - 1 do\n        let a, b = f acc arr.JS.[i]\n        r.[i] <- a\n        acc <- b \n    r.Self, acc\n\n[<Name \"WebSharper.Arrays.mapFoldBack\">]\nlet ArrayMapFoldBack<'T,'S,'R> (f: 'T -> 'S -> 'R * 'S) (arr: 'T[]) (zero: 'S) : 'R[] * 'S =\n    let r = JavaScript.Array<'R>(Array.length arr)\n    let mutable acc = zero\n    let len = Array.length arr\n    for j = 1 to len do\n        let i = len - j\n        let a, b = f arr.JS.[i] acc\n        r.[i] <- a\n        acc <- b \n    r.Self, acc\n\n[<Name \"WebSharper.Arrays.mapInPlace\">]\nlet mapInPlace (f: 'T1 -> 'T2) (arr: 'T1 []) =\n    for i = 0 to Array.length arr - 1 do\n        arr.JS.[i] <- As (f arr.JS.[i])\n\n[<Name \"WebSharper.Arrays.mapiInPlace\">]\nlet mapiInPlace (f: int -> 'T1 -> 'T2) (arr: 'T1 []) : 'T2[] =\n    for i = 0 to Array.length arr - 1 do\n        arr.JS.[i] <- As (f i arr.JS.[i])\n    As arr\n\n[<Name \"WebSharper.Arrays.sortInPlaceByDescending\">]\nlet ArraySortInPlaceByDescending<'T,'U when 'U: comparison> (f: 'T -> 'U) (arr: 'T []) =\n    (mapiInPlace (fun i x -> x, (f x, i)) arr).JS.Sort(fun (x, y) -> - compare (snd x) (snd y)) |> mapInPlace fst \n\n[<Name \"WebSharper.Seq.tryHead\">]\nlet SeqTryHead (s: seq<'T>) =\n    use e = Enumerator.Get s\n    if e.MoveNext() then Some e.Current else None\n\n[<Name \"WebSharper.Seq.tryItem\">]\nlet SeqTryItem i (s: seq<'T>) =\n    if i < 0 then None else\n    let mutable j = 0\n    use e = Enumerator.Get s\n    let mutable go = true\n    while go && j <= i do\n        if e.MoveNext() then\n            j <- j + 1\n        else\n            go <- false\n    if go then Some e.Current else None\n\n[<Name \"WebSharper.Seq.tryLast\">]\nlet SeqTryLast (s: seq<'T>) =\n    use e = Enumerator.Get s\n    if e.MoveNext() then \n        while e.MoveNext() do ()\n        Some e.Current \n    else None\n\n[<Name \"WebSharper.Seq.chunkBySize\">]\nlet SeqChunkBySize (size: int) (s: seq<'T>) =\n    if size <= 0 then failwith \"Chunk size must be positive\"\n    Enumerable.Of <| fun () ->\n        let o = Enumerator.Get s\n        Enumerator.NewDisposing () (fun _ -> o.Dispose()) <| fun e ->\n            if o.MoveNext() then\n                let res = [|o.Current|]\n                while res.Length < size && o.MoveNext() do \n                    res.JS.Push o.Current |> ignore\n                e.Current <- res\n                true\n            else false\n\n[<Name \"WebSharper.Arrays.countBy\">]\nlet ArrayCountBy (f: 'T -> 'K) (a: 'T[]) : ('K * int)[] =\n    let d = System.Collections.Generic.Dictionary<'K, int>()\n    let keys = JavaScript.Array()\n    for i = 0 to a.Length - 1 do\n        let c = a.JS.[i]\n        let k = f c\n        if d.ContainsKey(k) then\n            d.[k] <- d.[k] + 1 \n        else\n            keys.Push(k) |> ignore\n            d.Add(k, 1)\n    As<'K[]> keys |> mapInPlace (fun k -> (k, d.[k]))\n    As keys\n\n[<Name \"WebSharper.Seq.except\">]\nlet SeqExcept (itemsToExclude: seq<'T>) (s: seq<'T>) =\n    Enumerable.Of <| fun () ->\n        let o  = Enumerator.Get s\n        let seen = System.Collections.Generic.HashSet(itemsToExclude)\n        Enumerator.NewDisposing () (fun _ -> o.Dispose()) <| fun e ->\n            if o.MoveNext() then\n                let mutable cur = o.Current\n                let mutable has = seen.Add(cur)\n                while not has && o.MoveNext() do\n                    cur <- o.Current\n                    has <- seen.Add(cur)\n                if has then\n                    e.Current <- cur\n                    true\n                else\n                    false\n            else\n                false\n\n[<Name \"WebSharper.List.skip\">]\nlet ListSkip i (l : list<'T>) =\n    let mutable res = l\n    for j = 1 to i do\n        match res with \n        | _ :: t ->\n            res <- t\n        | [] -> failwith \"Input list too short.\"\n    res\n\n[<Name \"WebSharper.Arrays.groupBy\">]\nlet ArrayGroupBy (f: 'T -> 'K when 'K : equality) (a: 'T[]) : ('K * 'T[])[] =\n    let d = System.Collections.Generic.Dictionary<'K, 'T[]>()\n    let keys = JavaScript.Array()\n    for i = 0 to a.Length - 1 do\n        let c = a.JS.[i]\n        let k = f c\n        if d.ContainsKey(k) then\n            d.[k].JS.Push(c) |> ignore\n        else\n            keys.Push(k) |> ignore\n            d.Add(k, [| c |])\n    As<'K[]> keys |> mapInPlace (fun k -> (k, d.[k]))\n    As keys\n\n[<Name \"WebSharper.Seq.insufficient\">]\nlet InsufficientElements() =\n    failwith \"The input sequence has an insufficient number of elements.\"\n\n[<Name \"WebSharper.Seq.last\">]\nlet SeqLast (s: seq<_>) =\n    use e = Enumerator.Get s\n    if not <| e.MoveNext() then InsufficientElements()\n    else \n        while e.MoveNext() do ()\n        e.Current\n\n[<Name \"WebSharper.Seq.contains\">]\nlet SeqContains (el: 'T) (s: seq<'T>) =\n    use e = Enumerator.Get s\n    let mutable r = false\n    while not r && e.MoveNext() do\n        r <- e.Current = el\n    r\n\n[<Name \"WebSharper.List.skipWhile\">]\nlet rec ListSkipWhile<'T> (predicate : 'T -> bool) (list : list<'T>) : list<'T> =\n    let mutable rest = list\n    while not (List.isEmpty rest) && predicate (List.head rest) do\n        rest <- List.tail rest \n    rest\n\n[<Name \"WebSharper.Seq.nonNegative\">]\nlet InputMustBeNonNegative() =\n    failwith \"The input must be non-negative.\"\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\n#nowarn \"864\"\nopen WebSharper.JavaScript\n\n[<Proxy(typeof<System.Object>)>]\n[<Name \"WebSharper.Obj\">]\ntype private ObjectProxy() =\n\n    [<Inline>]\n    override this.GetHashCode() = Unchecked.hash this\n\n    [<Inline>]\n    override this.Equals(obj: obj) = Unchecked.equals (this :> obj) obj\n\n    [<Name \"GetHashCode\">]\n    member this.GetHashCodeImpl() = -1\n\n    [<Name \"Equals\">]\n    member this.EqualsImpl(obj: obj) = this ===. obj\n\n    [<Inline>]\n    static member Equals(a: obj, b: obj) = Unchecked.equals a b\n\n    [<Inline>]\n    static member ReferenceEquals(a: obj, b: obj) = a ===. b\n\n    [<Inline>]\n    static member op_Equality(a: obj, b: obj) = Unchecked.equals a b\n\n    [<Inline>]\n    static member op_Inequality(a: obj, b: obj) = not (Unchecked.equals a b)\n\n    [<Inline>]\n    override this.ToString() = string this\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Core.LanguagePrimitives+IntrinsicFunctions, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.IntrinsicFunctionProxy\n\nopen System\nopen WebSharper.JavaScript\n\n[<Inline \"$value\">]\nlet UnboxGeneric<'T> (value: obj) = X<'T>\n\n[<Inline \"$value\">]\nlet UnboxFast<'T> (value: obj) = X<'T>\n\n[<Macro(typeof<Macro.TypeTest>)>]\nlet TypeTestGeneric<'T> (value: obj) = X<bool>\n\n[<Macro(typeof<Macro.TypeTest>)>]\nlet TypeTestFast<'T> (value: obj) = X<bool>\n\n[<Inline \"$arr.length\">]\nlet GetArray2DLength1 (arr: 'T[,]) = X<int>\n\n[<Inline \"$arr.length ? $arr[0].length : 0\">]\nlet GetArray2DLength2 (arr: 'T[,]) =  X<int>\n\n[<Name \"WebSharper.Arrays.checkBounds\">]\nlet checkBounds (arr: 'T[]) (n: int) =\n    if n < 0 || n >= Array.length arr then\n        failwith \"Index was outside the bounds of the array.\"\n\n[<Name \"WebSharper.Arrays.checkBounds2D\">]\nlet checkBounds2D<'T> (arr: 'T[,]) (n1: int) (n2: int) =\n    if n1 < 0 || n2 < 0 || n1 >= GetArray2DLength1 arr\n        || n2 >= GetArray2DLength2 arr then\n        raise (new IndexOutOfRangeException())\n\n[<Name \"WebSharper.Arrays.checkRange\">]\n\nlet checkRange (arr: 'T []) (start: int) (size: int) : unit =\n    if (size < 0) || (start < 0) || (Array.length arr < start + size) then\n        failwith \"Index was outside the bounds of the array.\"\n\n[<Inline \"$arr[$n]\">]\nlet GetArrayInternal<'T> (arr: 'T[]) (n:int) = X<'T>\n\n[<Inline \"void ($arr[$n] = $x)\">]\nlet SetArrayInternal<'T> (arr: 'T[]) (n:int) (x:'T) = ()\n\n[<Name \"WebSharper.Arrays.set\">]\nlet SetArray<'T> (arr: 'T[]) (n: int) (x: 'T) =\n    checkBounds arr n\n    SetArrayInternal arr n x\n\n[<Inline \"$s[$ix]\">]\n[<Name \"WebSharper.Strings.get\">]\nlet GetString (s: string) (ix: int) = X<char>\n\n[<Name \"WebSharper.Arrays.get\">]\nlet GetArray<'T> (arr: 'T[]) (n: int) =\n    checkBounds arr n\n    GetArrayInternal arr n\n\n[<Inline \"$x.slice($start,$start+$length)\">]\nlet private subArray (x: 'T) start length = X<'T>\n\n[<Name \"WebSharper.Arrays.sub\">]\nlet GetArraySub<'T> (arr: 'T[]) start length =\n    checkRange arr start length\n    subArray arr start length\n\n[<Name \"WebSharper.Arrays.setSub\" >]\nlet SetArraySub<'T> (arr: 'T[]) start len (src: 'T[]) =\n    for i = 0 to len - 1 do\n        arr.[start+i] <- src.[i]\n\n[<Inline \"$arr[$n1][$n2]\">]\nlet GetArray2DInternal (arr: 'T[,]) (n1:int) (n2:int) = X<'T>\n\n[<Name \"WebSharper.Arrays.get2D\" >]\nlet GetArray2D (arr: 'T[,]) (n1: int) (n2: int) =\n    checkBounds2D arr n1 n2\n    GetArray2DInternal arr n1 n2\n\n[<Inline \"void ($arr[$n1][$n2] = $x)\">]\nlet SetArray2DInternal (arr: 'T[,]) (n1:int) (n2:int) (x:'T) = ()\n\n\n[<Name \"WebSharper.Arrays.set2D\" >]\nlet SetArray2D (arr: 'T[,]) (n1: int) (n2: int) (x: 'T) =\n    checkBounds2D arr n1 n2\n    SetArray2DInternal arr n1 n2 x\n\n[<Name \"WebSharper.Arrays.zeroCreate2D\" >]\nlet Array2DZeroCreate<'T> (n:int) (m:int) =\n    let arr = As<'T[,]>(Array.init n (fun _ -> Array.zeroCreate m))\n    arr?dims <- 2\n    arr\n\n[<Name \"WebSharper.Arrays.sub2D\" >]\nlet GetArray2DSub<'T> (src: 'T[,]) src1 src2 len1 len2 =\n    let len1 = (if len1 < 0 then 0 else len1)\n    let len2 = (if len2 < 0 then 0 else len2)\n    let dst = Array2DZeroCreate len1 len2\n    for i = 0 to len1 - 1 do\n        for j = 0 to len2 - 1 do\n            dst.[i,j] <- src.[src1 + i, src2 + j]\n    dst\n\n[<Name \"WebSharper.Arrays.setSub2D\" >]\nlet SetArray2DSub<'T> (dst: 'T[,]) src1 src2 len1 len2 (src: 'T[,]) =\n    for i = 0 to len1 - 1 do\n        for j = 0 to len2 - 1 do\n            dst.[src1+i, src2+j] <- src.[i, j]\n\n[<Name \"WebSharper.Arrays.length\" >]\nlet GetLength<'T> (arr: System.Array) =\n    match arr?dims with\n    | 2 -> GetArray2DLength1 (As arr) * GetArray2DLength1 (As arr)\n    | _ -> Array.length (As arr)\n\n[<Name \"WebSharper.checkThis\">]\nlet CheckThis (this: 'T) =\n    if this = null then\n        invalidOp \"The initialization of an object or value resulted in an object or value being accessed recursively before it was fully initialized.\"\n    else this", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen WebSharper.JavaScript\nmodule F = WebSharper.IntrinsicFunctionProxy\n\n[<Proxy(typeof<System.Array>)>]\ntype private ArrayProxy =\n\n    [<Inline \"$array.reverse()\">]\n    static member Reverse(array: System.Array) = X<unit>\n\n    [<Name \"WebSharper.Arrays.reverse\">]\n    static member Reverse(array: System.Array, offset: int, length: int) =\n        let a = Array.rev (Array.sub (As array) offset length)\n        Array.blit a 0 (As array) offset a.Length\n\n    member this.Length\n        with [<Inline>] get() = F.GetLength (As this)   \n\n    [<Inline>]\n    member this.GetEnumerator() = Enumerator.Get0 (As this)         \n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.Name \"Arrays\">]\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Collections.ArrayModule, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.ArrayModuleProxy\n\nopen WebSharper.JavaScript\nopen WebSharper.CollectionInternals\n\nmodule F = WebSharper.IntrinsicFunctionProxy\n\nlet checkLength (arr1: 'T1[]) (arr2: 'T2[]) =\n    if Array.length arr1 <> Array.length arr2 then\n        failwith \"The arrays have different lengths.\"\n\n[<Inline \"$x.push($y)\">]\nlet push (x: obj) (y: obj) = ()\n\n[<Inline \"$arr1.concat($arr2)\">]\nlet Append<'T> (arr1: 'T []) (arr2: 'T []) : 'T [] = arr1\n\n[<Name \"allPairs\">]\nlet AllPairs (array1: 'T1 []) (array2: 'T2 []) =\n    let len1 = Array.length array1\n    let len2 = Array.length array2\n    let res = JavaScript.Array (len1 * len2)\n    for i = 0 to len1-1 do\n        for j = 0 to len2-1 do\n            res.[i * len2 + j] <- (array1.JS.[i],array2.JS.[j])\n    res |> As<('T1 * 'T2) []>\n\n[<Name \"average\">]\nlet inline Average (arr: 'T []): 'T = As (float (Array.sum arr) / float (Array.length arr))\n\n[<Name \"averageBy\">]\nlet inline AverageBy (f: 'T -> 'U) (arr: 'T []) : 'U = As (float (Array.sumBy f arr) / float (Array.length arr))\n\n[<Name \"blit\">]\nlet CopyTo<'T> (arr1: 'T [], start1, arr2: 'T [], start2, length) =\n    F.checkRange arr1 start1 length\n    F.checkRange arr2 start2 length\n    for i = 0 to length - 1 do\n        arr2.JS.[start2 + i] <- arr1.JS.[start1 + i]\n\n[<Name \"choose\">]\nlet Choose<'T,'U> (f: 'T -> option<'U>) (arr: 'T []) : 'U [] =\n    let q : 'U [] = [||]\n    for i = 0 to Array.length arr - 1 do\n        match f arr.JS.[i] with\n        | Some x -> push q x\n        | None   -> ()\n    q\n\n[<Inline \"Array.prototype.concat.apply([], $x)\"; Pure>]\nlet concatArray (x: 'T[][]) = X<'T[]>\n\n[<Name \"collect\">]\nlet Collect<'T,'U> (f: 'T -> 'U[]) (x: 'T []) : 'U[] =\n    concatArray (Array.map f x)\n\n[<Name \"concat\">]\nlet Concat<'T> (xs: seq<'T []>) : 'T [] =\n    concatArray (Array.ofSeq xs)\n\n[<Inline>]\nlet SplitInto count (arr: 'T[]) = ArraySplitInto count arr\n\n[<Inline \"$x.slice()\">]\nlet Copy (x: 'T []) = X<'T []>\n\n[<Name \"create\">]\nlet Create (size: int) value =\n    let r = JavaScript.Array(size)\n    for i = 0 to size - 1 do\n        r.[i] <- value\n    r.Self\n\n[<Inline \"[]\">]\nlet Empty () = X<'T []>\n\n[<Name \"exists\">]\nlet Exists<'T> (f: 'T -> bool) (x: 'T []) =\n    let mutable e = false\n    let mutable i = 0\n    let l = x.Length\n    while not e && i < l do\n        if f x.JS.[i] then\n            e <- true\n        else\n            i <- i + 1\n    e\n\n[<Name \"exists2\">]\nlet Exists2 f (x1: _ []) (x2: _ []) =\n    checkLength x1 x2\n    let mutable e = false\n    let mutable i = 0\n    let l = x1.Length\n    while not e && i < l do\n        if f x1.JS.[i] x2.JS.[i] then\n            e <- true\n        else\n            i <- i + 1\n\n    e\n\n[<Name \"fill\">]\nlet Fill<'T> (arr: 'T []) (start: int) (length: int) (value: 'T) =\n    F.checkRange arr start length\n    for i = start to start + length - 1 do\n        arr.JS.[i] <- value\n\n[<Name \"filter\">]\nlet Filter<'T> f (arr: 'T []) : 'T [] =\n    let r : 'T [] = [||]\n    for i = 0 to Array.length arr - 1 do\n        if f arr.JS.[i] then\n            push r arr.JS.[i]\n    r\n\n[<Name \"find\">]\nlet Find f (arr: _ []) =\n    match Array.tryFind f arr with\n    | Some x -> x\n    | None   -> failwith \"KeyNotFoundException\"\n\n[<Name \"findIndex\">]\nlet FindIndex f (arr: _ []) =\n    match Array.tryFindIndex f arr with\n    | Some x -> x\n    | None   -> failwith \"KeyNotFoundException\"\n\n[<Name \"fold\">]\nlet Fold<'T,'S> (f: 'S -> 'T -> 'S) (zero: 'S) (arr: 'T []) : 'S =\n    let mutable acc = zero\n    for i = 0 to Array.length arr - 1 do\n        acc <- f acc arr.JS.[i]\n    acc\n\n[<Name \"fold2\">]\nlet Fold2<'T1,'T2,'S> f (zero: 'S) (arr1: 'T1 []) (arr2: 'T2 []) : 'S =\n    checkLength arr1 arr2\n    let mutable accum = zero\n    for i in 0 .. Array.length arr1 - 1 do\n        accum <- f accum arr1.JS.[i] arr2.JS.[i]\n    accum\n\n[<Name \"foldBack\">]\nlet FoldBack f (arr: _ []) zero =\n    let mutable acc = zero\n    let len = Array.length arr\n    for i = 1 to len do\n        acc <- f arr.JS.[len - i] acc\n    acc\n\n[<Name \"foldBack2\">]\nlet FoldBack2 f (arr1: _ []) (arr2: _ []) zero =\n    checkLength arr1 arr2\n    let len = Array.length arr1\n    let mutable accum = zero\n    for i in 1 .. len do\n        accum <- f arr1.JS.[len - i] arr2.JS.[len - i] accum\n    accum\n\n[<Name \"forall\">]\nlet ForAll f (x: _ []) =\n    let mutable a = true\n    let mutable i = 0\n    let l = x.Length\n    while a && i < l do\n        if f x.JS.[i] then\n            i <- i + 1\n        else\n            a <- false\n    a\n\n[<Name \"forall2\">]\nlet ForAll2 f (x1: _ []) (x2: _ []) =\n    checkLength x1 x2\n    let mutable a = true\n    let mutable i = 0\n    let l = x1.Length\n    while a && i < l do\n        if f x1.JS.[i] x2.JS.[i] then\n            i <- i + 1\n        else\n            a <- false\n    a\n\n[<Inline>]\nlet Get (arr: _ []) index =\n    F.GetArray arr index\n\n[<Inline>]\nlet Item index (arr: _ []) =\n    F.GetArray arr index\n\n[<Name \"init\">]\nlet Initialize (size: int) f =\n    if size < 0 then\n        failwith \"Negative size given.\"\n    let r = JavaScript.Array(size)\n    for i = 0 to size - 1 do\n        r.[i] <- f i\n    r.Self\n\n[<Inline \"$arr.length == 0\">]\nlet IsEmpty (arr: _ []) = X<bool>\n\n[<Name \"iter\">]\nlet Iterate f (arr: 'T []) =\n    for i = 0 to Array.length arr - 1 do\n        f arr.JS.[i]\n\n[<Name \"iter2\">]\nlet Iterate2 f (arr1: _ []) (arr2: _ []) =\n    checkLength arr1 arr2\n    for i = 0 to Array.length arr1 - 1 do\n        f arr1.JS.[i] arr2.JS.[i]\n\n[<Name \"iteri\">]\nlet IterateIndexed f (arr: 'T []) =\n    for i = 0 to Array.length arr - 1 do\n        f i arr.JS.[i]\n\n[<Name \"iteri2\">]\nlet IterateIndexed2 f (arr1: _ []) (arr2: _ []) =\n    checkLength arr1 arr2\n    for i = 0 to Array.length arr1 - 1 do\n        f i arr1.JS.[i] arr2.JS.[i]\n\n[<Inline \"$arr.length\">]\nlet Length<'T> (arr: 'T []) = X<int>\n\n[<Name \"map\">]\nlet Map<'T1,'T2> (f: 'T1 -> 'T2) (arr: 'T1 []) : 'T2 [] =\n    let r = JavaScript.Array<'T2>(Array.length arr)\n    for i = 0 to Array.length arr - 1 do\n        r.[i] <- f arr.JS.[i]\n    r.Self\n\n[<Name \"map2\">]\nlet Map2 (f: 'T1 -> 'T2 -> 'T3) (arr1: 'T1 []) (arr2: 'T2 []) : 'T3 [] =\n    checkLength arr1 arr2\n    let r = JavaScript.Array<'T3>(Array.length arr2)\n    for i = 0 to Array.length arr2 - 1 do\n        r.[i] <- f arr1.JS.[i] arr2.JS.[i]\n    r.Self\n\n[<Name \"mapi\">]\nlet MapIndexed f (arr: _ []) =\n    let y = JavaScript.Array(Array.length arr)\n    for i = 0 to Array.length arr - 1 do\n        y.[i] <- f i arr.JS.[i]\n    y.Self\n\n[<Name \"mapi2\">]\nlet MapIndexed2 f (arr1: 'T1 []) (arr2: 'T2 []): 'U[] =\n    checkLength arr1 arr2\n    let res = JavaScript.Array(Array.length arr1)\n    for i = 0 to Array.length arr1 - 1 do\n        res.[i] <- f i arr1.JS.[i] arr2.JS.[i]\n    res.Self\n\n[<Inline>]\nlet MapFold<'T,'S,'R> f zero arr = ArrayMapFold<'T, 'S, 'R> f zero arr\n\n[<Inline>]\nlet MapFoldBack f arr zero = ArrayMapFoldBack f arr zero\n\n[<Name \"max\">]\nlet Max x = Array.reduce max x\n\n[<Name \"maxBy\">]\nlet MaxBy f arr =\n    Array.reduce (fun x y -> if f x > f y then x else y) arr\n\n[<Name \"min\">]\nlet Min x = Array.reduce min x\n\n[<Name \"minBy\">]\nlet MinBy f arr =\n    Array.reduce (fun x y -> if f x < f y then x else y) arr\n\n[<Name \"ofList\">]\nlet OfList<'T> (xs: list<'T>) =\n    let q : 'T [] = [||]\n    let mutable l = xs\n    while not (List.isEmpty l) do\n        push q l.Head\n        l <- l.Tail\n    q\n\n[<Name \"ofSeq\">]\nlet OfSeq<'T> (xs: seq<'T>) : 'T [] =\n    if xs :? System.Array then\n        Array.copy (As<'T[]> xs)\n    elif xs :? _ list then\n        Array.ofList (As<'T list> xs)\n    else\n        let q : 'T [] = [||]\n        use o = Enumerator.Get xs\n        while o.MoveNext() do\n            push q o.Current\n        q\n\n[<Name \"partition\">]\nlet Partition f (arr: 'T []) : 'T [] * 'T [] =\n    let ret1 : 'T [] = [||]\n    let ret2 : 'T [] = [||]\n    for i = 0 to Array.length arr - 1 do\n        if f arr.JS.[i] then\n            push ret1 arr.JS.[i]\n        else\n            push ret2 arr.JS.[i]\n    (ret1, ret2)\n\n[<Name \"permute\">]\nlet Permute f (arr: 'T []) =\n    let ret = JavaScript.Array(Array.length arr)\n    for i = 0 to Array.length arr - 1 do\n        ret.[f i] <- arr.JS.[i]\n    ret.Self\n\n[<Name \"pick\">]\nlet Pick f (arr: _ []) =\n    match Array.tryPick f arr with\n    | Some x -> x\n    | None   -> failwith \"KeyNotFoundException\"\n\nlet private nonEmpty (arr: _ []) =\n    if Array.length arr = 0 then\n        failwith \"The input array was empty.\"\n\n[<Name \"reduce\">]\nlet Reduce f (arr: _ []) =\n    nonEmpty arr\n    let mutable acc = arr.JS.[0]\n    for i = 1 to Array.length arr - 1 do\n        acc <- f acc arr.JS.[i]\n    acc\n\n[<Name \"reduceBack\">]\nlet ReduceBack f (arr: _ []) =\n    nonEmpty arr\n    let len = Array.length arr\n    let mutable acc = arr.JS.[len - 1]\n    for i = 2 to len do\n        acc <- f arr.JS.[len - i] acc\n    acc\n\n[<Inline \"$x.slice().reverse()\">]\nlet Reverse (x: 'T []) = X<'T []>\n\n[<Name \"scan\">]\nlet Scan<'T,'S> (f: 'S -> 'T -> 'S) (zero: 'S) (arr: 'T []) : 'S [] =\n    let ret = JavaScript.Array(1 + Array.length arr)\n    ret.[0] <- zero\n    for i = 0 to Array.length arr - 1 do\n        ret.[i + 1] <- f ret.[i] arr.JS.[i]\n    ret.Self\n\n[<Name \"scanBack\">]\nlet ScanBack (f: 'T -> 'S -> 'S) (arr: 'T []) (zero: 'S) : 'S [] =\n    let len = Array.length arr\n    let ret = JavaScript.Array(1 + len)\n    ret.[len] <- zero\n    for i = 0 to len - 1 do\n        ret.[len - i - 1] <- f arr.JS.[len - i - 1] ret.[len - i]\n    ret.Self\n\n[<Inline>]\nlet Set (arr: _ []) i v =\n    F.SetArray arr i v\n\n[<Name \"sort\">]\nlet Sort<'T when 'T: comparison> (arr: 'T []) : 'T [] =\n    (Array.mapi (fun i x -> x, i) arr).JS.Sort(fun (x, y) -> compare x y) |> Array.map fst\n\n[<Name \"sortBy\">]\nlet SortBy<'T,'U when 'U: comparison> (f: 'T -> 'U) (arr: 'T []) : 'T [] =\n    (Array.mapi (fun i x -> x, (f x, i)) arr).JS.Sort(fun (x, y) -> compare (snd x) (snd y)) |> Array.map fst\n\n[<Name \"sortInPlace\">]\nlet SortInPlace<'T when 'T: comparison> (arr: 'T []) =\n    (mapiInPlace (fun i x -> x, i) arr).JS.Sort(fun (x, y) -> compare x y) |> mapInPlace fst\n\n[<Name \"sortInPlaceBy\">]\nlet SortInPlaceBy<'T,'U when 'U: comparison> (f: 'T -> 'U) (arr: 'T []) =\n    (mapiInPlace (fun i x -> x, (f x, i)) arr).JS.Sort(fun (x, y) -> compare (snd x) (snd y)) |> mapInPlace fst \n\n[<Name \"sortInPlaceWith\">]\nlet SortInPlaceWith<'T> (comparer: 'T -> 'T -> int) (arr: 'T []) =\n    arr.JS.Sort(fun (x, y) -> comparer x y) |> ignore\n\n[<Name \"sortWith\">]\nlet SortWith<'T> (comparer: 'T -> 'T -> int) (arr: 'T []) : 'T [] =\n    (Array.copy arr).JS.Sort(fun (x, y) -> comparer x y)\n\n[<Name \"sortByDescending\">]\nlet SortByDescending<'T,'U when 'U: comparison> (f: 'T -> 'U) (arr: 'T []) : 'T [] =\n    (Array.mapi (fun i x -> x, (f x, i)) arr).JS.Sort(fun (x, y) -> - compare (snd x) (snd y)) |> Array.map fst\n\n[<Name \"sortDescending\">]\nlet SortDescending<'T when 'T: comparison> (arr: 'T []) : 'T [] =\n    (Array.mapi (fun i x -> x, i) arr).JS.Sort(fun (x, y) -> - compare x y) |> Array.map fst\n\n[<Inline \"$x.slice($start,$start+$length)\">]\nlet private subArray (x: 'T) start length = X<'T>\n\n[<Inline>]\nlet GetSubArray (arr: 'T []) (start: int) (length: int) : 'T []=\n    F.GetArraySub arr start length\n\n[<Direct \"var sum = 0; for (var i = 0; i < $arr.length; i++) sum += $arr[i]; return sum\">]\n[<Name \"sum\">]\nlet Sum (arr: 'T []) : 'T = X<'T>\n\n[<Direct \"var sum = 0; for (var i = 0; i < $arr.length; i++) sum += $f($arr[i]); return sum\">]\n[<Name \"sumBy\">]\nlet SumBy (f: 'T -> 'U) (arr: 'T []) : 'U =  X<'U>\n\n[<Inline>]\nlet ToList arr = List.ofArray arr\n\n[<Inline \"$arr\">]\nlet ToSeq (arr: _ []) = arr :> seq<_>\n\n[<Name \"tryFind\">]\nlet TryFind f (arr: _ []) =\n    let mutable res = None\n    let mutable i = 0\n    while i < Array.length arr && Option.isNone res do\n        if f arr.JS.[i] then res <- Some arr.JS.[i]\n        i <- i + 1\n    res\n\n[<Inline>]\nlet TryFindBack f (arr: _ []) = ArrayTryFindBack f arr\n\n[<Name \"tryFindIndex\">]\nlet TryFindIndex f (arr: _ []) =\n    let mutable res = None\n    let mutable i = 0\n    while i < Array.length arr && Option.isNone res do\n        if f arr.JS.[i] then res <- Some i\n        i <- i + 1\n    res\n\n[<Inline>]\nlet TryFindIndexBack f (arr: _ []) = ArrayTryFindIndexBack f arr\n\n[<Name \"tryHead\">]\nlet TryHead (arr: 'T[]) =\n    if Array.length arr = 0 then None else Some arr.JS.[0]\n\n[<Name \"tryItem\">]\nlet TryItem i (arr: 'T[]) =\n    if Array.length arr <= i || i < 0 then None else Some arr.JS.[i]\n\n[<Name \"tryLast\">]\nlet TryLast (arr: 'T[]) =\n    let len = Array.length arr\n    if len = 0 then None else Some arr.JS.[len - 1]\n\n[<Name \"tryPick\">]\nlet TryPick f (arr: _ []) =\n    let mutable res = None\n    let mutable i = 0\n    while i < Array.length arr && Option.isNone res do\n        match f arr.JS.[i] with\n        | Some _ as r -> res <- r\n        | _ -> ()\n        i <- i + 1\n    res\n\n[<Name \"unzip\">]\nlet Unzip<'T1,'T2> (arr: ('T1 * 'T2) []) : 'T1 [] * 'T2 [] =\n    let x : 'T1 [] = [||]\n    let y : 'T2 [] = [||]\n    for i = 0 to Array.length arr - 1 do\n        let (a, b) = arr.JS.[i]\n        push x a\n        push y b\n    (x, y)\n\n[<Name \"unzip3\">]\nlet Unzip3<'T1,'T2,'T3> (arr: ('T1 * 'T2 * 'T3) []) =\n    let x : 'T1 [] = [||]\n    let y : 'T2 [] = [||]\n    let z : 'T3 [] = [||]\n    for i = 0 to Array.length arr - 1 do\n        match arr.JS.[i] with\n        | (a, b, c) ->\n            push x a\n            push y b\n            push z c\n    (x, y, z)\n\n[<Inline>]\n[<Name \"zeroCreate\">]\nlet ZeroCreate<'T> (size: int) =\n    Create size Unchecked.defaultof<'T>\n\n[<Name \"zip\">]\nlet Zip (arr1: 'T1 []) (arr2: 'T2 []) =\n    checkLength arr1 arr2\n    let res = Array.zeroCreate (Array.length arr1)\n    for i = 0 to Array.length arr1 - 1 do\n        res.JS.[i] <- (arr1.JS.[i], arr2.JS.[i])\n    res\n\n[<Name \"zip3\">]\nlet Zip3 (arr1: _ [], arr2: _ [], arr3: _ []) =\n    checkLength arr1 arr2\n    checkLength arr2 arr3\n    let res = Array.zeroCreate (Array.length arr1)\n    for i = 0 to Array.length arr1 - 1 do\n        res.JS.[i] <- (arr1.JS.[i], arr2.JS.[i], arr3.JS.[i])\n    res\n\n[<Name \"chunkBySize\">]\nlet ChunkBySize size array =\n    SeqChunkBySize size (Array.toSeq array)\n    |> Seq.toArray\n\n[<Name \"compareWith\">]\nlet CompareWith  (f: 'T -> 'T -> int) (a1: 'T []) (a2: 'T []) : int =\n    Seq.compareWith f (Array.toSeq a1) (Array.toSeq a2)\n\n[<Inline>]\nlet CountBy (f: 'T -> 'K) (a: 'T []) : ('K * int) [] =\n    ArrayCountBy f a\n\n[<Name \"distinct\">]\nlet Distinct<'T when 'T : equality> (l: 'T []) : 'T [] =\n    Seq.distinct (Array.toSeq l)\n    |> Seq.toArray\n\n[<Name \"distinctBy\">]\nlet DistinctBy<'T,'K when 'K : equality>\n        (f: 'T -> 'K) (a: 'T []) : 'T [] =\n    Seq.distinctBy f (Array.toSeq a)\n    |> Seq.toArray\n\n[<Name \"except\">]\nlet Except (itemsToExclude: seq<'T>) (a: 'T []) =\n    SeqExcept itemsToExclude (Array.toSeq a)\n    |> Seq.toArray\n\n[<Name \"findBack\">]\nlet FindBack p (s: _ []) =\n    match TryFindBack p s with\n    | Some x -> x\n    | None   -> failwith \"KeyNotFoundException\"\n\n[<Name \"findIndexBack\">]\nlet FindIndexBack p (s: _ []) =\n    match TryFindIndexBack p s with\n    | Some x -> x\n    | None   -> failwith \"KeyNotFoundException\"\n\n[<Inline>]\nlet GroupBy (f: 'T -> 'K when 'K : equality)\n            (a: 'T []) : ('K * 'T []) [] =\n    ArrayGroupBy f a\n\n[<Name \"head\">]\nlet Head (arr : 'T []) : 'T =\n    nonEmpty arr\n    arr.JS.[0]\n\n[<Name \"last\">]\nlet Last (arr : 'T []) : 'T =\n    nonEmpty arr\n    arr.JS.[Array.length arr - 1]\n\n[<Name \"map3\">]\nlet Map3 (f: 'T1 -> 'T2 -> 'T3 -> 'T4) (arr1: 'T1 []) (arr2: 'T2 []) (arr3: 'T3 []) : 'T4 [] =\n    checkLength arr1 arr2\n    checkLength arr1 arr3\n    let r = JavaScript.Array<'T4>(Array.length arr3)\n    for i = 0 to Array.length arr3 - 1 do\n        r.[i] <- f arr1.JS.[i] arr2.JS.[i] arr3.JS.[i]\n    r.Self\n\n[<Inline>]\nlet Contains (el: 'T) (a: 'T []) =\n    ArrayContains el a\n\n[<Name \"pairwise\">]\nlet Pairwise (a: 'T []) : ('T * 'T) [] =\n    Seq.pairwise (Array.toSeq a)\n    |> Seq.toArray\n\n[<Name \"replicate\">]\nlet Replicate size value =\n    Array.create size value\n\n[<Name \"indexed\">]\nlet Indexed (ar : 'T []) : (int * 'T) [] =\n    Array.mapi (fun a b -> (a, b)) ar\n\n[<Inline>]\nlet Singleton<'T> (x: 'T) =\n    [| x |]\n\n[<Name \"skip\">]\nlet Skip<'T> i (ar : 'T []) =\n    if i < 0 then InputMustBeNonNegative() else\n    if i > Array.length ar then InsufficientElements() else\n    ar.JS.Slice(i)\n\n[<Name \"skipWhile\">]\nlet SkipWhile<'T> (predicate : 'T -> bool) (ar : 'T []) : 'T [] =\n    let len = Array.length ar\n    let mutable i = 0\n    while i < len && predicate ar.JS.[i] do\n        i <- i + 1\n    ar.JS.Slice(i)\n\n[<Name \"tail\">]\nlet Tail<'T> (ar : 'T []) : 'T [] =\n    Skip 1 ar\n\n[<Name \"take\">]\nlet Take<'T> n (ar: 'T []) =\n    if n < 0 then InputMustBeNonNegative() else\n    if n > Array.length ar then InsufficientElements() else\n    ar.JS.Slice(0, n)\n\n[<Name \"takeWhile\">]\nlet TakeWhile<'T> (predicate : 'T -> bool) (ar: 'T []) =\n    let len = Array.length ar\n    let mutable i = 0\n    while i < len && predicate ar.JS.[i] do\n        i <- i + 1\n    ar.JS.Slice(0, i)\n\n[<Inline>]\nlet Truncate<'T> n (ar: 'T []) =\n    ar.JS.Slice(0, n)\n\n[<Name \"exactlyOne\">]\nlet ExactlyOne (ar : 'T []) =\n    if Array.length ar = 1 then\n        ar.JS.[0]\n    else\n        failwith \"The input does not have precisely one element.\"\n\n[<Name \"unfold\">]\nlet Unfold<'T, 'S> (f: 'S -> option<'T * 'S>) (s: 'S) : 'T [] =\n    Seq.unfold f s\n    |> Seq.toArray\n\n[<Inline>]\nlet Where (predicate : 'T -> bool) (s : 'T []) : 'T [] =\n    Filter predicate s\n\n[<Name \"windowed\">]\nlet Windowed (windowSize: int) (s: 'T []) : array<'T []> =\n    Seq.windowed windowSize (Array.toSeq s)\n    |> Seq.toArray\n\n[<Name \"splitAt\">]\nlet SplitAt (n: int) (ar: 'T []) =\n    Take n ar, Skip n ar\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.Name \"Arrays2D\">]\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Collections.Array2DModule, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.Array2DModuleProxy\n\nopen WebSharper.JavaScript\nmodule F = WebSharper.IntrinsicFunctionProxy\n\n[<Inline>]\nlet Length1 (arr: 'T[,]) = F.GetArray2DLength1 arr\n\n[<Inline>]\nlet Length2 (arr: 'T[,]) = F.GetArray2DLength2 arr\n\n[<Inline>]\nlet Get (array: 'T[,]) (n:int) (m:int) = F.GetArray2D array n m\n\n[<Inline>]\nlet Set (array: 'T[,]) (n:int) (m:int) (x:'T) = F.SetArray2D array n m x\n\n[<Inline>]\nlet ZeroCreate (n:int) (m:int) = F.Array2DZeroCreate n m\n    \n[<Inline>]\nlet Create n m (x:'T) =\n    let arr = As<'T[,]>(Array.init n (fun _ -> Array.create m x))\n    arr?dims <- 2\n    arr\n     \n[<Name \"init\">]\nlet Initialize n m f = \n    let array = ZeroCreate n m : 'T[,]  \n    for i = 0 to n - 1 do \n        for j = 0 to m - 1 do \n            array.[i, j] <- f i j\n    array\n\n[<Name \"iter\">]\nlet Iterate f array = \n    let count1 = F.GetArray2DLength1 array \n    let count2 = F.GetArray2DLength2 array \n    for i = 0 to count1 - 1 do \n      for j = 0 to count2 - 1 do \n        f array.[i,j]\n\n[<Name \"iteri\">]\nlet IterateIndexed (f : int -> int -> 'T -> unit) (array:'T[,]) =\n    let count1 = F.GetArray2DLength1 array \n    let count2 = F.GetArray2DLength2 array \n    for i = 0 to count1 - 1 do \n      for j = 0 to count2 - 1 do \n        f i j array.[i,j]\n\n[<Name \"map\">]\nlet Map f array = \n    Initialize (F.GetArray2DLength1 array) (F.GetArray2DLength2 array) (fun i j -> f array.[i,j])\n\n[<Name \"mapi\">]\nlet MapIndexed f array = \n    Initialize (F.GetArray2DLength1 array) (F.GetArray2DLength2 array) (fun i j -> f i j array.[i,j])\n\n[<Name \"copy\">]\nlet Copy array = \n    Initialize (F.GetArray2DLength1 array) (F.GetArray2DLength2 array) (fun i j -> array.[i,j])\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen WebSharper.JavaScript\n\ntype private CT  = System.Threading.CancellationToken\ntype private CTS  = System.Threading.CancellationTokenSource\ntype private CTR  = System.Threading.CancellationTokenRegistration\ntype private OCE = System.OperationCanceledException\nmodule C = WebSharper.Concurrency\n\n[<Proxy(typeof<Async>)>]\ntype private AsyncProxy =\n\n    [<Inline>]\n    static member Catch(a: Async<'T>) : Async<Choice<'T,exn>>  =\n        As (C.Catch (As a))\n\n    [<Inline>]\n    static member Start(computation: Async<unit>, ?t: CT) : unit =\n        C.Start (As computation, As t)\n\n    [<Inline>]\n    static member Ignore (computation: Async<'T>) : Async<unit> =\n        As (C.Ignore (As computation))\n\n    [<Inline>]\n    static member Sleep milliseconds : Async<unit> =\n        As (C.Sleep milliseconds)\n\n    [<Inline>]\n    static member StartWithContinuations(op: Async<'T>,\n                                         c1: 'T -> unit,\n                                         c2: exn -> unit,\n                                         c3: OCE -> unit,\n                                         ?t: CT) : unit =\n        C.StartWithContinuations (As op, c1, c2, c3, As t)\n\n    [<Inline>]\n    static member FromContinuations(callback: (('T -> unit) *\n                                               (exn -> unit) *\n                                               (OCE -> unit)) -> unit)\n                                    : Async<'T> =\n        As (C.FromContinuations callback)\n\n    [<Inline>]\n    static member AwaitEvent(ev: IEvent<'D,'T>, ?t: unit -> unit) : Async<'T> =\n        As (C.AwaitEvent (As ev, t))\n\n    [<Inline>]\n    static member AwaitTask(t : System.Threading.Tasks.Task) : Async<unit> =\n        As (C.AwaitTask t)\n\n    [<Inline>]\n    static member AwaitTask(t : System.Threading.Tasks.Task<'T>) : Async<'T> =\n        As (C.AwaitTask1 t)\n\n    [<Inline>]\n    static member StartChild(a: Async<'T>, ?timeOut: int) : Async<Async<'T>> =\n        As (C.StartChild (As a, timeOut))\n\n    [<Inline>]\n    static member Parallel(cs: seq<Async<'T>>) : Async<'T []> =\n        As (C.Parallel (As cs))\n\n    [<Inline>]\n    static member StartImmediate(c: Async<unit>, ?t: CT) : unit =\n        C.StartImmediate (As c, As t)\n\n    [<Inline>]\n    static member StartAsTask (a: Async<'T>, ?opt :System.Threading.Tasks.TaskCreationOptions, ?t: CT) \n        : System.Threading.Tasks.Task<'T> =\n        C.StartAsTask(As a, As t)        \n\n    [<Inline>]\n    static member DefaultCancellationToken : CT =\n        As !C.defCTS\n\n    [<Inline>]\n    static member CancelDefaultToken() : unit =\n        let cts = !C.defCTS\n        C.defCTS := new CTS()\n        cts.Cancel()    \n\n    [<Inline>]\n    static member CancellationToken : Async<CT> =\n        As C.GetCT\n\n    [<Inline>]\n    static member OnCancel(action: unit -> unit) : Async<System.IDisposable> =\n        As (C.OnCancel action)\n    \n    [<Inline>]\n    static member TryCancelled(p: Async<'T>, f: OCE -> unit) : Async<'T> =\n        As (C.TryCancelled(As p, f))\n\n[<Proxy(typeof<CT>)>]\ntype private CancellationTokenProxy =\n    [<Inline \"$this.c\">]\n    member this.IsCancellationRequested = X<bool>\n\n    [<Inline>]\n    member this.Register(callback: System.Action) =\n        As<CTR> (C.Register (As this) callback.Invoke)\n\n    [<Inline>]\n    member this.ThrowIfCancellationRequested() =\n        if this.IsCancellationRequested then raise (OCE(As<CT> this)) \n\n    [<Inline>]\n    static member None = As<CT> C.noneCT\n        \n[<Proxy(typeof<CTS>)>]\n[<Name \"CancellationTokenSource\">]\ntype private CancellationTokenSourceProxy () =\n    let mutable c = false\n\n    let mutable pending = None\n\n    let r = [||] : (unit -> unit)[]\n\n    [<Inline>]\n    new (delay: int) as this = \n        CancellationTokenSourceProxy() then this.CancelAfter(delay)\n\n    [<Inline>]\n    new (delay: System.TimeSpan) as this = \n        CancellationTokenSourceProxy() then this.CancelAfter(delay)\n\n    [<Inline>]\n    member this.IsCancellationRequested = c\n\n    member this.Token \n        with [<Inline \"$this\">] get() = X<CT>\n\n    member this.Cancel() =\n        if not c then\n            c <- true\n            let errors = \n                r |> Array.choose (fun a -> \n                    try a()\n                        None\n                    with e -> Some e\n                )\n            if errors.Length > 0 then\n                raise (System.AggregateException(errors))    \n            \n    member this.Cancel(throwOnFirstException) =\n        if not throwOnFirstException then\n            this.Cancel()\n        else\n            if not c then\n                c <- true\n                r |> Array.iter (fun a -> a())   \n \n    member this.CancelAfter(delay: int) =\n        if not c then\n            pending |> Option.iter JS.ClearTimeout\n            pending <- Some <| JS.SetTimeout this.Cancel delay\n\n    [<Inline>]\n    member this.CancelAfter(delay: System.TimeSpan) = this.CancelAfter(As<int> delay)\n\n    static member CreateLinkedTokenSource(tokens: CT[]) =\n        let cts = new CTS()\n        tokens |> Array.iter (fun t -> t.Register(fun () -> cts.Cancel()) |> ignore)\n        cts\n\n    static member CreateLinkedTokenSource(t1: CT, t2: CT) =\n        CancellationTokenSourceProxy.CreateLinkedTokenSource [| t1; t2 |]\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen WebSharper.JavaScript\n\n[<Name \"Char\">]\n[<Proxy(typeof<System.Char>)>]\ntype private CharProxy =\n\n    [<Inline \"'\\u0000'\">]\n    new () = {}\n\n    static member GetNumericValue(c: char) : float =\n        if c >= '0' && c <= '9' then float c - float '0' else -1.\n\n    static member IsControl(c: char) : bool =\n        c >= '\\u0000' && c <= '\\u001f'\n        || c >= '\\u0080' && c <= '\\u009f'\n\n    static member IsDigit(c: char) : bool =\n        c >= '0' && c <= '9'\n\n    static member IsLetter(c: char) : bool =\n        c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z'\n\n    static member IsLetterOrDigit(c: char) : bool =\n        System.Char.IsLetter c || System.Char.IsDigit c\n\n    static member IsLower(c: char) : bool =\n        c >= 'a' && c <= 'z'\n\n    static member IsUpper(c: char) : bool =\n        c >= 'A' && c <= 'Z'\n\n    [<Direct @\"$c.match(/\\s/) !== null\">]\n    static member IsWhiteSpace(c: char) = X<bool>\n\n    static member Parse(s: string) =\n        if s.Length = 1 then As<char> s else\n            failwith \"String must be exactly one character long.\"\n\n    [<Inline \"String.fromCharCode($x.charCodeAt() + $y.charCodeAt())\">]\n    static member (+) (x: char, y: char) : char = x + y\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.Name \"Util\">]\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Control.CommonExtensions, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.CommonExtensionsProxy\n\nopen WebSharper.JavaScript\n\nlet observer (h: 'T -> unit) : System.IObserver<'T> =\n    { new System.IObserver<'T> with \n        member this.OnCompleted() = ()\n        member this.OnError _ = ()\n        member this.OnNext args = h args\n    }\n\n[<Inline>]\nlet AddToObservable<'T> (event: System.IObservable<'T>) (h: 'T -> unit) =\n    event.Subscribe(observer h) |> ignore\n\n[<Inline>]\nlet SubscribeToObservable<'T> (event: System.IObservable<'T>) (h: 'T -> unit) =\n    event.Subscribe(observer h)\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen WebSharper.JavaScript\nopen System.Runtime.InteropServices\n\ntype private D = System.DateTime\ntype private K = System.DateTimeKind\ntype private TS = System.TimeSpan\ntype private DO = System.DateTimeOffset\n\n[<JavaScript>]\n[<Name \"DateUtil\">]\nmodule private DateTimeHelpers =\n    let DatePortion (d: int) =\n        let e = Date(d)\n        Date(       \n            e.GetFullYear(),\n            e.GetMonth(),\n            e.GetDate()\n        ).GetTime()\n        |> As<D>        \n\n    let TimePortion (d: int) =\n        let e = Date(d)\n        TS(\n            0,\n            e.GetHours(), \n            e.GetMinutes(), \n            e.GetSeconds(), \n            e.GetMilliseconds()\n        )        \n        |> As<TS>        \n\n    let AddYears(d: int, years) =\n        let e = Date(d)\n        Date(   \n            e.GetFullYear() + years,\n            e.GetMonth(),\n            e.GetDate(),\n            e.GetHours(),\n            e.GetMinutes(),\n            e.GetSeconds(),\n            e.GetMilliseconds()\n        ).GetTime()\n        |> As<D>        \n\n    let AddMonths(d: int, months: int) =\n        let e = Date(d)\n        Date(   \n            e.GetFullYear(),\n            e.GetMonth() + months,\n            e.GetDate(),\n            e.GetHours(),\n            e.GetMinutes(),\n            e.GetSeconds(),\n            e.GetMilliseconds()\n        ).GetTime()    \n        |> As<D>        \n\n    let TryParse (s: string) =\n        let d = Date.Parse(s)   \n        if JS.IsNaN(d) then\n            None\n        else Some d\n\n    let Parse (s: string) =\n        match TryParse s with\n        | Some d -> d\n        | _ ->\n            failwith \"Failed to parse date string.\"\n\n    [<Direct \"(new Date($d)).toLocaleDateString({}, {year: 'numeric', month: 'long', day: 'numeric', weekday: 'long'})\">]\n    let LongDate (d: obj) = X<string>\n     \n    [<Direct \"(new Date($d)).toLocaleTimeString({}, {hour: '2-digit', minute: '2-digit', hour12: false})\">]\n    let ShortTime (d: obj) = X<string>\n\n    [<Direct \"(new Date($d)).toLocaleTimeString({}, {hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false})\">]\n    let LongTime (d: obj) = X<string>\n                \n[<Proxy(typeof<System.DateTime>)>]\ntype private DateTimeProxy =\n    [<Inline \"0\">]\n    new () = {}\n\n    [<Inline \"new Date($y,$mo-1,$d).getTime()\">]\n    new (y: int, mo: int, d: int) = {}\n\n    [<Inline \"new Date($y,$mo-1,$d,$h,$m,$s).getTime()\">]\n    new (y: int, mo: int, d: int, h: int, m: int, s: int) = {}\n\n    [<Inline \"new Date($y,$mo-1,$d,$h,$m,$s,$ms).getTime()\">]\n    new (y: int, mo: int, d: int, h: int, m: int, s: int, ms: int) = {}\n    \n    static member Now\n        with [<Inline \"Date.now()\">] get() = X<D>\n\n    static member UtcNow\n        with [<Inline \"Date.now()\">] get() = X<D>\n    \n    [<Inline \"1\">]\n    member this.Kind = X<System.DateTimeKind>\n\n    member this.Date \n        with [<Inline; JavaScript>] get() : D = DateTimeHelpers.DatePortion(As this)\n\n    static member Today\n        with [<Inline; JavaScript>] get() = DateTimeProxy.Now.Date  \n\n    member this.TimeOfDay \n        with [<Inline; JavaScript>] get() = DateTimeHelpers.TimePortion(As this)\n\n    member this.Year\n        with [<Inline; JavaScript>] get() = Date(As<int> this).GetFullYear()\n\n    member this.Month \n        with [<Inline; JavaScript>] get() = Date(As<int> this).GetMonth() + 1\n\n    member this.Day \n        with [<Inline; JavaScript>] get() = Date(As<int> this).GetDate()\n\n    member this.Hour \n        with [<Inline; JavaScript>] get() = Date(As<int> this).GetHours()\n                                                  \n    member this.Minute \n        with [<Inline; JavaScript>] get() = Date(As<int> this).GetMinutes()\n    \n    member this.Second \n        with [<Inline; JavaScript>] get() = Date(As<int> this).GetSeconds()\n\n    member this.Millisecond \n        with [<Inline; JavaScript>] get() = Date(As<int> this).GetMilliseconds()\n    \n    member this.DayOfWeek \n        with [<Inline; JavaScript>] get() = As<System.DayOfWeek>(Date(As<int> this).GetDay())\n\n    member this.Ticks\n        with [<Inline \"$this * 1E4\">] get() = X<int64>\n\n    [<Inline \"$this + $t\">]\n    member this.Add(t: TS) = X<D>\n                            \n    [<Inline \"$this - $t\">]\n    member this.Subtract(t: TS) = X<D>\n\n    [<Inline \"$this - $d\">]\n    member this.Subtract(d: D) = X<TS>\n\n    [<Inline; JavaScript>]\n    member this.AddYears(years: int) : D = DateTimeHelpers.AddYears(As this, years)\n\n    [<Inline; JavaScript>]\n    member this.AddMonths(months: int) : D = DateTimeHelpers.AddMonths(As this, months)\n\n    [<Inline; JavaScript>]\n    member this.AddDays(days: float) : D =\n        this.Add(TS.FromDays days)\n\n    [<Inline; JavaScript>]\n    member this.AddHours(hours: float) : D =\n        this.Add(TS.FromHours hours)\n\n    [<Inline; JavaScript>]\n    member this.AddMinutes(minutes: float) : D =\n        this.Add (TS.FromMinutes minutes)\n\n    [<Inline; JavaScript>]\n    member this.AddSeconds(seconds: float) : D =\n        this.Add (TS.FromSeconds seconds)\n\n    [<Inline; JavaScript>]\n    member this.AddMilliseconds(msec: float) : D =\n        this.Add (TS.FromMilliseconds msec)\n\n    [<Inline; JavaScript>]\n    member this.AddTicks(ticks: int64) : D =\n        this.Add (TS.FromTicks ticks)\n\n    [<Inline \"new Date($this).toLocaleDateString()\">]\n    member this.ToShortDateString() = X<string>\n    \n    [<Inline; JavaScript>]\n    member this.ToLongDateString() = DateTimeHelpers.LongDate(this)\n    \n    [<Inline; JavaScript>]\n    member this.ToShortTimeString() = DateTimeHelpers.ShortTime(this)\n\n    [<Inline; JavaScript>]\n    member this.ToLongTimeString() = DateTimeHelpers.LongTime(this)\n\n    [<Inline; JavaScript>]\n    static member Parse(s) = As<D>(DateTimeHelpers.Parse(s))\n\n    [<Inline; JavaScript>]\n    static member TryParse(s, [<Out>] res: byref<D>) =\n        match DateTimeHelpers.TryParse s with\n        | Some d ->\n            res <- As<D> d   \n            true\n        | _ -> false    \n\n    static member MaxValue\n        with [<Inline \"8640000000000000\">] get () = X<int>\n\n    static member MinValue\n        with [<Inline \"-8640000000000000\">] get () = X<int>\n\n[<Proxy(typeof<System.DateTimeOffset>)>]\n[<Name \"DateTimeOffset\">]\ntype private DateTimeOffsetProxy(d: int, o: int) =\n\n    [<Inline>]\n    new (d: D) = DateTimeOffsetProxy(As<int> d, 0) \n\n    [<Inline>]\n    member this.DateTime = d |> As<D>\n\n//    static member Now = X<D>\n\n//    static member UtcNow = DateTimeOffsetProxy(DateTime, o: int)\n        \n    member this.ToLocalTime() =\n        DateTimeOffsetProxy(d, As<int>(Date().GetTimezoneOffset())) |> As<DO>   \n        \n    member this.ToUniversalTime() =\n        DateTimeOffsetProxy(d, 0) |> As<DO>\n\n    [<Inline>]\n    member this.UtcDateTime = this.ToUniversalTime().DateTime\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen System\nopen WebSharper.JavaScript\n\n[<Name \"WebSharper.Delegate\">]\n[<Proxy(typeof<Delegate>)>]\ntype internal DelegateProxy =\n//    member this.GetLastInvoke() =\n//        let inv = As<Delegate[]> this?``$Invokes``\n//        if As inv then inv.[inv.Length - 1] else As this\n\n    [<Inline \"$this.apply(null, $args)\">]\n    member this.DynamicInvoke(args: obj[]) = X<obj>\n\n    [<Direct \"$0.$Invokes || [$0]\">]\n    static member InvocationList(del: Delegate) = X<Delegate[]> \n    [<Inline>]\n    member this.GetInvocationList() : Delegate[] =\n        DelegateProxy.InvocationList (As this)\n    \n    static member DelegateTarget(del) =\n        if (JS.Not del) then null\n        elif (JS.In \"$Target\" del) then del?``$Target``\n        elif (JS.In \"$Invokes\" del) then \n            let inv = del?``$Invokes`` : (_ * _)[]\n            snd inv.[inv.Length - 1]\n        else null\n\n    [<Inline>]\n    member this.Target =\n        DelegateProxy.DelegateTarget this\n\n    [<Inline \"$wsruntime.CreateDelegate($0)\">]\n    static member JSCreateDelegate(invokes: Delegate[]) = X<Delegate>\n\n    [<Inline \"$wsruntime.CombineDelegates([$0, $1])\">]\n    static member Combine(a: Delegate, b: Delegate) = X<Delegate>\n\n    [<Inline \"$wsruntime.CombineDelegates($0)\">]\n    static member Combine(delegates: Delegate[]) = X<Delegate>\n\n    [<Inline \"$wsruntime.DelegateEqual($0, $1)\">]\n    static member DelegateEqual(d1: Delegate, d2: Delegate) = X<bool>\n                           \n    static member Remove(source:Delegate, value: Delegate) =\n        let sourceInv = source.GetInvocationList()\n        if value.GetInvocationList().Length > 1 then\n            failwith \"TODO: Remove multicast delegates\"\n        let resInv = [||]\n        let mutable found = false\n        for i = sourceInv.Length - 1 downto 0 do\n            let it = sourceInv.[i]\n            if not found && DelegateProxy.DelegateEqual(it, value) then\n                found <- true\n            else\n                resInv.JS.Unshift(it) |> ignore\n        DelegateProxy.JSCreateDelegate(resInv)         \n\n    static member RemoveAll(source:Delegate, value: Delegate) =\n        let sourceInv = source.GetInvocationList()\n        if value.GetInvocationList().Length > 1 then\n            failwith \"TODO: Remove multicast delegates\"\n        DelegateProxy.JSCreateDelegate(sourceInv |> Array.filter (fun i -> not (i.Equals(value))))         \n\n[<Proxy(typeof<MulticastDelegate>)>]\ntype internal MulticastDelegateProxy =\n    \n    [<Inline>]\n    member this.GetInvocationList() : Delegate[] =\n        DelegateProxy.InvocationList (As this)\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.Collections\n\nopen WebSharper\nopen WebSharper.JavaScript\nopen System.Collections\nopen System.Collections.Generic\n\ntype private KVP<'K,'V> = KeyValuePair<'K,'V>\ntype private D<'K,'V> = Dictionary<'K,'V>\n\n[<JavaScript>]\nmodule internal DictionaryUtil =\n\n    let notPresent () =\n        failwith \"The given key was not present in the dictionary.\"\n\n    let alreadyAdded () =\n        failwith \"An item with the same key has already been added.\"\n\n    let equals (c: IEqualityComparer<'T>) =\n        FuncWithArgs(fun (x, y) -> c.Equals(x, y))\n\n    [<Inline>]\n    let genEquals<'T when 'T : equality> () = \n        FuncWithArgs(fun (x :'T, y) -> x = y)\n\n    let getHashCode (c: IEqualityComparer<'T>) x =\n        c.GetHashCode x\n\nopen DictionaryUtil\nopen System.Runtime.InteropServices\n\n// not really used, a sequence enumerator is cast to this type instead\n// proxy is needed so calls against it compile\n// TODO: lazy iterating\n[<Proxy(typeof<D<_,_>.KeyCollection.Enumerator>)>]\n[<Stub>]\ntype private KeyCollectionEnumeratorProxy<'K,'V> [<JavaScript(false)>] () =\n    [<Inline \"$this.Current()\">]\n    member this.get_Current() = As<'K> 0        \n    member this.MoveNext() = false\n    member this.Dispose() = ()\n\n// not really used, a sequence enumerator is cast to this type instead\n// proxy is needed so calls against it compile\n// TODO: lazy iterating\n[<Proxy(typeof<D<_,_>.ValueCollection.Enumerator>)>]\n[<Stub>]\ntype private ValueCollectionEnumeratorProxy<'K,'V> [<JavaScript(false)>] () =\n    [<Inline \"$this.Current()\">]\n    member this.get_Current() = As<'V> 0        \n    member this.MoveNext() = false\n    member this.Dispose() = ()\n\n[<Name \"WebSharper.Collections.KeyCollection\">]\n[<Proxy(typeof<D<_,_>.KeyCollection>)>]\ntype private KeyCollectionProxy<'K,'V> (d: D<'K,'V>) =\n    member this.Count = d.Count \n\n    member this.GetEnumerator() =\n        As<D<'K,'V>.KeyCollection.Enumerator>(\n            (d |> Seq.map(fun kvp -> kvp.Key)).GetEnumerator())\n            \n    interface IEnumerable<'K> with\n        member this.GetEnumerator() = As<IEnumerator<'K>>(this.GetEnumerator())\n        member this.GetEnumerator() = As<IEnumerator>(this.GetEnumerator())\n\n[<Name \"WebSharper.Collections.ValueCollection\">]\n[<Proxy(typeof<D<_,_>.ValueCollection>)>]\ntype private ValueCollectionProxy<'K,'V> (d: D<'K,'V>) =\n    member this.Count = d.Count \n\n    member this.GetEnumerator() =\n        As<D<'K,'V>.ValueCollection.Enumerator>(\n            (d |> Seq.map(fun kvp -> kvp.Value)).GetEnumerator())\n            \n    interface IEnumerable<'V> with\n        member this.GetEnumerator() = As<IEnumerator<'V>>(this.GetEnumerator())\n        member this.GetEnumerator() = As<IEnumerator>(this.GetEnumerator())\n\n[<Proxy(typeof<D<_,_>.Enumerator>)>]\n[<Stub>]\ntype private DictionaryEnumeratorProxy<'K,'V> [<JavaScript(false)>] () =\n    [<Inline \"$this.Current()\">]\n    member this.get_Current() = As<KVP<'K,'V>> 0        \n    member this.MoveNext() = false\n    member this.Dispose() = ()\n\n/// Implements a proxy for the .NET dictionary.\n[<Name \"WebSharper.Collections.Dictionary\">]\n[<Proxy(typeof<D<_,_>>)>]\ntype internal Dictionary<'K,'V when 'K : equality>\n\n    private (init   : seq<KVP<'K,'V>>,\n             equals : FuncWithArgs<'K * 'K, bool>,\n             hash   : 'K -> int) =\n\n        let mutable count = 0\n        let mutable data  = As<Array<Array<KVP<'K, 'V>>>> [||]\n\n        let get k =\n            let h = hash k\n            let d = data.[h]\n            if As<bool> d then\n                d.Self |> Array.pick (fun (KeyValue(dk, v)) -> \n                    if equals.Call(dk, k) then Some v else None\n                ) \n            else\n                notPresent()\n\n        let set k v =\n            let h = hash k\n            let d = data.[h]\n            if As<bool> d then\n                match d.Self |> Array.tryFindIndex (fun (KeyValue(dk, _)) -> equals.Call(dk, k)) with\n                | Some i ->\n                    d.[i] <- KVP(k, v) \n                | None ->\n                    count <- count + 1\n                    d.Push(KVP(k, v)) |> ignore\n            else\n                count <- count + 1\n                data.[h] <- Array(KVP(k, v))\n                    \n        let add k v =\n            let h = hash k\n            let d = data.[h]\n            if As<bool> d then\n                if d.Self |> Array.exists (fun (KeyValue(dk, _)) -> equals.Call(dk, k)) then\n                    alreadyAdded()                    \n                count <- count + 1\n                d.Push(KVP(k, v)) |> ignore\n            else\n                count <- count + 1\n                data.[h] <- Array(KVP(k, v))\n                    \n        let remove k =\n            let h = hash k \n            let d = data.[h]\n            if As<bool> d then\n                let r = d.Self |> Array.filter (fun (KeyValue(dk, _)) -> not (equals.Call(dk, k)))\n                if r.Length < d.Length then                  \n                    count <- count - 1\n                    data.[h] <- r.JS\n                    true\n                else\n                    false\n            else\n                false\n\n        do for x in init do\n            set x.Key x.Value\n\n        new () = new Dictionary<'K,'V>([||], genEquals<'K>(), hash)\n\n        new (capacity: int) = new Dictionary<'K,'V>()\n\n        new (comparer: IEqualityComparer<'K>) =\n            new Dictionary<'K,'V>([||], equals comparer, getHashCode comparer)\n\n        new (capacity: int, comparer: IEqualityComparer<'K>) =\n            new Dictionary<'K,'V>(comparer)\n\n        new (dictionary: IDictionary<'K,'V>) =\n            new Dictionary<'K,'V>(dictionary, genEquals<'K>(), hash)\n\n        new (dictionary: IDictionary<'K,'V>, comparer: IEqualityComparer<'K>) =\n            new Dictionary<'K,'V>(\n                dictionary,\n                equals comparer,\n                getHashCode comparer\n            )\n\n        member this.Add(k: 'K, v: 'V) =\n            add k v\n\n        member this.Clear() =\n            data <- Array()\n            count <- 0\n\n        member this.ContainsKey(k: 'K) =\n            let h = hash k\n            let d = data.[h]\n            if As<bool> d then\n                d.Self |> Array.exists (fun (KeyValue(dk, _)) -> \n                    equals.Call(dk, k)\n                ) \n            else\n                false\n\n        member this.Count with [<Inline>] get () = count\n\n        member this.Item\n            with get (k: 'K) : 'V = get k\n            and set (k: 'K) (v: 'V) = set k v\n\n        member this.GetEnumerator() = As<D<'K,'V>.Enumerator> ((this :> System.Collections.IEnumerable).GetEnumerator())\n\n        interface System.Collections.IEnumerable with\n            member this.GetEnumerator() = \n                let s = JS.GetFieldValues data\n                (As<KeyValuePair<'K,'V>[][]> s |> Array.concat).GetEnumerator()\n            \n        interface IEnumerable<KeyValuePair<'K,'V>> with\n            member this.GetEnumerator() = As<IEnumerator<KeyValuePair<'K,'V>>> ((this :> System.Collections.IEnumerable).GetEnumerator())\n\n        member this.Remove(k: 'K) =\n            remove k\n\n        member this.TryGetValue(k: 'K, [<Out>] res : byref<'V>) =\n            let h = hash k\n            let d = data.[h]\n            if As<bool> d then\n                let v =\n                    d.Self |> Array.tryPick (fun (KeyValue(dk, v)) -> \n                        if equals.Call(dk, k) then Some v else None\n                    ) \n                match v with \n                | Some v -> \n                    res <- v\n                    true\n                | _ -> false\n            else\n                false\n\n        member this.Values =\n            As<D<'K,'V>.ValueCollection>(ValueCollectionProxy(As<D<'K,'V>>this))\n\n        member this.Keys =\n            As<D<'K,'V>.KeyCollection>(KeyCollectionProxy(As<D<'K,'V>>this))\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen WebSharper.JavaScript\n\n[<Name [| \"Error\" |]>]\n[<Proxy(typeof<System.Exception>)>]\ntype private ExceptionProxy =\n    [<Inline \"Error($message)\">]\n    new (message: string) = { }\n\n    [<Inline \"var e = Error($message); e.inner = $inner; return e\">]\n    new (message: string, inner: exn) = { }\n\n    [<Inline>]\n    new () = ExceptionProxy \"Exception of type 'System.Exception' was thrown.\"\n\n    member this.Message with [<Inline \"$this.message\">] get () = X<string>\n    member this.InnerException with [<Inline \"$this.inner\">] get () = X<System.Exception>\n\n[<Proxy(typeof<MatchFailureException>)>]\n[<Name \"MatchFailureException\">]\ntype private MatchFailureExceptionProxy (message: string, line: int, column: int) =\n    inherit exn(message + \" at \" + string line + \":\" + string column)\n\n[<Proxy(typeof<System.IndexOutOfRangeException>)>]\n[<Name \"IndexOutOfRangeException\">]\ntype private IndexOutOfRangeExceptionProxy(message: string) =\n    inherit exn(message)\n\n    new () = IndexOutOfRangeExceptionProxy \"Index was outside the bounds of the array.\"\n\n[<Proxy(typeof<System.OperationCanceledException>)>]\n[<Name \"OperationCanceledException\">]\ntype private OperationCanceledExceptionProxy(message: string, inner: exn, ct: CT) =\n    inherit exn(message, inner)\n\n    new (ct) = OperationCanceledExceptionProxy (\"The operation was canceled.\", null, ct)\n    \n    [<Inline>]\n    new () = OperationCanceledExceptionProxy (CT.None)\n    [<Inline>]\n    new (message) = OperationCanceledExceptionProxy (message, null, CT.None)\n    [<Inline>]\n    new (message, ct) = OperationCanceledExceptionProxy (message, null, ct)\n    [<Inline>]\n    new (message, inner) = OperationCanceledExceptionProxy (message, inner, CT.None)\n\n    [<Inline>]\n    member this.CancellationToken = ct\n\n[<Proxy(typeof<System.ArgumentException>)>]\n[<Name \"ArgumentException\">]\ntype private ArgumentExceptionProxy(message: string) =\n    inherit exn(message)\n    \n    new () = ArgumentExceptionProxy \"Value does not fall within the expected range.\"\n\n    new (argumentName: string, message: string) =\n        ArgumentExceptionProxy (message + \"\\nParameter name: \" + argumentName)\n\n[<Proxy(typeof<System.ArgumentOutOfRangeException>)>]\n[<Name \"ArgumentOutOfRangeException\">]\ntype private ArgumentOutOfRangeExceptionProxy(message: string) =\n    inherit exn(message)\n    \n    new () = ArgumentOutOfRangeExceptionProxy \"Specified argument was out of the range of valid values.\"\n\n[<Proxy(typeof<System.InvalidOperationException>)>]\n[<Name \"InvalidOperationException\">]\ntype private InvalidOperationExceptionProxy(message: string) =\n    inherit exn(message)\n    \n    new () = InvalidOperationExceptionProxy \"Operation is not valid due to the current state of the object.\"\n\n[<Proxy(typeof<System.AggregateException>)>]\n[<Name \"AggregateException\">]\ntype private AggregateExceptionProxy(message: string, innerExceptions: exn[]) =\n    inherit exn(message)\n\n    new (innerExceptions: exn[]) = AggregateExceptionProxy(\"One or more errors occurred.\", innerExceptions)\n\n    new (innerExceptions: seq<exn>) = AggregateExceptionProxy(\"One or more errors occurred.\", Array.ofSeq innerExceptions)\n\n    new (message, innerExceptions: seq<exn>) = AggregateExceptionProxy(message, Array.ofSeq innerExceptions)\n\n    new (message, innerException: exn) = AggregateExceptionProxy(message, [| innerException |])\n\n    [<Inline>]\n    member this.InnerExceptions \n        with get() = As<System.Collections.ObjectModel.ReadOnlyCollection<exn>> innerExceptions\n\n[<Proxy(typeof<System.TimeoutException>)>]\n[<Name \"TimeoutException\">]\ntype private TimeoutExceptionProxy(message: string) =\n    inherit exn(message)\n    \n    new () = TimeoutExceptionProxy \"The operation has timed out.\"\n\n[<Proxy(typeof<System.FormatException>)>]\n[<Name \"FormatException\">]\ntype private FormatException(message: string) =\n    inherit exn(message)\n\n    new () = FormatException \"One of the identified items was in an invalid format.\"\n\n[<Proxy(typeof<System.OverflowException>)>]\n[<Name \"OverflowException\">]\ntype private OverflowException(message: string) =\n    inherit exn(message)\n\n    new () = OverflowException \"Arithmetic operation resulted in an overflow.\"\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Core.ExtraTopLevelOperators, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.ExtraTopLevelOperatorsProxy\n\nopen WebSharper.JavaScript\nmodule M = WebSharper.Macro\n\n[<Inline \"null\">]\nlet DefaultAsyncBuilder : Control.AsyncBuilder =\n    As (AsyncBuilderProxy())\n\n[<Name \"WebSharper.Arrays.create2D\" >]\nlet CreateArray2D (rows : seq<#seq<'T>>) =\n    let arr = rows |> Seq.map (Array.ofSeq) |> Array.ofSeq |> As<'T[,]>\n    arr?dims <- 2\n    arr\n\n[<Inline \"+$0\">]\nlet ToDouble<'T> (x: 'T) : double = X\n\n[<Inline \"$f(function(x){return x;})\">]\nlet PrintFormatToString (f: Printf.StringFormat<'T>) = X<'T>\n\n[<Inline; JavaScript>]\nlet PrintFormatToStringThen k f = Printf.ksprintf k f \n\n[<Inline; JavaScript>]\nlet PrintFormatLine f = Printf.printfn f \n\n[<Inline; JavaScript>]\nlet PrintFormatToStringThenFail f = Printf.failwithf f \n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.Collections\n\nopen System.Collections\nopen System.Collections.Generic\n\nopen WebSharper\nopen WebSharper.JavaScript\n\n[<AutoOpen>]\nmodule private HashSetUtil =\n    [<Direct \"var r=[]; for(var k in $o) { r.push.apply(r, $o[k]) }; return r\">]\n    let concat (o: Array<Array<'T>>) = X<Array<'T>>\n    \nopen DictionaryUtil\n\n// not really used, an array enumerator is cast to this type instead\n// proxy is needed so calls against it compile\n// TODO: lazy iterating\n[<Proxy(typeof<HashSet<_>.Enumerator>)>]\n[<Stub>]\ntype private HashSetEnumeratorProxy<'T> [<JavaScript(false)>] () =\n    [<Inline \"$this.Current()\">]\n    member this.get_Current() = As<'T> 0        \n    member this.MoveNext() = false\n    member this.Dispose() = ()\n\n[<Proxy(typeof<HashSet<_>>)>]\n[<Name \"HashSet\">]\ntype internal HashSetProxy<'T when 'T : equality>\n\n    private (init   : seq<'T>,\n             equals : FuncWithArgs<'T * 'T, bool>,\n             hash   : 'T -> int) =\n\n        let mutable data  = Array<Array<'T>>()\n        let mutable count = 0\n\n        let arrContains (item: 'T) (arr: Array<'T>)  =\n            let mutable c = true\n            let mutable i = 0\n            let l = arr.Length\n            while c && i < l do\n                if equals.Call(arr.[i], item) then\n                    c <- false\n                else\n                    i <- i + 1\n            not c\n\n        let arrRemove (item: 'T) (arr: Array<'T>)  =\n            let mutable c = true\n            let mutable i = 0\n            let l = arr.Length\n            while c && i < l do\n                if equals.Call(arr.[i], item) then\n                    arr.Splice(i, 1) |> ignore\n                    c <- false\n                else\n                    i <- i + 1\n            not c\n\n        let add (item: 'T) =\n            let h = hash item\n            let arr = data.[h]\n            if arr ==. null then\n                data.[h] <- As [| item |]\n                count <- count + 1\n                true\n            else\n                if arrContains item arr then false else    \n                    arr.Push item |> ignore\n                    count <- count + 1\n                    true\n\n        do for x in init do add x |> ignore\n\n        new () = HashSetProxy<'T>(Seq.empty, genEquals<'T>(), hash)\n\n        new (init: seq<'T>) = new HashSetProxy<'T>(init, genEquals<'T>(), hash)\n\n        new (comparer: IEqualityComparer<'T>) =\n            new HashSetProxy<'T>(Seq.empty, equals comparer, getHashCode comparer)\n\n        new (init: seq<'T>, comparer: IEqualityComparer<'T>) =\n            new HashSetProxy<'T>(init, equals comparer, getHashCode comparer)\n\n        member this.Add(item: 'T) = add item\n\n        member this.Clear() =\n            data <- Array()\n            count <- 0\n\n        member x.Contains(item: 'T) =\n            let arr = data.[hash item]\n            if arr ==. null then false else arrContains item arr\n\n        member x.CopyTo(arr: 'T[]) =\n            let mutable i = 0\n            let all = concat data \n            for i = 0 to all.Length - 1 do \n                arr.[i] <- all.[i]\n\n        member x.Count = count\n\n        member x.ExceptWith(xs: seq<'T>) =\n            for item in xs do\n                x.Remove(item) |> ignore\n\n        [<Inline>]\n        member this.GetEnumerator() =\n           As<HashSet<'T>.Enumerator>((As<seq<'T>>(concat data)).GetEnumerator())\n\n        interface IEnumerable with\n            member this.GetEnumerator() = this.GetEnumerator() :> _\n        \n        interface IEnumerable<'T> with\n            member this.GetEnumerator() = this.GetEnumerator() :> _\n\n        // TODO: optimize methods by checking if other collection\n        // is a HashSet with the same IEqualityComparer\n        \n        member x.IntersectWith(xs: seq<'T>) =\n            let other = HashSetProxy(xs, equals, hash) \n            let all = concat data\n            for i = 0 to all.Length - 1 do\n                let item = all.[i]\n                if other.Contains(item) |> not then\n                    x.Remove(item) |> ignore\n\n        member x.IsProperSubsetOf(xs: seq<'T>) =\n            let other = xs |> Array.ofSeq\n            count < other.Length && x.IsSubsetOf(other)\n\n        member x.IsProperSupersetOf(xs: seq<'T>) =\n            let other = xs |> Array.ofSeq\n            count > other.Length && x.IsSupersetOf(other)\n\n        member x.IsSubsetOf(xs: seq<'T>) =\n            let other = HashSetProxy(xs, equals, hash)\n            As<_[]>(concat data) |> Array.forall other.Contains\n\n        member x.IsSupersetOf(xs: seq<'T>) =\n            xs |> Seq.forall x.Contains\n\n        member x.Overlaps(xs: seq<'T>) =\n            xs |> Seq.exists x.Contains\n\n        member x.Remove(item: 'T) =\n            let h = hash item\n            let arr = data.[h]\n            if arr ==. null then false else\n                if arrRemove item arr then\n                    count <- count - 1\n                    true\n                else false\n\n        member x.RemoveWhere(cond: System.Predicate<'T>) =\n            let all = concat data\n            let mutable res = 0\n            for i = 0 to all.Length - 1 do\n                let item = all.[i]\n                if cond.Invoke item then\n                    if x.Remove(item) then\n                        res <- res + 1\n            res\n\n        member x.SetEquals(xs: seq<'T>) =\n            let other = HashSetProxy(xs, equals, hash)\n            x.Count = other.Count && x.IsSupersetOf(other)\n\n        member x.SymmetricExceptWith(xs: seq<'T>) =\n            for item in xs do\n                if x.Contains item then\n                    x.Remove(item) |> ignore\n                else\n                    x.Add(item) |> ignore\n\n        member x.UnionWith(xs: seq<'T>) =\n            for item in xs do\n                x.Add(item) |> ignore\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen WebSharper.JavaScript\n\n[<Proxy(typeof<System.IComparable>)>]\ntype private IComparableProxy =\n    [<Name \"CompareTo0\">]\n    abstract CompareTo : obj -> int\n\n[<Proxy(typeof<System.IComparable<_>>)>]\ntype private IComparableProxy<'T> =\n    [<Name \"CompareTo\">]\n    abstract CompareTo : 'T -> int\n\n[<Proxy(typeof<System.Collections.IEqualityComparer>)>]\ntype private IEqualityComparerProxy =\n    [<Name \"CEquals0\">]\n    abstract Equals : obj * obj -> bool \n    [<Name \"CGetHashCode0\">]\n    abstract GetHashCode : obj -> int\n\n[<Proxy(typeof<System.Collections.Generic.IEqualityComparer<_>>)>]\ntype private IEqualityComparerProxy<'T> =\n    [<Name \"CEquals\">]\n    abstract Equals : 'T * 'T -> bool \n    [<Name \"CGetHashCode\">]\n    abstract GetHashCode : 'T -> int\n\n[<Proxy(typeof<System.Collections.Generic.EqualityComparer<_>>)>]\n[<Name \"WebSharper.Collections.EqualityComparer\">]\n[<AbstractClass>]\ntype private EqualityComparerProxy<'T>() =\n    abstract Equals : 'T * 'T -> bool \n    abstract GetHashCode : 'T -> int\n    interface System.Collections.Generic.IEqualityComparer<'T> with\n        member this.Equals(x, y) = this.Equals(x, y)\n        member this.GetHashCode(x) = this.GetHashCode(x)\n    interface System.Collections.IEqualityComparer with\n        member this.Equals(x, y) = this.Equals(As x, As y)\n        member this.GetHashCode(x) = this.GetHashCode(As x)\n    [<Macro(typeof<Macro.EqualityComparer>)>]\n    static member Default = X<System.Collections.Generic.EqualityComparer<'T>>\n\n[<Proxy(typeof<System.Collections.IComparer>)>]\ntype private IComparerProxy =\n    [<Name \"Compare0\">]\n    abstract Compare : obj * obj -> int\n\n[<Proxy(typeof<System.Collections.Generic.IComparer<_>>)>]\ntype private IComparerProxy<'T> =\n    [<Name \"Compare\">]\n    abstract Compare : 'T * 'T -> int\n\n[<Proxy(typeof<System.Collections.Generic.Comparer<_>>)>]\n[<Name \"WebSharper.Collections.Comparer\">]\n[<AbstractClass>]\ntype private ComparerProxy<'T>() =\n    abstract Compare : 'T * 'T -> int\n    interface System.Collections.Generic.IComparer<'T> with\n        member this.Compare(x, y) = this.Compare(x, y)\n    interface System.Collections.IComparer with\n        member this.Compare(x, y) = this.Compare(As x, As y)\n    [<Macro(typeof<Macro.Comparer>)>]\n    static member Default = X<System.Collections.Generic.Comparer<'T>>\n\n[<Proxy(typeof<System.IEquatable<_>>)>]\ntype private IEquatableProxy<'T> =\n    [<Name \"EEquals\">]\n    abstract Equals : 'T -> bool\n\n[<Proxy(typeof<System.Collections.IStructuralEquatable>)>]\ntype private IStructuralEquatableProxy =\n    [<Name \"SEquals\">]\n    abstract Equals : obj * System.Collections.IEqualityComparer -> bool \n    [<Name \"SGetHashCode\">]\n    abstract GetHashCode : System.Collections.IEqualityComparer -> int\n\n[<Proxy(typeof<System.Collections.IStructuralComparable>)>]\ntype private IStructuralComparableProxy =\n    [<Name \"SCompareTo\">]\n    abstract CompareTo : obj * System.Collections.IComparer -> int \n\n[<Proxy(typeof<System.IDisposable>)>]\ntype private IDisposableProxy =\n    [<Name \"Dispose\">]\n    abstract member Dispose : unit -> unit\n\n[<Proxy(typeof<System.Collections.IEnumerable>)>]  \ntype private IEnumerableProxy =\n\n    [<Name \"GetEnumerator0\">]\n    abstract GetEnumerator : unit -> System.Collections.IEnumerator\n\n[<Proxy(typeof<seq<_>>)>]  \ntype private IEnumerableProxy<'T> =\n    inherit System.Collections.IEnumerable \n    \n    [<Name \"GetEnumerator\">]\n    abstract GetEnumerator : unit -> System.Collections.Generic.IEnumerator<'T>\n    \n[<Proxy(typeof<System.Collections.IEnumerator>)>]\n[<Name \"WebSharper.IEnumerator\">]\ntype private IEnumeratorProxy =\n    [<Name \"Current0\">]\n    abstract member Current  : obj\n    [<Name \"MoveNext\">]\n    abstract member MoveNext : unit -> bool\n    [<Name \"Reset\">]\n    abstract member Reset    : unit -> unit\n\n[<Proxy(typeof<System.Collections.Generic.IEnumerator<_>>)>]\n[<Name \"WebSharper.IEnumerator1\">]\ntype private IEnumeratorProxy<'T> =\n    [<Name \"Current\">]\n    abstract member Current : 'T\n\n[<Proxy(typeof<System.IObservable<_>>)>]\ntype private IObservableProxy<'T> =\n    [<Name \"Subscribe\">]\n    abstract member Subscribe : System.IObserver<'T> -> System.IDisposable\n\n[<Proxy(typeof<System.IObserver<_>>)>]\ntype private IObserverProxy<'T> =\n    [<Name \"OnCompleted\">]\n    abstract member OnCompleted : unit -> unit\n    [<Name \"OnError\">]\n    abstract member OnError : exn -> unit\n    [<Name \"OnNext\">]\n    abstract member OnNext : 'T -> unit\n\n[<Proxy(typeof<IDelegateEvent<_>>)>]\ntype private IDelegateEventProxy<'D> =\n    [<Name \"AddHandler\">]\n    abstract AddHandler : 'D -> unit\n    [<Name \"RemoveHandler\">]\n    abstract RemoveHandler : 'D -> unit\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.Name \"Lazy\">]\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Control.LazyExtensions, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.LazyExtensionsProxy\n\nopen WebSharper.JavaScript\n\n[<JavaScript; Prototype false>]\ntype LazyRecord<'T> =\n    {\n        [<Name \"c\">] mutable created : bool\n        [<Name \"v\">] mutable evalOrVal : obj\n        [<Name \"f\">] mutable force : unit -> 'T\n    }\n\nlet cachedLazy<'T> () =\n    JS.This.evalOrVal\n\nlet forceLazy<'T> () =\n    let v = (As JS.This.evalOrVal)()\n    JS.This.created <- true\n    JS.This.evalOrVal <- v\n    JS.This.force <- As cachedLazy\n    v\n\nlet Create (f: unit -> 'T) : Lazy<'T> =\n    As {\n        created = false\n        evalOrVal = f\n        force = As forceLazy\n    }\n\nlet CreateFromValue (v: 'T) : Lazy<'T> =\n    As {\n        created = true\n        evalOrVal = v\n        force = As cachedLazy\n    }\n\nlet Force (x: Lazy<'T>) : 'T =\n    As<LazyRecord<'T>>(x).force()\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen WebSharper.JavaScript\n\n[<Proxy(typeof<list<_>>)>]\n[<Name \"WebSharper.List.T\">]\n[<DefaultAugmentation(false)>]\ntype private ListProxy<'T> =\n    | Empty\n    | Cons of Head: 'T * Tail: List<'T>\n\n    [<Inline; Pure>]\n    static member Cons(head: 'T, tail: list<'T>) = head :: tail\n\n    [<Inline; Pure>]\n    static member Empty : list<'T> = []\n\n    member this.Head with [<Inline>] get () = List.head (As this) : 'T\n    member this.Tail with [<Inline>] get () = List.tail (As this) : list<'T>\n    member this.IsEmpty with [<Inline \"$this.$ == 0\">] get () = X<bool>\n\n    member this.Length with get () = List.length (As this)\n\n    member this.Item with get (x: int) : 'T = List.nth (As this) x\n\n    interface System.Collections.IEnumerable with\n        member this.GetEnumerator() = (this :> _ seq).GetEnumerator() :> _\n\n    interface seq<'T> with\n        member this.GetEnumerator() =\n            let data = As<list<'T>> this\n            Enumerator.New data (fun e ->\n                match e.State with\n                | x :: xs ->\n                    e.Current <- x\n                    e.State <- xs\n                    true\n                | [] ->\n                    false)\n\n    member this.GetSlice(start, finish) : list<'T> =\n        match start, finish with\n        | None, None -> As this\n        | Some i, None -> As this |> CollectionInternals.ListSkip i\n        | None, Some j -> As this |> Seq.take (j + 1) |> List.ofSeq  \n        | Some i, Some j -> As this |> CollectionInternals.ListSkip i |> Seq.take (j - i + 1) |> List.ofSeq        \n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.Name \"List\">]\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Collections.ListModule, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.ListModuleProxy\n\nopen WebSharper.JavaScript\nopen WebSharper.CollectionInternals\n\nlet badLengths() =\n    failwith \"The lists have different lengths.\"\n\nlet listEmpty() =\n    failwith \"The input list was empty.\"\n\n[<Inline \"$l.$0\">]\nlet unsafeHead (l: list<'T>) = X<'T> \n\n[<Inline \"$l.$1\">]\nlet unsafeTail (l: list<'T>) = X<list<'T>> \n\n[<Inline>]\nlet setValue (l: list<'T>) (v: 'T) =\n    JS.Set l \"$0\" v\n\n[<Inline>]\nlet setTail (l: list<'T>) (t: list<'T>) =\n    JS.Set l \"$1\" t\n\n[<Inline \"new WebSharper.List.T({$: 1})\"; Pure>]\nlet freshEmptyList() = X<list<'T>>\n\n[<Inline>]\nlet freshTail (l: list<'T>) =\n    let t = freshEmptyList()\n    setTail l t\n    t\n\n[<Inline \"$l.$ == 1\">]\nlet notEmpty (l: list<_>) = X<bool>\n\n[<Name \"allPairs\">]\nlet AllPairs (l1: list<_>) (l2: list<_>) =\n    let arr1 = Array.ofList l1\n    let arr2 = Array.ofList l2\n    let res = Array.allPairs arr1 arr2\n    List.ofArray res\n\n[<Name \"append\">]\nlet Append (x: list<'T>) (y: list<'T>) = \n    if List.isEmpty x then y\n    elif List.isEmpty y then x else\n    let res = freshEmptyList()\n    let mutable r = res\n    let mutable l = x\n    let mutable go = true\n    while go do\n        setValue r (unsafeHead l)\n        l <- unsafeTail l\n        if List.isEmpty l then\n            go <- false\n        else\n            r <- freshTail r\n    setTail r y |> ignore\n    res\n\n[<Inline>]\nlet inline Average (l: list<_>) = Seq.average l\n\n[<Inline>]\nlet inline AverageBy f (l: list<_>) = Seq.averageBy f l\n\n[<Name \"choose\">]\nlet Choose f (l: list<_>) = List.ofSeq (Seq.choose f l)\n\n[<Name \"collect\">]\nlet Collect (f: _ -> list<_>) (l: list<_>) = List.ofSeq (Seq.collect f l)\n\n[<Name \"concat\">]\nlet Concat (s: seq<list<_>>) = List.ofSeq (Seq.concat s)\n\n[<Inline>]\nlet Empty<'T> : list<'T> = []\n\n[<Name \"exists\">]\nlet Exists<'T> (p: 'T -> bool) (x: list<'T>) =\n    let mutable e = false\n    let mutable l = x\n    while not e && notEmpty l do\n        e <- p (unsafeHead l)\n        l <- unsafeTail l\n    e\n\n[<Name \"exists2\">]\nlet Exists2<'T1,'T2> (p : 'T1 -> 'T2 -> bool)\n                        (x1: list<'T1>)\n                        (x2: list<'T2>) =\n    let mutable e = false\n    let mutable l1 = x1\n    let mutable l2 = x2\n    while not e && notEmpty l1 && notEmpty l2 do\n        e <- p (unsafeHead l1) (unsafeHead l2)\n        l1 <- unsafeTail l1\n        l2 <- unsafeTail l2\n    if not e && (notEmpty l1 || notEmpty l2) then\n        badLengths()\n    e\n\n[<Name \"filter\">]\nlet Filter<'T> (p: 'T -> bool) (l: list<'T>) =\n    List.ofSeq (Seq.filter p l)\n\n[<Inline>]\nlet Find p (l: list<_>) = Seq.find p l\n\n[<Inline>]\nlet FindIndex p (l: list<_>) = Seq.findIndex p l\n\n[<Inline>]\nlet Fold<'T,'S> (f: 'S -> 'T -> 'S) (s: 'S) (l: list<'T>) : 'S =\n    Seq.fold f s l\n\n[<Name \"fold2\">]\nlet Fold2<'T1,'T2,'S> (f: 'S -> 'T1 -> 'T2 -> 'S)\n                        (s: 'S)\n                        (l1: list<'T1>)\n                        (l2: list<'T2>) : 'S =\n    Array.fold2 f s (Array.ofList l1) (Array.ofList l2)\n\n[<Name \"foldBack\">]\nlet FoldBack f (l: list<_>) s =\n    Array.foldBack f (Array.ofList l) s\n\n[<Name \"foldBack2\">]\nlet FoldBack2 f (l1: list<_>) (l2: list<_>) s =\n    Array.foldBack2 f (Array.ofList l1) (Array.ofList l2) s\n\n[<Name \"forAll\">]\nlet ForAll p (x: list<_>) =\n    let mutable a = true\n    let mutable l = x\n    while a && notEmpty l do\n        a <- p (unsafeHead l)\n        l <- unsafeTail l\n    a\n\n[<Name \"forall2\">]\nlet ForAll2 p (x1: list<_>) (x2: list<_>) =\n    let mutable a = true\n    let mutable l1 = x1\n    let mutable l2 = x2\n    while a && notEmpty l1 && notEmpty l2 do\n        a <- p (unsafeHead l1) (unsafeHead l2)\n        l1 <- unsafeTail l1\n        l2 <- unsafeTail l2\n    if a && (notEmpty l1 || notEmpty l2) then\n        badLengths()\n    a\n\n[<Name \"head\">]\nlet Head (l: list<'T>) =\n    match l with \n    | h :: _ -> h\n    | _ -> listEmpty()\n\n[<Name \"init\">]\nlet Initialize s f = List.ofArray (Array.init s f)\n\n[<Inline \"$l.$ == 0\">]\nlet IsEmpty (l: list<_>) = X<bool>\n\n[<Name \"iter\">]\nlet Iterate f (l: list<_>) =\n    let mutable r = l\n    while notEmpty r do\n        f r.Head\n        r <- r.Tail\n\n[<Name \"iter2\">]\nlet Iterate2 f (l1: list<_>) (l2: list<_>) =\n    let mutable r1 = l1\n    let mutable r2 = l2\n    while notEmpty r1 do\n        if List.isEmpty r2 then\n            badLengths()\n        f r1.Head r2.Head\n        r1 <- r1.Tail\n        r2 <- r2.Tail\n    if notEmpty r2 then\n        badLengths()\n\n[<Name \"iteri\">]\nlet IterateIndexed f (l: list<_>) =\n    let mutable r = l\n    let mutable i = 0\n    while notEmpty r do\n        f i r.Head\n        r <- r.Tail\n        i <- i + 1\n\n[<Name \"iteri2\">]\nlet IterateIndexed2 f (l1: list<_>) (l2: list<_>) =\n    let mutable r1 = l1\n    let mutable r2 = l2\n    let mutable i = 0\n    while notEmpty r1 do\n        if List.isEmpty r2 then\n            badLengths()\n        f i r1.Head r2.Head\n        r1 <- r1.Tail\n        r2 <- r2.Tail\n        i <- i + 1\n    if notEmpty r2 then\n        badLengths()\n\n[<Name \"length\">]\nlet Length (l: list<_>) =\n    let mutable r = l\n    let mutable i = 0\n    while notEmpty r do\n        r <- r.Tail\n        i <- i + 1\n    i\n\n[<Name \"map\">]\nlet Map (f: 'T1 -> 'T2) (x: list<'T1>) = \n    if List.isEmpty x then As x else\n    let res = freshEmptyList()\n    let mutable r = res\n    let mutable l = x\n    let mutable go = true\n    while go do\n        setValue r (f (unsafeHead l))\n        l <- unsafeTail l\n        if List.isEmpty l then\n            go <- false\n        else\n            r <- freshTail r\n    setTail r []\n    res\n\n[<Name \"map2\">]\nlet Map2 (f: 'T1 -> 'T2 -> 'T3) (x1: list<'T1>) (x2: list<'T2>) =\n    let mutable go = notEmpty x1 && notEmpty x2\n    if not go then \n        if notEmpty x1 || notEmpty x2 then\n            badLengths()\n        else As x1\n    else\n    let res = freshEmptyList()\n    let mutable r = res\n    let mutable l1 = x1\n    let mutable l2 = x2\n    while go do\n        setValue r (f (unsafeHead l1) (unsafeHead l2))\n        l1 <- unsafeTail l1\n        l2 <- unsafeTail l2\n        if notEmpty l1 && notEmpty l2 then\n            r <- freshTail r\n        else \n            go <- false\n    if notEmpty l1 || notEmpty l2 then\n        badLengths()\n    setTail r []\n    res\n\n[<Name \"map3\">]\nlet Map3 (f: 'T1 -> 'T2 -> 'T3 -> 'T4) (x1: list<'T1>) (x2: list<'T2>) (x3: list<'T3>) =\n    let mutable go = notEmpty x1 && notEmpty x2 && notEmpty x3\n    if not go then \n        if notEmpty x1 || notEmpty x2 || notEmpty x3 then\n            badLengths()\n        else As x1\n    else\n    let res = freshEmptyList()\n    let mutable r = res\n    let mutable l1 = x1\n    let mutable l2 = x2\n    let mutable l3 = x3\n    while go do\n        setValue r (f (unsafeHead l1) (unsafeHead l2) (unsafeHead l3))\n        l1 <- unsafeTail l1\n        l2 <- unsafeTail l2\n        l3 <- unsafeTail l3\n        if notEmpty l1 && notEmpty l2 && notEmpty l3 then\n            r <- freshTail r\n        else \n            go <- false\n    if notEmpty l1 || notEmpty l2 || notEmpty l3 then\n        badLengths()\n    setTail r []\n    res\n\n[<Name \"mapi\">]\nlet MapIndexed (f: int -> 'T1 -> 'T2) (x: list<'T1>) =\n    if List.isEmpty x then As x else\n    let res = freshEmptyList()\n    let mutable r = res\n    let mutable l = x\n    let mutable i = 0\n    let mutable go = true\n    while go do\n        setValue r (f i (unsafeHead l))\n        l <- unsafeTail l\n        if List.isEmpty l then \n            go <- false\n        else\n            r <- freshTail r\n            i <- i + 1\n    setTail r []\n    res\n\n[<Name \"mapi2\">]\nlet MapIndexed2 (f: int -> 'T1 -> 'T2 -> 'T3) (x1: list<'T1>) (x2: list<'T2>) =\n    let mutable go = notEmpty x1 && notEmpty x2\n    if not go then \n        if notEmpty x1 || notEmpty x2 then\n            badLengths()\n        else As x1\n    else\n    let res = freshEmptyList()\n    let mutable r = res\n    let mutable l1 = x1\n    let mutable l2 = x2\n    let mutable i = 0\n    while go do\n        setValue r (f i (unsafeHead l1) (unsafeHead l2))\n        l1 <- unsafeTail l1\n        l2 <- unsafeTail l2\n        if notEmpty l1 && notEmpty l2 then\n            r <- freshTail r\n            i <- i + 1\n        else \n            go <- false\n    if notEmpty l1 || notEmpty l2 then\n        badLengths()\n    setTail r []\n    res\n\n[<Name \"max\">]\nlet Max (l: list<_>) = Seq.reduce max l\n\n[<Name \"maxBy\">]\nlet MaxBy f (l: list<_>) =\n    Seq.reduce (fun x y -> if f x > f y then x else y) l\n\n[<Name \"min\">]\nlet Min (l: list<_>) = Seq.reduce min l\n\n[<Name \"minBy\">]\nlet MinBy f (l: list<_>) =\n    Seq.reduce (fun x y -> if f x < f y then x else y) l\n\n[<Inline>]\nlet Get (l: list<_>) ix = Seq.nth ix l\n\n[<Inline>]\nlet Item ix (l: list<_>) = Seq.nth ix l\n\n[<Name \"ofArray\">]\nlet OfArray<'T> (arr: 'T []) =\n    let mutable r = []\n    for i = arr.Length - 1 downto 0 do\n        r <- arr.[i] :: r\n    r\n\n[<Name \"ofSeq\">]\nlet OfSeq (s: seq<'T>) =\n    if s :? _ list then\n        As<'T list> s\n    elif s :? System.Array then\n        List.ofArray (As<'T[]> s)\n    else\n        use e = Enumerator.Get s\n        let mutable go = e.MoveNext()\n        if not go then [] else\n        let res = freshEmptyList()\n        let mutable r = res\n        while go do\n            setValue r e.Current\n            if e.MoveNext() then\n                r <- freshTail r\n            else    \n                go <- false\n        setTail r []\n        res\n\n[<Name \"partition\">]\nlet Partition p (l: list<_>) =\n    let (a, b) = Array.partition p (Array.ofList l)\n    (List.ofArray a, List.ofArray b)\n\n[<Name \"permute\">]\nlet Permute f (l: list<_>) =\n    List.ofArray (Array.permute f (Array.ofList l))\n\n[<Inline>]\nlet Pick f (l: list<_>) = Seq.pick f l\n\n[<Inline>]\nlet Reduce (f: 'T -> 'T -> 'T) (list: list<'T>) : 'T =\n    Seq.reduce f list\n\n[<Name \"reduceBack\">]\nlet ReduceBack f (l: list<_>) =\n    Array.reduceBack f (Array.ofList l)\n\n[<Name \"replicate\">]\nlet Replicate size value =\n    List.ofArray (Array.create size value)\n\n[<Name \"rev\">]\nlet Reverse (l: list<'T>) =\n    let mutable res = []\n    let mutable r = l\n    while notEmpty r do\n        res <- unsafeHead r :: res\n        r <- unsafeTail r\n    res\n\n[<Name \"scan\">]\nlet Scan<'T,'S> (f: 'S -> 'T -> 'S) (s: 'S) (l: list<'T>) : list<'S> =\n    List.ofSeq (Seq.scan f s l)\n\n[<Name \"scanBack\">]\nlet ScanBack f (l: list<_>) s =\n    List.ofArray (Array.scanBack f (Array.ofList l) s)\n\n[<Name \"sort\">]\nlet Sort (l: list<_>) =\n    let a = Array.ofList l\n    Array.sortInPlace a\n    List.ofArray a\n\n[<Name \"sortBy\">]\nlet SortBy f (l: list<_>) =\n    List.sortWith (fun x y -> compare (f x) (f y)) l\n\n[<Name \"sortByDescending\">]\nlet SortByDescending f (l: list<_>) =\n    List.sortWith (fun x y -> - compare (f x) (f y)) l\n\n[<Name \"sortDescending\">]\nlet SortDescending (l: list<_>) =\n    let a = Array.ofList l\n    ArraySortInPlaceByDescending id a\n    List.ofArray a\n\n[<Name \"sortWith\">]\nlet SortWith f (l: list<_>) =\n    let a = Array.ofList l\n    Array.sortInPlaceWith f a\n    List.ofArray a\n\n[<Inline>]\nlet inline Sum (l: list<'T>) : 'T = Seq.sum l\n\n[<Inline>]\nlet inline SumBy (f: 'T -> 'U) (l: list<'T>) : 'U = Seq.sumBy f l\n\n[<Name \"tail\">]\nlet Tail (l: list<'T>) = \n    match l with \n    | _ :: t -> t\n    | _ -> listEmpty()\n\n[<Inline>]\nlet ToArray (l: list<_>) = Array.ofList l\n\n[<Inline \"$x\">]\nlet ToSeq<'T> (x: list<'T>) : seq<'T> = x :> _\n\n[<Inline>]\nlet TryFind p (l: list<_>) = Seq.tryFind p l\n\n[<Inline>]\nlet TryFindIndex p (l: list<_>) = Seq.tryFindIndex p l\n\n[<Inline>]\nlet TryPick p (l: list<_>) = Seq.tryPick p l\n\n[<Name \"unzip\">]\nlet Unzip (l: list<_>) =\n    let x = System.Collections.Generic.Queue<_>()\n    let y = System.Collections.Generic.Queue<_>()\n    for (a, b) in l do\n        x.Enqueue a\n        y.Enqueue b\n    (List.ofArray (x.ToArray()), List.ofArray (y.ToArray()))\n\n[<Name \"unzip3\">]\nlet Unzip3 (l: list<_>) =\n    let x = System.Collections.Generic.Queue<_>()\n    let y = System.Collections.Generic.Queue<_>()\n    let z = System.Collections.Generic.Queue<_>()\n    for (a, b, c) in l do\n        x.Enqueue a\n        y.Enqueue b\n        z.Enqueue c\n    (\n        List.ofArray (x.ToArray()),\n        List.ofArray (y.ToArray()),\n        List.ofArray (z.ToArray())\n    )\n\n[<Name \"zip\">]\nlet Zip (l1: list<_>) (l2: list<_>) =\n    List.map2 (fun x y -> x, y) l1 l2\n\n[<Name \"zip3\">]\nlet Zip3 (l1: list<_>) (l2: list<_>) (l3: list<_>) =\n    Map3 (fun x y z -> (x, y, z)) l1 l2 l3\n\n[<Name \"chunkBySize\">]\nlet ChunkBySize size list =\n    SeqChunkBySize size (List.toSeq list)\n    |> Seq.toList\n    |> List.map Array.toList\n\n[<Name \"compareWith\">]\nlet CompareWith  (f: 'T -> 'T -> int) (l1: list<'T>) (l2: list<'T>) : int =\n    Seq.compareWith f (List.toSeq l1) (List.toSeq l2)\n\n[<Name \"countBy\">]\nlet CountBy (f: 'T -> 'K) (l: list<'T>) : list<'K * int> =\n    ArrayCountBy f (List.toArray l)\n    |> Array.toList\n\n[<Name \"distinct\">]\nlet Distinct<'T when 'T : equality> (l: list<'T>) : list<'T> =\n    Seq.distinct (List.toSeq l)\n    |> Seq.toList\n\n[<Name \"distinctBy\">]\nlet DistinctBy<'T,'K when 'K : equality>\n        (f: 'T -> 'K) (l: list<'T>) : list<'T> =\n    Seq.distinctBy f (List.toSeq l)\n    |> Seq.toList\n\n[<Name \"splitInto\">]\nlet SplitInto count (list: list<'T>) =\n    ArraySplitInto count (List.toArray list)\n    |> Array.toList\n    |> List.map Array.toList\n\n[<Name \"except\">]\nlet Except (itemsToExclude: seq<'T>) (l: list<'T>) =\n    SeqExcept itemsToExclude l\n    |> Seq.toList\n\n[<Name \"tryFindBack\">]\nlet TryFindBack ok (l: list<_>) =\n    ArrayTryFindBack ok (Array.ofList l)\n\n[<Name \"findBack\">]\nlet FindBack p (s: list<_>) =\n    match TryFindBack p s with\n    | Some x -> x\n    | None   -> failwith \"KeyNotFoundException\"\n\n[<Inline>]\nlet TryFindIndexBack ok (l: list<_>) =\n    ArrayTryFindIndexBack ok (Array.ofList l) \n\n[<Name \"findIndexBack\">]\nlet FindIndexBack p (s: list<_>) =\n    match TryFindIndexBack p s with\n    | Some x -> x\n    | None   -> failwith \"KeyNotFoundException\"\n\n[<Name \"groupBy\">]\nlet GroupBy (f: 'T -> 'K when 'K : equality)\n            (l: list<'T>) : list<'K * list<'T>> =\n    let arr = ArrayGroupBy f (List.toArray l)\n    arr |> mapInPlace (fun (k, s) -> (k, Array.toList s))\n    Array.toList (As arr)\n\n[<Name \"last\">]\nlet Last (list : list<'T>) : 'T =\n    if List.isEmpty list then\n        listEmpty()\n    let mutable r = list\n    let mutable t = unsafeTail r\n    while notEmpty t do\n        r <- t\n        t <- unsafeTail r\n    unsafeHead r\n\n[<Name \"contains\">]\nlet Contains (el: 'T) (x: list<'T>) =\n    let mutable c = false\n    let mutable l = x\n    while not c && notEmpty l do\n        c <- el = unsafeHead l\n        l <- unsafeTail l\n    c\n\n[<Name \"mapFold\">]\nlet MapFold<'T, 'S, 'R> (f: 'S -> 'T -> 'R * 'S) zero list =\n    ArrayMapFold f zero (List.toArray list)\n    |> (fun (x, y) ->\n        (Array.toList x, y)\n    )\n\n[<Name \"mapFoldBack\">]\nlet MapFoldBack<'T, 'S, 'R> f list zero =\n    ArrayMapFoldBack<'T, 'S, 'R> f (List.toArray list) zero\n    |> (fun (x, y) ->\n        (Array.toList x, y)\n    )\n\n[<Name \"pairwise\">]\nlet Pairwise (l: list<'T>) : list<'T * 'T> =\n    Seq.pairwise (List.toSeq l)\n    |> Seq.toList\n\n[<Name \"indexed\">]\nlet Indexed (list : list<'T>) : list<int * 'T> =\n    List.mapi (fun a b -> (a, b)) list\n\n[<Inline>]\nlet Singleton<'T> (x: 'T) =\n    [x]\n\n[<Inline>]\nlet Skip<'T> i (l : list<'T>) = ListSkip i l\n\n[<Inline>]\nlet SkipWhile<'T> (predicate : 'T -> bool) (list : list<'T>) : list<'T> =\n    ListSkipWhile predicate list\n\n[<Inline>]\nlet Take<'T> n (list: list<'T>) =\n    Seq.take n list |> List.ofSeq\n\n[<Inline>]\nlet TakeWhile<'T> (predicate : 'T -> bool) (list: list<'T>) =\n    Seq.takeWhile predicate list |> List.ofSeq\n\n[<Inline>]\nlet Truncate<'T> n (list: list<'T>) =\n    Seq.truncate n list |> List.ofSeq\n\n[<Name \"tryHead\">]\nlet TryHead<'T> (list: list<'T>) =\n    match list with\n    | head :: _ ->\n        Some head\n    | [] ->\n        None\n\n[<Inline>]\nlet TryItem<'T> n (list: list<'T>) =\n    SeqTryItem n list \n\n[<Inline>]\nlet TryLast<'T> (list: list<'T>) =\n    SeqTryLast list\n\n[<Name \"exactlyOne\">]\nlet ExactlyOne (list : 'T list) =\n    match list with\n    | head :: [] ->\n        head\n    | _ ->\n        failwith \"The input does not have precisely one element.\"\n\n[<Name \"unfold\">]\nlet Unfold<'T, 'S> (f: 'S -> option<'T * 'S>) (s: 'S) : list<'T> =\n    Seq.unfold f s\n    |> Seq.toList\n\n[<Inline>]\nlet Where (predicate : 'T -> bool) (s : 'T list) : 'T list =\n    Filter predicate s\n\n[<Name \"windowed\">]\nlet Windowed (windowSize: int) (s: 'T list) : list<list<'T>> =\n    Seq.windowed windowSize (List.toSeq s)\n    |> Seq.map List.ofArray |> Seq.toList\n\n[<Name \"splitAt\">]\nlet SplitAt (n: int) (list: 'T list) =\n    (Take n list, Skip n list)\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen WebSharper.JavaScript\n\n[<JavaScript>]\nmodule Nullable =\n    let get (x: obj) =\n        if x ==. null then failwith \"Nullable object must have a value.\" else x\n\n////    let getOrDefault<'T> (x: 'T) =\n//        if x ==. null then Unchecked.defaultof<'T> else x     \n\n    let getOrValue<'T> (x: 'T) (v: 'T)  =\n        if x ==. null then v else x     \n\n[<Proxy(typeof<System.Nullable<_>>)>]\ntype private NullableProxy<'T> =\n    \n    [<Inline \"null\">]\n    new () = {}\n\n    [<Inline \"$v\">]\n    new (v: 'T) = {}\n\n    member this.Value \n        with [<JavaScript; Inline>] get(): 'T = As<'T>(Nullable.get this)\n\n    member this.HasValue\n        with [<JavaScript; Inline>] get() = this !=. null\n\n//    [<Inline>]\n////    member this.GetValueOrDefault() : 'T = Nullable.getOrDefault (As<'T> this)\n\n    [<Inline>]\n    member this.GetValueOrDefault(v: 'T) : 'T = Nullable.getOrValue (As<'T> this) v\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.Name \"Operators\">]\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Core.Operators, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.OperatorsProxy\n\n#nowarn \"86\"\n\nopen WebSharper.JavaScript\n\nmodule M = WebSharper.Macro\n\n[<JavaScript>]\n[<Name \"range\">]\n[<Macro(typeof<M.Range>)>]\nlet ( .. ) (min: 'T) (max: 'T) : seq<'T> =\n    let count = 1 + As max - As min\n    if count <= 0 then Seq.empty\n    else Seq.init count (fun x -> As (x + As min))\n\n[<Name \"step\">]\nlet ( .. .. ) (min: 'T1) (step: 'T2) (max: 'T1) : seq<'T1> =\n    let s = sign (As<int> step)\n    Seq.initInfinite (fun k -> As<int> min + k * As<int> step)\n    |> Seq.takeWhile (fun k -> s * (As<int> max - As<int> k) >= 0)\n    |> As\n\n[<Inline \"$r[0]\">]\nlet ( ! ) (r: ref<'T>) = X<'T>\n\n[<Macro(typeof<M.Arith>)>]\nlet ( % ) (a: 'T1) (b: 'T2) = X<'T3>\n\n[<Inline \"$a & $b\">]\nlet ( &&& ) (a: 'T1) (b: 'T1) = X<'T1>\n\n[<Macro(typeof<M.Arith>)>]\nlet ( * ) (a: 'T1) (b: 'T2) = X<'T3>\n\n[<Inline \"Math.pow($a, $b)\">]\nlet ( ** ) (a: 'T1) (b: 'T2) = X<'T1>\n\n[<Inline \"Math.pow($a, $p)\">]\nlet PowInteger (a: 'T, p: int) = X<'T>\n\n[<Macro(typeof<M.Arith>)>]\nlet ( + ) (a: 'T1) (b: 'T2) = X<'T3>\n\n[<Macro(typeof<M.Arith>)>]\nlet ( - ) (a: 'T1) (b: 'T2) = X<'T3>\n\n[<Macro(typeof<M.Arith>)>]\nlet ( / ) (x: 'T1) (y: 'T2) = X<'T3>\n\n[<Inline \"void ($a[0] = $b)\">]\nlet ( := ) (a: ref<'T>) (b: 'T) = X<unit>\n\n[<Inline>]\nlet ( << ) (f: 'T1 -> 'T2) (g: 'T3 -> 'T1) : 'T3 -> 'T2 = \n    ()\n    fun x -> f (g x)\n\n[<Inline \"$a << $b\">]\nlet inline ( <<< ) (a: 'T) (b: int) = X<'T>\n\n[<Inline>]\nlet ( <| ) (f: 'T -> 'TR) (x: 'T) : 'TR = f x\n\n[<Inline>]\nlet ( <|| ) (f: 'T1 -> 'T2 -> 'TR) (x: 'T1, y: 'T2) : 'TR = f x y\n\n[<Inline>]\nlet ( <||| ) (f: 'T1 -> 'T2 -> 'T3 -> 'TR)\n             (x: 'T1, y: 'T2, z: 'T3) : 'TR = f x y z\n\n[<Macro(typeof<M.Comp>)>]\nlet ( = ) (a: 'T) (b: 'T) = X<bool>\n\n[<Macro(typeof<M.Comp>)>]\nlet ( <> ) (a: 'T) (b: 'T) =  X<bool>\n\n[<Macro(typeof<M.Comp>)>]\nlet ( < ) (a: 'T) (b: 'T) = X<bool>\n\n[<Macro(typeof<M.Comp>)>]\nlet ( > ) (a: 'T) (b: 'T) = X<bool>\n\n[<Macro(typeof<M.Comp>)>]\nlet ( <= ) (a: 'T) (b: 'T) = X<bool>\n\n[<Macro(typeof<M.Comp>)>]\nlet ( >= ) (a: 'T) (b: 'T) = X<bool>\n\n[<Inline>]\nlet ( >> ) (f: 'T1 -> 'T2) (g: 'T2 -> 'T3): 'T1->'T3 = \n    ()\n    fun x -> g (f x)\n\n[<Inline \"$a >> $b\">]\nlet inline ( >>> ) (a: 'T) (b: int) : 'T = a >>> b\n\n[<Inline>]\nlet ( @ ) a b = List.append a b\n\n[<Inline \"$a + $b\">]\nlet ( ^ ) (a: string) (b: string) : string = a + b\n\n[<Inline \"$a ^ $b\">]\nlet ( ^^^ ) (a: 'T) (b: 'T) = X<'T>\n\n[<Inline>]\nlet ( |> ) (x: 'T1) (f: 'T1 -> 'T2) : 'T2 = f x\n\n[<Inline>]\nlet ( ||> ) (x: 'T1, y: 'T2) (f: 'T1 -> 'T2 -> 'TR) : 'TR = f x y\n\n[<Inline \"$a | $b\">]\nlet ( ||| ) (a: 'T) (b: 'T) = X<'T>\n\n[<Inline>]\nlet ( |||> ) (x: 'T1, y: 'T2, z: 'T3)\n             (f: 'T1 -> 'T2 -> 'T3 -> 'TR) : 'TR = f x y z\n\n[<Inline \"+ $x\">]\nlet ( ~+ ) (x: 'T) = X<'T>\n\n[<Inline \"- $x\">]\nlet ( ~- ) (x: 'T) = X<'T>\n\n[<Inline \"~ $x\">]\nlet ( ~~~ ) (x: 'T) = X<'T>\n\n[<Inline \"Math.abs($x)\">]\nlet Abs (x: 'T) = X<'T>\n\n[<Inline \"Math.acos($x)\">]\nlet Acos (x: 'T) = X<'T>\n\n[<Inline \"Math.asin($x)\">]\nlet Asin (x: 'T) = X<'T>\n\n[<Inline \"Math.atan($x)\">]\nlet Atan (x: 'T) = X<'T>\n\n[<Inline \"Math.atan2($x, $y)\">]\nlet Atan2 (x: 'T1) (y: 'T1) = X<'T2>\n\n[<Inline \"$x\">]\nlet Box (x: 'T) = X<obj>\n\n[<Inline \"Math.ceil($x)\">]\nlet Ceiling (x: 'T) = X<'T>\n\n[<Macro(typeof<M.Char>)>]\nlet ToChar (x: 'T) = X<char>\n\n[<Inline>]\nlet Compare<'T> (a: 'T) (b: 'T) = Unchecked.compare a b\n\n[<Inline \"Math.cos($x)\">]\nlet Cos (x: 'T) = X<'T>\n\n[<Inline \"(Math.exp($x)+Math.exp(-$x))/2\">]\nlet Cosh<'T> (x: 'T) = X<'T>\n\n[<Inline \"void ($x[0]--)\">]\nlet Decrement (x: ref<int>) = ()\n\n[<Inline>]\nlet DefaultArg x d =\n    match x with\n    | Some x -> x\n    | None   -> d\n\n[<Inline \"$x\">]\nlet Enum<'T when 'T : enum<int>> (x: 'T) = X<'T>\n\n[<Macro(typeof<M.Conversion>)>]\nlet ToDouble (x: 'T) = X<double>\n\n[<Inline \"Math.exp($x)\">]\nlet inline Exp (x: 'T) = X<'T>\n\nlet FailWith (msg: string) : 'T = raise (exn msg)\n\n[<Macro(typeof<M.Conversion>)>]\nlet ToFloat (x: 'T) = X<float>\n\n[<Inline \"Math.floor($x)\">]\nlet Floor (x: 'T) = X<'T>\n\n[<Inline \"$x[0]\">]\nlet Fst (x: System.Tuple<'T1,'T2>) = X<'T1>\n\n[<Inline>]\nlet Hash<'T when 'T : equality> (x: 'T) = Unchecked.hash x\n\n[<Inline \"$x\">]\nlet Identity (x: 'T) = X<'T>\n\n[<Inline \"void $x\">]\nlet Ignore (x: 'T) = X<unit>\n\n[<Inline \"void ($x[0]++)\">]\nlet Increment (x: ref<int>) = ()\n\n[<Inline \"Infinity\">]\nlet Infinity = Unchecked.defaultof<double>\n\nlet InvalidOp (msg: string) : 'T = raise (System.InvalidOperationException(msg))\n\nlet InvalidArg (arg: string) (msg: string) : 'T = raise (System.ArgumentException(arg, msg))\n\n[<Macro(typeof<M.Conversion>)>]\nlet ToInt (x: 'T) = X<int>\n\n[<Macro(typeof<M.Conversion>)>]\nlet ToSingle (x: 'T) = X<single>\n\n[<Macro(typeof<M.Conversion>)>]\nlet ToInt32 (x: 'T) = X<int32>\n\n[<Inline \"$x\">]\nlet ToEnum<'T> (x: int) = X<'T>\n\n[<Macro(typeof<M.Conversion>)>]\nlet ToInt64 (x: 'T) = X<int64>\n\n[<Inline \"Math.log($x)\">]\nlet Log (x: 'T) = X<'T>\n\n[<Inline \"Math.log($x)/Math.log(10)\">]\nlet Log10 (x: 'T) = X<'T>\n\n[<Inline>]\nlet Max<'T when 'T : comparison> (a: 'T) (b: 'T) =\n    if a > b then a else b\n\n[<Inline>]\nlet Min<'T when 'T : comparison> (a: 'T) (b: 'T) =\n    if a < b then a else b\n\n[<Inline \"Infinity\">]\nlet InfinitySingle = single infinity\n\n[<Inline \"NaN\">]\nlet NaNSingle = single nan\n\n[<Inline \"NaN\">]\nlet NaN = nan\n\n[<Inline \"!$x\">]\nlet Not (x: bool) = X<bool>\n\nlet Pown<'T> (a: 'T) (n: int) =\n    let a = box a :?> double\n    let rec p n =\n        match n with\n        | 1 ->\n            a\n        | n when n % 2 = 0 ->\n            let b = p (n / 2)\n            b * b\n        | n ->\n            a * (p (n - 1))\n    p n\n\n[<Inline \"throw $e\">]\nlet Raise (e: exn) = X<'T>\n\n[<Inline \"[$x]\">]\nlet Ref (x: 'T) = X<ref<'T>>\n\n[<Inline \"Math.round($x)\">]\nlet Round (x: 'T) = X<'T>\n\n[<Inline \"$x\">]\nlet CreateSequence (x: seq<'T>) = X<seq<'T>>\n\nlet Sign<'T> (x: 'T) =\n    match As<int> x with\n    | 0            -> 0\n    | n when n < 0 -> -1\n    | _            -> 1\n\n[<Inline \"Math.sin($x)\">]\nlet Sin (x: 'T) = X<'T>\n\n[<Inline \"(Math.exp($x)-Math.exp(-$x))/2\">]\nlet Sinh (x: 'T) = x\n\n[<Inline \"$x[1]\">]\nlet Snd (x: System.Tuple<'T1,'T2>) = X<'T2>\n\n[<Inline \"Math.sqrt($x)\">]\nlet Sqrt (x: 'T1) = X<'T2>\n\n[<Macro(typeof<M.String>)>]\nlet ToString (x: 'T) = X<string>\n\n[<Inline \"Math.tan($x)\">]\nlet inline Tan (x: 'T) = X<'T>\n\n[<Inline \"(Math.exp(2*$x)-1)/(Math.exp(2*$x)+1)\">]\nlet Tanh (x: 'T) = X<'T>\n\nlet inline Truncate<'T> (x: 'T) =\n    if x <. 0 then Ceiling x else Floor x\n\n[<Inline \"$x\">]\nlet Unbox (x: obj) = X<'T>\n\n[<Inline \"$x == null\">]\nlet IsNull (x: 'T) = X<bool>\n\n[<Inline>]\nlet Using t f =\n    try f t finally (t :> System.IDisposable).Dispose()\n\n[<Name \"KeyValue\">]\nlet KeyValuePattern (kvp: System.Collections.Generic.KeyValuePair<_,_>) =\n    (kvp.Key, kvp.Value)\n\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.Name \"Slice\">]\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Core.Operators+OperatorIntrinsics, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.OperatorIntrinsicsProxy \n\nopen WebSharper.JavaScript\n\n[<Inline \"$s.slice($st,$e)\">]\nlet Slice (s: 'T) (st: int) (e: int) = X<'T>\n\n[<Inline \"$s.slice($st)\">]\nlet SliceStart (s: 'T) (st: int) = X<'T>\n\n[<Name \"string\">]\nlet GetStringSlice (source: string) (start: int option) (finish: int option) =\n    match start, finish with\n    | Some s, Some f -> Slice source s (f + 1)\n    | Some s, None -> SliceStart source s\n    | None, Some f -> Slice source 0 (f + 1)\n    | _ -> \"\"\n\n[<Name \"array\">]\nlet GetArraySlice<'T> (source: 'T[]) (start: int option) (finish: int option) =\n    match start, finish with\n    | Some s, Some f -> Slice source s (f + 1)\n    | Some s, None -> SliceStart source s\n    | None, Some f -> Slice source 0 (f + 1)\n    | _ -> [||]\n\nmodule F = WebSharper.IntrinsicFunctionProxy\n\n[<Name \"setArray\">]\nlet SetArraySlice (dst: _[]) start finish (src:_[]) = \n    let start  = (match start with None -> 0 | Some n -> n) \n    let finish = (match finish with None -> Array.length dst - 1 | Some n -> n) \n    F.SetArraySub dst start (finish - start + 1) src\n\n[<Name \"array2D\">]\nlet GetArraySlice2D (arr: _[,]) start1 finish1 start2 finish2 = \n    let start1  = (match start1 with None -> 0 | Some n -> n) \n    let start2  = (match start2 with None -> 0 | Some n -> n) \n    let finish1 = (match finish1 with None -> F.GetArray2DLength1 arr - 1 | Some n -> n) \n    let finish2 = (match finish2 with None -> F.GetArray2DLength2 arr - 1 | Some n -> n) \n    let len1 = (finish1 - start1 + 1)\n    let len2 = (finish2 - start2 + 1)\n    F.GetArray2DSub arr start1 start2 len1 len2\n\n[<Name \"array2Dfix1\">]\nlet GetArraySlice2DFixed1 (arr: _[,]) fixed1 start2 finish2 = \n    let start2  = (match start2 with None -> 0 | Some n -> n) \n    let finish2 = (match finish2 with None -> F.GetArray2DLength2 arr - 1 | Some n -> n) \n    let len2 = (finish2 - start2 + 1)\n    let dst = JavaScript.Array(len2)\n    for j = 0 to len2 - 1 do \n        F.SetArray dst.Self j (F.GetArray2D arr fixed1 (start2+j))\n    dst.Self\n\n[<Name \"array2Dfix2\">]\nlet GetArraySlice2DFixed2 (arr: _[,]) start1 finish1 fixed2 = \n    let start1  = (match start1 with None -> 0 | Some n -> n) \n    let finish1 = (match finish1 with None -> F.GetArray2DLength1 arr - 1 | Some n -> n) \n    let len1 = (finish1 - start1 + 1)\n    let dst = JavaScript.Array(len1)\n    for i = 0 to len1 - 1 do \n        F.SetArray dst.Self i (F.GetArray2D arr (start1+i) fixed2)\n    dst.Self\n\n[<Name \"setArray2Dfix1\">]\nlet SetArraySlice2DFixed1 (dst: _[,]) fixed1 start2 finish2 (src:_[]) = \n    let start2  = (match start2 with None -> 0 | Some n -> n) \n    let finish2 = (match finish2 with None -> F.GetArray2DLength2 dst - 1 | Some n -> n) \n    let len2 = (finish2 - start2 + 1)\n    for j = 0 to len2 - 1 do\n        F.SetArray2D dst fixed1 (start2+j) (F.GetArray src j)\n\n[<Name \"setArray2Dfix2\">]\nlet SetArraySlice2DFixed2 (dst: _[,]) start1 finish1 fixed2 (src:_[]) = \n    let start1  = (match start1 with None -> 0 | Some n -> n) \n    let finish1 = (match finish1 with None -> F.GetArray2DLength1 dst - 1 | Some n -> n) \n    let len1 = (finish1 - start1 + 1)\n    for i = 0 to len1 - 1 do\n        F.SetArray2D dst (start1+i) fixed2 (F.GetArray src i)\n\n[<Name \"setArray2D\">]\nlet SetArraySlice2D (dst: _[,]) start1 finish1 start2 finish2 (src:_[,]) = \n    let start1  = (match start1 with None -> 0 | Some n -> n) \n    let start2  = (match start2 with None -> 0 | Some n -> n) \n    let finish1 = (match finish1 with None -> F.GetArray2DLength1 dst - 1 | Some n -> n) \n    let finish2 = (match finish2 with None -> F.GetArray2DLength2 dst - 1 | Some n -> n) \n    F.SetArray2DSub dst start1 start2 (finish1 - start1 + 1) (finish2 - start2 + 1) src\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.NameAttribute \"Option\">]\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Core.OptionModule, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.OptionModuleProxy\n\nopen WebSharper.JavaScript\n\n[<Inline>]\nlet Bind f x =\n    match x with\n    | Some x -> f x\n    | None   -> None\n\n[<Inline>]\nlet Contains v o =\n    match o with\n    | Some x -> x = v\n    | None -> false\n\n[<Inline \"$x ? 1 : 0\">]\nlet Count (x: option<_>) = X<int>\n\n[<Inline>]\nlet DefaultValue v o =\n    match o with\n    | Some x -> x \n    | None -> v\n\n[<Inline>]\nlet DefaultWith f o =\n    match o with\n    | Some x -> x \n    | None -> f()\n\n[<Inline>]\nlet Exists p x =\n    match x with\n    | Some x -> p x\n    | None   -> false\n\n[<Name \"filter\">]\nlet Filter f o =\n    match o with\n    | Some x when f x -> o\n    | _ -> None\n\n[<Inline>]\nlet Flatten o =\n    match o with\n    | Some x -> x\n    | None -> None\n\n[<Name \"fold\">]\nlet Fold<'T,'S> (f: 'S -> 'T -> 'S) (s: 'S) (x: option<'T>) : 'S =\n    match x with\n    | Some x -> f s x\n    | None   -> s\n\n[<Name \"foldBack\">]\nlet FoldBack f x s =\n    match x with\n    | Some x -> f x s\n    | None   -> s\n\n[<Inline>]\nlet ForAll p x =\n    match x with\n    | Some x -> p x\n    | None   -> true\n\n[<Inline \"$x.$0\"; Pure>]\nlet GetValue (x: option<'T>) = X<'T>\n\n[<Inline \"$x==null\">]\nlet IsNone (x: option<'T>) = false\n\n[<Inline \"$x!=null\">]\nlet IsSome (x: option<'T>) =  false\n\n[<Inline>]\nlet Iterate p x =\n    match x with\n    | Some x -> p x\n    | None   -> ()\n\n[<Inline>]\nlet Map f x =\n    match x with\n    | Some x -> Some (f x)\n    | None -> None\n\n[<Inline>]\nlet Map2 f x y =\n    match x, y with\n    | Some x, Some y -> Some (f x y)\n    | _ -> None\n\n[<Inline>]\nlet Map3 f x y z =\n    match x, y, z with\n    | Some x, Some y, Some z -> Some (f x y z)\n    | _ -> None\n\n[<Name \"ofNullable\">]\nlet OfNullable (o: System.Nullable<'T>) =\n    if o ==. null then None else Some o.Value                   \n\n[<Name \"ofObj\">]\nlet OfObj o = \n    if o ==. null then None else Some o\n\n[<Inline>]\nlet OrElse v o =\n    match o with\n    | Some x -> o \n    | None -> v\n\n[<Inline>]\nlet OrElseWith f o =\n    match o with\n    | Some x -> o \n    | None -> f()\n\n[<Name \"toArray\">]\nlet ToArray x =\n    match x with\n    | Some x -> [|x|]\n    | None   -> [||]\n\n[<Name \"toList\">]\nlet ToList x =\n    match x with\n    | Some x -> [x]\n    | None   -> []\n\n[<Name \"toNullable\">]\nlet ToNullable o =\n    match o with\n    | Some v -> System.Nullable(v)\n    | _ -> System.Nullable()\n\n[<Name \"toObj\">]\nlet ToObj o = \n    match o with\n    | Some v -> v\n    | None -> null\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.Name \"Queue\">]\nmodule private WebSharper.QueueProxy\n\nopen WebSharper.JavaScript\n\n[<Inline \"$arr.splice($offset,$len)\">]\nlet splice (arr: obj) (offset: int) (len: int) = X<unit>\n\n[<JavaScript>]\nlet Clear (a: obj) =\n    splice a 0 (a :?> obj []).Length\n\n[<JavaScript>]\nlet Contains (a: obj) (el: 'T) =\n    Seq.exists ((=) el) (a :?> seq<'T>)\n\n[<JavaScript>]\nlet CopyTo (a: obj) (array: 'T[]) (index: int) =\n    Array.blit (a :?> 'T []) 0 array index (a :?> 'T[]).Length\n\n[<Proxy(typeof<System.Collections.Generic.Queue<_>>)>]\n[<WebSharper.Name \"WebSharper.Queue\">]\ntype private QueueProxy<'T when 'T : equality>\n\n    [<Inline \"$data\">] private (data: 'T []) =\n\n    [<Inline \"[]\">]\n    private new () = QueueProxy [||]\n\n    [<Inline>]\n    private new (s: seq<'T>) = QueueProxy (Array.ofSeq s)\n\n    member this.Count with [<Inline \"$this.length\">] get () = X<int>\n\n    [<Inline>]\n    member this.Clear() = Clear this\n\n    [<Inline>]\n    member this.Contains(x: 'T) = Contains this x\n\n    [<Inline>]\n    member this.CopyTo(array: 'T [], index: int) = CopyTo this array index\n\n    [<Inline \"$this[0]\">]\n    member this.Peek() = X<'T>\n\n    [<Inline \"$this.shift()\">]\n    member this.Dequeue() = X<'T>\n\n    [<Inline \"$this.push($x)\">]\n    member this.Enqueue(x: 'T) = X<unit>\n\n    [<Inline \"$this.slice(0)\">]\n    member this.ToArray() = data\n\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen WebSharper.JavaScript\n\n[<AutoOpen>]\nmodule RandomHelpers =\n    [<Inline \"Math.floor(Math.random() * 2147483648)\">]\n    let Next() = X<int>\n    \n    [<Inline \"Math.floor(Math.random() * $maxValue)\">]\n    let NextMax (maxValue: int) = X<int>\n\n[<Name \"Random\">]\n[<Proxy(typeof<System.Random>)>]\ntype internal RandomProxy() =\n    member this.Next() = Next()\n\n    member this.Next maxValue =\n        if maxValue < 0 then\n            failwith \"'maxValue' must be greater than zero.\"\n        else NextMax maxValue\n\n    member this.Next (minValue: int, maxValue: int) =\n        if minValue > maxValue then\n            failwith \"'minValue' cannot be greater than maxValue.\"\n        else minValue + NextMax (maxValue - minValue)\n\n    member this.NextBytes (buffer: byte[]) =\n        for i = 0 to buffer.Length - 1 do\n            buffer.[i] <- As (NextMax 256)\n\n    [<Inline \"Math.random()\">]\n    member this.NextDouble() = X<float>\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.NameAttribute \"Result\">]\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Core.ResultModule, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.ResultModuleProxy\n    \nlet Bind f r =\n    match r with\n    | Ok x -> f x\n    | Error e -> Error e\n        \nlet Map f r =\n    match r with\n    | Ok x -> Ok (f x)\n    | Error e -> Error e\n        \nlet MapError f r =\n    match r with\n    | Ok x -> Ok x\n    | Error e -> Error (f e)    \n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Core.CompilerServices.RuntimeHelpers, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.RuntimeHelpersProxy\n\n#nowarn \"40\"\n\nopen WebSharper.JavaScript\n\ntype IE<'T> = System.Collections.Generic.IEnumerator<'T>\n\n[<Inline>]\nlet safeDispose (x: System.IDisposable) =\n    if x <> null then x.Dispose()\n\n[<Name \"WebSharper.Seq.enumFinally\">]\nlet EnumerateThenFinally (s: seq<'T>) (f: unit -> unit) : seq<'T> =\n    Enumerable.Of <| fun () ->\n        let enum = try Enumerator.Get s with e -> f(); raise e\n        Enumerator.NewDisposing () (fun _ -> enum.Dispose(); f()) <| fun e ->\n            if enum.MoveNext() then\n                e.Current <- enum.Current\n                true\n            else\n                false\n\n[<Name \"WebSharper.Seq.enumUsing\">]\nlet EnumerateUsing<'T1,'T2,'T3 when 'T1 :> System.IDisposable\n                                and 'T2 :> seq<'T3>>\n        (x: 'T1) (f: 'T1 -> 'T2) : seq<'T3> =\n\n    Enumerable.Of <| fun () ->\n        let enum = try Enumerator.Get (f x) with e -> x.Dispose(); raise e\n        Enumerator.NewDisposing () (fun _ -> enum.Dispose(); x.Dispose()) <| fun e ->\n            if enum.MoveNext() then\n                e.Current <- enum.Current\n                true\n            else\n                false\n\n[<Name \"WebSharper.Seq.enumWhile\">]\nlet EnumerateWhile (f: unit -> bool) (s: seq<'T>) : seq<'T> =\n    Enumerable.Of (fun () ->\n        let rec next (en: Enumerator.T<IE<_>,'T>) =\n            match en.State with\n            | null ->\n                if f () then\n                    en.State <- Enumerator.Get s\n                    next en\n                else\n                    false\n            | e ->\n                if e.MoveNext() then\n                    en.Current <- e.Current\n                    true\n                else\n                    e.Dispose()\n                    en.State <- null\n                    next en\n        Enumerator.NewDisposing null (fun en -> safeDispose en.State) next)\n\n[<Name \"WebSharper.Control.createEvent\">]\nlet CreateEvent<'D, 'A when 'D : delegate<'A, unit> and 'D :> System.Delegate> \n        (add: 'D -> unit) \n        (remove: 'D -> unit)\n        (create: (obj -> 'A -> unit) -> 'D) : IEvent<'D, 'A> =\n    { new IEvent<'D, 'A> with\n        member this.AddHandler h = add h\n        member this.RemoveHandler h = remove h\n        member this.Subscribe (r: System.IObserver<'A>) =     \n            let h = create (fun _ args -> r.OnNext(args))\n            add h\n            { new System.IDisposable with member this.Dispose() = remove h }\n    }\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.Name \"Seq\">]\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Collections.SeqModule, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.SeqModuleProxy\n\nopen WebSharper.JavaScript\nopen WebSharper.CollectionInternals\n\n[<Inline>]\nlet safeDispose (x: System.IDisposable) =\n    if x <> null then x.Dispose()\n\n[<Name \"allPairs\">]\nlet AllPairs (source1: seq<_>) (source2: seq<_>) =\n    let cached = Seq.cache source2\n    source1 |> Seq.collect (fun x -> cached |> Seq.map (fun y -> x,y))\n\n[<Name \"append\">]\nlet Append (s1: seq<'T>) (s2: seq<'T>) : seq<'T> =\n    Enumerable.Of (fun () ->\n        let e1 = Enumerator.Get s1\n        let first = ref true\n        Enumerator.NewDisposing e1 (fun x -> safeDispose x.State) (fun x ->\n            if x.State.MoveNext() then\n                x.Current <- x.State.Current\n                true\n            else \n                safeDispose x.State\n                x.State <- null\n                if !first then\n                    first := false\n                    x.State <- Enumerator.Get s2\n                    if x.State.MoveNext() then\n                        x.Current <- x.State.Current\n                        true\n                    else\n                        x.State.Dispose()\n                        x.State <- null\n                        false\n                else \n                    false)) \n\n[<Name \"average\">]\nlet Average<'T> (s: seq<'T>) : 'T =\n    let (count, sum) =\n        Seq.fold\n            (fun (n, s) x -> (n + 1, s + As<float> x))\n            (0, 0.)\n            s\n    if count = 0 then\n        invalidArg \"source\" \"The input sequence was empty.\"\n    else\n        As<'T> (sum / As<float> count)\n\n[<Name \"averageBy\">]\nlet AverageBy<'T,'U> (f: 'T -> 'U) (s: seq<'T>) : 'U =\n    let (count, sum) =\n        Seq.fold\n            (fun (n, s) x -> (n + 1, s + As<float> (f x)))\n            (0, 0.)\n            s\n    if count = 0 then\n        invalidArg \"source\" \"The input sequence was empty.\"\n    else\n        As<'U> (sum / As<float> count)\n\n[<Name \"cache\">]\nlet Cache<'T> (s: seq<'T>) : seq<'T> =\n    let cache = JavaScript.Array<'T>()\n    let o  = ref (Enumerator.Get s)\n    Enumerable.Of <| fun () ->\n        let next (e: Enumerator.T<_,_>) =\n            if e.State < cache.Length then\n                e.Current <- cache.[e.State]\n                e.State   <- e.State + 1\n                true\n            else\n                let en = !o\n                if en = null then false\n                elif en.MoveNext() then\n                    e.State   <- e.State + 1\n                    e.Current <- en.Current\n                    cache.Push(e.Current) |> ignore\n                    true\n                else\n                    en.Dispose()\n                    o := null\n                    false\n        Enumerator.New 0 next\n\n/// IEnumerable is not supported.\n[<Inline \"$i\">]\nlet Cast<'T> (i: System.Collections.IEnumerable) = X<seq<'T>>\n\n[<Inline>]\nlet Contains (el: 'T) (s: seq<'T>) =\n    SeqContains el s\n\n[<Name \"choose\">]\nlet Choose (f: 'T -> option<'U>) (s: seq<'T>) : seq<'U> =\n    s\n    |> Seq.collect (fun x ->\n        match f x with\n        | Some v -> [v]\n        | None   -> [])\n\n[<Inline>]\nlet ChunkBySize (size: int) (s: seq<'T>) = SeqChunkBySize size s\n\n[<Name \"collect\">]\nlet Collect f s = Seq.concat (Seq.map f s)\n\n[<Name \"compareWith\">]\nlet CompareWith  (f: 'T -> 'T -> int) (s1: seq<'T>) (s2: seq<'T>) : int =\n    use e1 = Enumerator.Get s1\n    use e2 = Enumerator.Get s2\n    let mutable r = 0\n    let mutable loop = true\n    while loop && r = 0 do\n        match e1.MoveNext(), e2.MoveNext() with\n        | true, false ->\n            r <- 1\n        | false, true ->\n            r <- -1\n        | false, false ->\n            loop <- false\n        | true, true ->\n            r <- f e1.Current e2.Current\n    r\n\n[<Name \"concat\">]\nlet Concat (ss: seq<#seq<'T>>) : seq<'T> =\n    Enumerable.Of (fun () ->\n        let outerE = Enumerator.Get ss\n        let rec next (st: Enumerator.T<Enumerator.IE<'T>,'T>) =\n            match st.State with\n            | null ->\n                if outerE.MoveNext() then\n                    st.State <- Enumerator.Get outerE.Current\n                    next st\n                else\n                    outerE.Dispose()\n                    false\n            | innerE ->\n                if innerE.MoveNext() then\n                    st.Current <- innerE.Current\n                    true\n                else\n                    (st :> System.IDisposable).Dispose()\n                    st.State <- null\n                    next st\n        Enumerator.NewDisposing null (fun st -> \n            safeDispose st.State \n            safeDispose outerE) \n            next)\n\n[<Name \"countBy\">]\nlet CountBy (f: 'T -> 'K) (s: seq<'T>) : seq<'K * int> =\n    Seq.delay <| fun () ->\n        ArrayCountBy f (Array.ofSeq s) |> Seq.ofArray\n\n[<Name \"delay\">]\nlet Delay<'T> (f: unit -> seq<'T>) : seq<'T> =\n    Enumerable.Of (fun () -> Enumerator.Get(f()))\n\n[<Name \"distinct\">]\nlet Distinct<'T when 'T : equality> (s: seq<'T>) : seq<'T> =\n    Seq.distinctBy id s\n\n[<Name \"distinctBy\">]\nlet DistinctBy<'T,'K when 'K : equality>\n        (f: 'T -> 'K) (s: seq<'T>) : seq<'T> =\n    Enumerable.Of <| fun () ->\n        let o  = Enumerator.Get s\n        let seen = System.Collections.Generic.HashSet<'K>()\n        Enumerator.NewDisposing () (fun _ -> o.Dispose()) <| fun e ->\n            if o.MoveNext() then\n                let mutable cur = o.Current\n                let mutable has = seen.Add(f cur)\n                while not has && o.MoveNext() do\n                    cur <- o.Current\n                    has <- seen.Add(f cur)\n                if has then\n                    e.Current <- cur\n                    true\n                else\n                    false\n            else\n                false\n\n[<Name \"splitInto\">]\nlet SplitInto count (s: seq<'T>) =\n    if count <= 0 then failwith \"Count must be positive\"\n    Seq.delay (fun () -> ArraySplitInto count (Array.ofSeq s) |> Seq.ofArray)   \n\n[<Inline>]\nlet Empty<'T> : seq<'T> = As [||]\n\n[<Name \"exactlyOne\">]\nlet ExactlyOne<'T> (s: seq<'T>) =\n    use e = Enumerator.Get s\n    if e.MoveNext() then\n        let x = e.Current\n        if e.MoveNext() then\n            invalidOp \"Sequence contains more than one element\"\n        else x\n    else invalidOp \"Sequence contains no elements\"\n\n[<Inline>]\nlet Except (itemsToExclude: seq<'T>) (s: seq<'T>) =\n    SeqExcept itemsToExclude s\n\n[<Name \"exists\">]\nlet Exists p (s: seq<_>) =\n    use e = Enumerator.Get s\n    let mutable r = false\n    while not r && e.MoveNext() do\n        r <- p e.Current\n    r\n\n[<Name \"exists2\">]\nlet Exists2 p (s1: seq<_>) (s2: seq<_>) =\n    use e1 = Enumerator.Get s1\n    use e2 = Enumerator.Get s2\n    let mutable r = false\n    while not r && e1.MoveNext() && e2.MoveNext() do\n        r <- p e1.Current e2.Current\n    r\n\n[<Name \"filter\">]\nlet Filter (f: 'T -> bool) (s: seq<'T>) =\n    Enumerable.Of <| fun () ->\n        let o = Enumerator.Get s\n        Enumerator.NewDisposing () (fun _ -> o.Dispose()) <| fun e ->\n            let mutable loop = o.MoveNext()\n            let mutable c    = o.Current\n            let mutable res  = false\n            while loop do\n                if f c then\n                    e.Current <- c\n                    res       <- true\n                    loop      <- false\n                else\n                    if o.MoveNext() then\n                        c <- o.Current\n                    else\n                        loop <- false\n            res\n\n[<Name \"find\">]\nlet Find p (s: seq<_>) =\n    match Seq.tryFind p s with\n    | Some x -> x\n    | None   -> failwith \"KeyNotFoundException\"\n\n[<Name \"findIndex\">]\nlet FindIndex p (s: seq<_>) =\n    match Seq.tryFindIndex p s with\n    | Some x -> x\n    | None   -> failwith \"KeyNotFoundException\"\n\n[<Name \"fold\">]\nlet Fold<'T,'S> (f: 'S -> 'T -> 'S) (x: 'S) (s: seq<'T>) : 'S =\n    let mutable r = x\n    use e = Enumerator.Get s\n    while e.MoveNext() do\n        r <- f r e.Current\n    r\n\n[<Name \"forall\">]\nlet ForAll p s =\n    not (Seq.exists (fun x -> not (p x)) s)\n\n[<Name \"forall2\">]\nlet ForAll2 p s1 s2 =\n    not (Seq.exists2 (fun x y -> not (p x y)) s1 s2)\n\n[<Name \"groupBy\">]\nlet GroupBy (f: 'T -> 'K when 'K : equality) (s: seq<'T>) : seq<'K * seq<'T>> =\n    Seq.delay <| fun () ->\n        ArrayGroupBy f (Array.ofSeq s) |> As\n\n[<Name \"head\">]\nlet Head (s: seq<'T>) : 'T =\n    use e = Enumerator.Get s\n    if e.MoveNext() then e.Current else InsufficientElements()\n\n[<Name \"init\">]\nlet Initialize (n: int) (f: int -> 'T) : seq<'T> =\n    Seq.take n (Seq.initInfinite f)\n\n[<Name \"initInfinite\">]\nlet InitializeInfinite (f: int -> 'T) : seq<'T> =\n    Enumerable.Of <| fun () ->\n        Enumerator.New 0 <| fun e ->\n            e.Current <- f e.State\n            e.State   <- e.State + 1\n            true\n\n[<Name \"isEmpty\">]\nlet IsEmpty (s: seq<'T>) : bool =\n    use e = Enumerator.Get s\n    not (e.MoveNext())\n\n[<Name \"iter\">]\nlet Iterate p (s: seq<_>) =\n    use e = Enumerator.Get s\n    while e.MoveNext() do\n        p e.Current\n\n[<Name \"iter2\">]\nlet Iterate2 p (s1: seq<_>) (s2: seq<_>) =\n    use e1 = Enumerator.Get s1\n    use e2 = Enumerator.Get s2\n    while e1.MoveNext() && e2.MoveNext() do\n        p e1.Current e2.Current\n\n[<Name \"iteri\">]\nlet IterateIndexed p (s: seq<_>) =\n    let mutable i = 0\n    use e = Enumerator.Get s\n    while e.MoveNext() do\n        p i e.Current\n        i <- i + 1\n\n[<Inline>]\nlet Last (s: seq<_>) =\n    SeqLast s\n\n[<Name \"length\">]\nlet Length (s: seq<_>) =\n    let mutable i = 0\n    use e = Enumerator.Get s\n    while e.MoveNext() do\n        i <- i + 1\n    i\n\n[<Name \"map\">]\nlet Map (f: 'T -> 'U) (s: seq<'T>) : seq<'U> =\n    Enumerable.Of <| fun () ->\n        let en = Enumerator.Get s\n        Enumerator.NewDisposing () (fun _ -> en.Dispose()) <| fun e ->\n            if en.MoveNext() then\n                e.Current <- f en.Current\n                true\n            else\n                false\n\n[<Name \"mapi\">]\nlet MapIndexed (f: int -> 'T -> 'U) (s: seq<'T>) : seq<'U> =\n    Seq.map2 f (Seq.initInfinite id) s\n\n[<Name \"map2\">]\nlet Map2 (f: 'T -> 'U -> 'V) (s1: seq<'T>) (s2: seq<'U>) : seq<'V> =\n    Enumerable.Of <| fun () ->\n        let e1 = Enumerator.Get s1\n        let e2 = Enumerator.Get s2\n        Enumerator.NewDisposing () (fun _ -> e1.Dispose(); e2.Dispose()) <| fun e ->\n            if e1.MoveNext() && e2.MoveNext() then\n                e.Current <- f e1.Current e2.Current\n                true\n            else\n                false\n\n[<Name \"maxBy\">]\nlet MaxBy (f: 'T -> 'U) (s: seq<'T>) : 'T =\n    Seq.reduce (fun x y -> if f x >= f y then x else y) s\n\n[<Name \"minBy\">]\nlet MinBy (f: 'T -> 'U) (s: seq<'T>) : 'T =\n    Seq.reduce (fun x y -> if f x <= f y then x else y) s\n\n[<Name \"max\">]\nlet Max (s: seq<'T>) : 'T =\n    Seq.reduce (fun x y -> if x >= y then x else y) s\n\n[<Name \"min\">]\nlet Min (s: seq<'T>) : 'T =\n    Seq.reduce (fun x y -> if x <= y then x else y) s\n\n[<Name \"nth\">]\nlet Get index (s: seq<'T>) =\n    if index < 0 then\n        failwith \"negative index requested\"\n    let mutable pos = -1\n    use e = Enumerator.Get s\n    while pos < index do\n        if not (e.MoveNext()) then\n            InsufficientElements()\n        pos <- pos + 1\n    e.Current\n\n[<Inline>]\nlet Item index (s: seq<'T>) = Get index s\n\n[<Inline \"$a\">]\n[<Name \"ofArray\">]\nlet OfArray (a: 'T[]) = X<seq<'T>>\n\n[<Inline \"$l\">]\n[<Name \"ofList\">]\nlet OfList (l: list<'T>) = X<seq<'T>>\n\n[<Name \"pairwise\">]\nlet Pairwise (s: seq<'T>) : seq<'T * 'T> =\n    Seq.windowed 2 s\n    |> Seq.map (fun x -> (x.[0], x.[1]))\n\n[<Name \"pick\">]\nlet Pick p (s: seq<_>) =\n    match Seq.tryPick p s with\n    | Some x -> x\n    | None   -> failwith \"KeyNotFoundException\"\n\n[<Name \"readOnly\">]\nlet ReadOnly (s: seq<'T>) : seq<'T> =\n    Enumerable.Of (fun () -> Enumerator.Get s)\n\n[<Name \"reduce\">]\nlet Reduce (f: 'T -> 'T -> 'T) (source: seq<'T>) : 'T =\n    use e = Enumerator.Get source\n    if not (e.MoveNext()) then\n        failwith \"The input sequence was empty\"\n    let mutable r = e.Current\n    while e.MoveNext() do\n        r <- f r e.Current\n    r\n\n[<Name \"scan\">]\nlet Scan<'T,'S> (f: 'S -> 'T -> 'S) (x: 'S) (s: seq<'T>) : seq<'S> =\n    Enumerable.Of <| fun () ->\n        let en = Enumerator.Get s\n        Enumerator.NewDisposing false (fun _ -> en.Dispose()) <| fun e ->\n            if e.State then\n                if en.MoveNext() then\n                    e.Current <- f e.Current en.Current\n                    true\n                else\n                    false\n            else\n                e.Current <- x\n                e.State <- true\n                true\n\n[<Inline \"[$x]\">]\n[<Name \"singleton\">]\nlet Singleton<'T> (x: 'T) = X<seq<'T>>\n\n[<Name \"skip\">]\nlet Skip (n: int) (s: seq<'T>) : seq<'T> =\n    Enumerable.Of (fun () ->\n        let o = Enumerator.Get s\n        Enumerator.NewDisposing true (fun _ -> o.Dispose()) (fun e ->\n            if e.State then\n                for i = 1 to n do\n                    if not (o.MoveNext()) then\n                        InsufficientElements()\n                e.State <- false\n            if o.MoveNext() then\n                e.Current <- o.Current\n                true\n            else\n                false))\n\n[<Name \"skipWhile\">]\nlet SkipWhile (f: 'T -> bool) (s: seq<'T>) : seq<'T> =\n    Enumerable.Of (fun () ->\n        let o = Enumerator.Get s\n        Enumerator.NewDisposing true (fun _ -> o.Dispose()) (fun e ->\n            if e.State then\n                let mutable go = true\n                let mutable empty = false\n                while go do\n                    if o.MoveNext() then\n                        if not (f o.Current) then go <- false \n                    else \n                        go <-false\n                        empty <- true\n                e.State <- false\n                if empty then \n                    false \n                else\n                    e.Current <- o.Current\n                    true\n            else\n                if o.MoveNext() then\n                    e.Current <- o.Current\n                    true\n                else\n                    false))\n\n[<Name \"sort\">]\nlet Sort<'T when 'T : comparison> (s: seq<'T>) =\n    Seq.sortBy id s\n\n[<Name \"sortBy\">]\nlet SortBy<'T, 'U when 'U: comparison>\n        (f: 'T -> 'U) (s: seq<'T>) : seq<'T> =\n    Seq.delay (fun () ->\n        let array = Array.ofSeq s\n        Array.sortInPlaceBy f array\n        array :> _)\n\n[<Name \"sortByDescending\">]\nlet SortByDescending<'T, 'U when 'U: comparison>\n        (f: 'T -> 'U) (s: seq<'T>) : seq<'T> =\n    Seq.delay (fun () ->\n        let array = Array.ofSeq s\n        ArraySortInPlaceByDescending f array\n        array :> _)\n\n[<Name \"sortDescending\">]\nlet SortDescending<'T when 'T : comparison> (s: seq<'T>) =\n    SortByDescending id s\n\n[<Name \"sum\">]\nlet Sum<'T> (s: seq<'T>) : 'T =\n    box (Seq.fold (fun s x -> s + (box x :?> _)) 0. s) :?> _\n\n[<Name \"sumBy\">]\nlet SumBy<'T,'U> (f: 'T -> 'U) (s: seq<'T>) : 'U =\n    box (Seq.fold (fun s x -> s + (box (f x) :?> _)) 0. s) :?> _\n\n[<Name \"take\">]\nlet Take (n: int) (s: seq<'T>) : seq<'T> =\n    if n < 0 then\n        InputMustBeNonNegative()\n    Enumerable.Of (fun () ->\n        let e = ref (Enumerator.Get s)\n        Enumerator.NewDisposing 0 (fun _ -> safeDispose !e) (fun o ->\n            o.State <- o.State + 1\n            if o.State > n then false else\n            let en = !e\n            if en = null then InsufficientElements()\n            elif en.MoveNext() then\n                o.Current <- en.Current\n                if o.State = n then\n                    en.Dispose()\n                    e := null\n                true\n            else\n                en.Dispose()\n                e := null\n                InsufficientElements()\n        )\n    )\n\n[<Name \"takeWhile\">]\nlet TakeWhile (f: 'T -> bool) (s: seq<'T>) : seq<'T> =\n    seq {\n        use e = Enumerator.Get s\n        while e.MoveNext() && f e.Current do\n            yield e.Current\n    }\n\n[<Inline>]\nlet ToArray (s: seq<'T>) =\n    Array.ofSeq s\n\n[<Inline>]\nlet ToList (s: seq<'T>) = List.ofSeq s\n\n[<Name \"truncate\">]\nlet Truncate (n: int) (s: seq<'T>) : seq<'T> =\n    seq {\n        use e = Enumerator.Get s\n        let i = ref 0\n        while e.MoveNext() && !i < n do\n            incr i\n            yield e.Current\n    }\n\n[<Name \"tryFind\">]\nlet TryFind ok (s: seq<_>) =\n    use e = Enumerator.Get s\n    let mutable r = None\n    while r.IsNone && e.MoveNext() do\n        let x = e.Current\n        if ok x then\n            r <- Some x\n    r\n\n[<Inline>]\nlet TryFindBack ok (s: seq<_>) =\n    ArrayTryFindBack ok (Array.ofSeq s) \n\n[<Inline>]\nlet TryHead (s: seq<'T>) = SeqTryHead s\n\n[<Inline>]\nlet TryItem i (s: seq<'T>) = SeqTryItem i s\n\n[<Inline>]\nlet TryLast (s: seq<'T>) =  SeqTryLast s\n\n[<Name \"findBack\">]\nlet FindBack p (s: seq<_>) =\n    match TryFindBack p s with\n    | Some x -> x\n    | None   -> failwith \"KeyNotFoundException\"\n\n[<Name \"tryFindIndex\">]\nlet TryFindIndex ok (s: seq<_>) =\n    use e = Enumerator.Get s\n    let mutable loop = true\n    let mutable i = 0\n    while loop && e.MoveNext() do\n        let x = e.Current\n        if ok x then\n            loop <- false\n        else\n            i <- i + 1\n    if loop then None else Some i\n\n[<Inline>]\nlet TryFindIndexBack ok (s: seq<_>) =\n    ArrayTryFindIndexBack ok (Array.ofSeq s) \n\n[<Name \"findIndexBack\">]\nlet FindIndexBack p (s: seq<_>) =\n    match TryFindIndexBack p s with\n    | Some x -> x\n    | None   -> failwith \"KeyNotFoundException\"\n\n[<Name \"tryPick\">]\nlet TryPick f (s: seq<_>) =\n    use e = Enumerator.Get s\n    let mutable r = None\n    while r = None && e.MoveNext() do\n        r <- f e.Current\n    r\n\n[<Name \"unfold\">]\nlet Unfold<'S, 'T> (f: 'S -> option<'T * 'S>) (s: 'S) : seq<'T> =\n    Enumerable.Of <| fun () ->\n        Enumerator.New s <| fun e ->\n            match f e.State with\n            | Some (t, s) ->\n                e.Current <- t\n                e.State  <- s\n                true\n            | None ->\n                false\n\n[<Name \"windowed\">]\nlet Windowed (windowSize: int) (s: seq<'T>) : seq<'T []> =\n    if windowSize <= 0 then\n        failwith \"The input must be positive.\"\n    seq {\n        use e = Enumerator.Get s\n        let q = new System.Collections.Generic.Queue<'T>()\n        while q.Count < windowSize && e.MoveNext() do\n            q.Enqueue e.Current\n        if q.Count = windowSize then\n            yield q.ToArray()\n            while e.MoveNext() do\n                ignore (q.Dequeue())\n                q.Enqueue e.Current\n                yield q.ToArray()\n    }\n\n[<Name \"zip\">]\nlet Zip (s1: seq<'T>) (s2: seq<'U>) =\n    Seq.map2 (fun x y -> x, y) s1 s2\n\n[<Name \"map3\">]\nlet Map3 f (s1: seq<_>) (s2: seq<_>) (s3: seq<_>) =\n    Enumerable.Of <| fun () ->\n        let e1 = Enumerator.Get s1\n        let e2 = Enumerator.Get s2\n        let e3 = Enumerator.Get s3\n        Enumerator.NewDisposing () (fun _ -> e1.Dispose(); e2.Dispose(); e3.Dispose()) <| fun e ->\n            if e1.MoveNext() && e2.MoveNext() && e3.MoveNext() then\n                e.Current <- f e1.Current e2.Current e3.Current\n                true\n            else\n                false\n\n[<Name \"zip3\">]\nlet Zip3 (s1: seq<'T>) (s2: seq<'U>) (s3: seq<'V>) : seq<'T * 'U * 'V> =\n    Map3 (fun x y z -> x, y, z) s1 s2 s3\n\n[<Name \"fold2\">]\nlet Fold2<'T1,'T2,'S> (f: 'S -> 'T1 -> 'T2 -> 'S)\n                        (s: 'S)\n                        (s1: seq<'T1>)\n                        (s2: seq<'T2>) : 'S =\n    Array.fold2 f s (Array.ofSeq s1) (Array.ofSeq s2)\n\n[<Name \"foldBack\">]\nlet FoldBack f (s: seq<_>) state =\n    Array.foldBack f (Array.ofSeq s) state\n\n[<Name \"foldBack2\">]\nlet FoldBack2 f (s1: seq<_>) (s2: seq<_>) s =\n    Array.foldBack2 f (Array.ofSeq s1) (Array.ofSeq s2) s\n\n[<Name \"iteri2\">]\nlet IterateIndexed2 f (s1: seq<_>) (s2: seq<_>) =\n    let mutable i = 0\n    use e1 = Enumerator.Get s1\n    use e2 = Enumerator.Get s2\n    while e1.MoveNext() && e2.MoveNext() do\n        f i e1.Current e2.Current\n        i <- i + 1\n\n[<Name \"mapi2\">]\nlet MapIndexed2 f (s1: seq<_>) (s2: seq<_>) =\n    Map3 f (Seq.initInfinite id) s1 s2\n\n[<Name \"mapFold\">]\nlet MapFold<'T,'S,'R> f zero s =\n    ArrayMapFold<'T,'S,'R> f zero (Seq.toArray s)\n    |> As<seq<'R> * 'S>\n\n[<Name \"mapFoldBack\">]\nlet MapFoldBack<'T,'S,'R> f s zero =\n    ArrayMapFoldBack<'T,'S,'R> f (Seq.toArray s) zero\n    |> As<seq<'R> * 'S>\n\n[<Name \"permute\">]\nlet Permute f (s: seq<_>) =\n    Seq.delay (fun () -> Seq.ofArray (Array.permute f (Array.ofSeq s)))\n\n[<Name \"reduceBack\">]\nlet ReduceBack f (s: seq<_>) =\n    Array.reduceBack f (Array.ofSeq s)\n\n[<Name \"replicate\">]\nlet Replicate size value =\n    if size < 0 then InputMustBeNonNegative()\n    seq { for i in 0 .. size - 1 -> value }\n\n[<Name \"rev\">]\nlet Reverse (s: seq<'T>) =\n    Seq.delay (fun () -> Array.rev (Seq.toArray s) |> Array.toSeq)\n    \n[<Name \"scanBack\">]\nlet ScanBack f (l: seq<_>) s =\n    Seq.delay (fun () -> Seq.ofArray (Array.scanBack f (Array.ofSeq l) s))\n\n[<Name \"indexed\">]\nlet Indexed (s : seq<'T>) : seq<int * 'T> =\n    Seq.mapi (fun a b -> (a, b)) s\n\n[<Name \"sortWith\">]\nlet SortWith f (s: seq<_>) =\n    Seq.delay (fun () -> \n        let a = Array.ofSeq s\n        Array.sortInPlaceWith f a\n        Seq.ofArray a)\n\n[<Name \"tail\">]\nlet Tail<'T> (s : seq<'T>) : seq<'T> =\n    Seq.skip 1 s\n\n[<Inline>]\nlet Where (predicate : 'T -> bool) (s : seq<'T>) : seq<'T> =\n    Filter predicate s\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.Name \"Stack\">]\nmodule private WebSharper.StackProxy\n\nopen WebSharper.JavaScript\n\n[<Inline \"$arr.splice($offset,$len)\">]\nlet splice (arr: obj) (offset: int) (len: int) = X<unit>\n\n[<JavaScript>]\nlet Clear (stack: obj) =\n    splice stack 0 (stack :?> obj []).Length\n\n[<JavaScript>]\nlet Contains (stack: obj) (el: 'T) =\n    Seq.exists ((=) el) (stack :?> 'T[])\n    \n[<JavaScript>]\nlet CopyTo (stack: obj) (array: 'T[]) (index: int) =\n    Array.blit array 0 array index (stack :?> 'T[]).Length\n\n[<Proxy(typeof<System.Collections.Generic.Stack<_>>)>]\n[<Name \"WebSharper.Stack\">]\ntype private StackProxy<'T when 'T : equality> =\n\n    [<Inline \"[].concat($s).reverse()\">]\n    private new (s: 'T []) = {}\n\n    [<Inline \"[]\">]\n    new () = {}\n\n    [<Inline>]\n    private new (s: seq<'T>) = StackProxy (Array.ofSeq s)\n\n    member this.Count with [<Inline \"$this.length\">] get () = X<int>\n\n    [<Inline>]\n    member this.Clear() = Clear this\n\n    [<Inline>]\n    member this.Contains(x: 'T) : bool = Contains this x\n\n    [<Inline>]\n    member this.CopyTo(array: 'T [], index) = CopyTo this array index\n\n    [<Inline \"$this[0]\">]\n    member this.Peek() = X<'T>\n\n    [<Inline \"$this.shift()\">]\n    member this.Pop() = X<'T>\n\n    [<Inline \"$this.unshift($x)\">]\n    member this.Push(x: 'T) = X<unit>\n\n    [<Inline \"$this.slice(0)\">]\n    member this.ToArray() = X<'T[]>\n\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.Name \"Strings\">]\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Core.StringModule, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.StringProxy\n\nopen WebSharper.JavaScript\n\nmodule M = WebSharper.Macro\n\nlet Compare (x: string) (y: string) = compare x y\n\nlet CopyTo (s: string) (o: int) (d: char []) (off: int) (ct: int) =\n    Array.blit (s.ToCharArray()) o d off ct\n\n[<Direct \"$x.substring($x.length - $s.length) == $s\">]\nlet EndsWith (x: string) (s: string) = X<bool>\n\n[<Direct \"$s.indexOf($c,$i)\">]\nlet IndexOf (s: string) (c: char) (i: int) = X<int>\n\n[<Direct \"$x.substring(0,$index-1)+$s+$x.substring($index)\">]\nlet Insert (x: string) (index: int) (s: string) = X<string>\n\n[<Direct \"$x == null || $x == ''\">]\nlet IsNullOrEmpty (x: string) = X<bool>\n\n[<Direct \"\"\"$x == null || /^\\s*$/.test($x)\"\"\">]\nlet IsNullOrWhiteSpace (x: string) = X<bool>\n\n[<Direct \"$s.lastIndexOf($c,$i)\">]\nlet LastIndexOf (s: string) (c: char) (i: int) = X<int>\n\n[<Direct \"$n>$s.length?Array($n-$s.length+1).join($c)+$s:$s\">]\nlet PadLeftWith (s: string) (n: int) (c: char) = X<string>\n\nlet PadLeft (s: string) (n: int) =\n    PadLeftWith s n ' '\n\n[<Direct \"$n>$s.length?$s+Array($n-$s.length+1).join($c):$s\">]\nlet PadRightWith (s: string) (n: int) (c: char) = X<string>\n\nlet PadRight (s: string) (n: int) =\n    PadRightWith s n ' '\n\n[<Direct \"$x.substring(0,$ix) + $x.substring($ix+$ct)\">]\nlet Remove (x: string) (ix: int) (ct: int) = X<string>\n\n[<Direct \"$string.replace($search,$replace)\">]\nlet ReplaceOnce string search replace = X<string>\n\nlet Replace (subject: string) (search: string) (replace: string) =\n    let rec replaceLoop (subj: string) =\n        let index = subj.IndexOf(search)\n        if index <> -1 then\n            let replaced = ReplaceOnce subj search replace\n            let nextStartIndex = index + replace.Length\n            (replaced.Substring(0, index + replace.Length)) +\n                (replaceLoop (replaced.Substring(nextStartIndex)))\n        else subj\n    replaceLoop subject\n\nlet ReplaceChar (s: string) (oldC: char) (newC: char) =\n    Replace s (string oldC) (string newC)\n\n[<Direct \"$s.substr($ix,$ct)\">]\nlet Substring (s: string) (ix: int) (ct: int) = X<string>\n\n[<Direct \"$t.substring(0,$s.length) == $s\">]\nlet StartsWith (t: string) (s: string) = X<bool>\n\nlet ToCharArray (s: string) = Array.init s.Length (fun x -> s.[x])\n\nlet ToCharArrayRange (s: string) (startIndex: int) (length: int) =\n    Array.init length (fun i -> s.[startIndex + i])\n\n[<Direct @\"$s.replace(/^\\s+/,'').replace(/\\s+$/,'')\">]\nlet Trim (s: string) = X<string>\n\n[<Direct @\"$s.replace(/^\\s+/,'')\">]\nlet TrimStartWS (s: string) = X<string>\n\nlet TrimStart (s: string) (t: char[]) =\n    if t = null || Array.isEmpty t then\n        TrimStartWS s\n    else\n        let mutable i = 0\n        let mutable go = true\n        while i < s.Length && go do\n            let c = s.[i]\n            if t |> Array.exists ((=) c) then\n                i <- i + 1 \n            else go <- false\n        s.Substring(i)\n\n[<Direct @\"$s.replace(/\\s+$/,'')\">]\nlet TrimEndWS (s: string) = X<string>\n\nlet TrimEnd (s: string) (t: char[]) =\n    if t = null || Array.isEmpty t then\n        TrimEndWS s\n    else \n        let mutable i = s.Length - 1\n        let mutable go = true\n        while i >= 0 && go do\n            let c = s.[i]\n            if t |> Array.exists ((=) c) then\n                i <- i - 1 \n            else go <- false\n        s.Substring(0, i + 1)\n\n[<Direct \"$values.join($sep)\">]\nlet Join (sep: string) (values: string []) = X<string>\n\n[<Direct \"$str.split($pat)\">]\nlet SplitWith (str: string) (pat: obj) = X<string[]>\n\n[<Inline \"new RegExp($pat)\">]\nlet MakeRegexp (pat: string) = X<obj>\n\n[<Direct @\"$s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&')\">]\nlet RegexEscape (s: string) = X<string>\n\nlet Split (s: string) (pat: obj) (opts: System.StringSplitOptions) =\n    let res = SplitWith s pat\n    if opts ===. System.StringSplitOptions.RemoveEmptyEntries then\n        Array.filter (fun x -> x !==. \"\") res\n    else\n        res\n\nlet SplitChars (s: string) (sep: char[]) (opts: System.StringSplitOptions) =\n    let re = \"[\" + RegexEscape (new System.String(sep)) + \"]\"\n    Split s (MakeRegexp re) opts\n\nlet SplitStrings (s: string) (sep: string[]) (opts: System.StringSplitOptions) =\n    let re = String.concat \"|\" (Array.map RegexEscape sep)\n    Split s (MakeRegexp re) opts\n\nlet Filter f (s: string) =\n    System.String.Concat(s |> Seq.choose (fun c -> if f c then Some (string c) else None) |> Array.ofSeq)\n\n[<Inline \"$text.replace($pattern, $replace)\">]\nlet ReplaceString (pattern: RegExp) (replace: 'obj) (text: string) = X<string>\n\nlet SFormat (format: string) (args: obj[]) =\n    let pattern = RegExp(\"{(0|[1-9]\\d*)(?:,(-?[1-9]\\d*|0))?(?::(.*?))?}\", \"g\")\n    format\n    |> ReplaceString pattern (FuncWithArgs(fun (_, i, w) ->\n        let r = string args.[JS.Plus i]\n\n        if w <> JS.Undefined then\n            let w1 = JS.Plus w\n            let w2 = abs w1\n\n            if w2 > r.Length then\n                if w1 > 0 then r.PadLeft(w2)\n                else r.PadRight(w2)\n            else r\n        else r\n    ))\n\n[<Proxy(typeof<string>)>]\ntype private StringProxy =\n\n    [<Inline \"''\">]\n    new () = {}\n\n    [<Inline \"$chars.join('')\">]\n    new (chars: char []) = {}\n\n    member this.Chars  with [<Inline \"$this[$pos]\">]\n                            get (pos: int) = X<char>\n\n    [<Inline \"$this\">]\n    member this.Clone() = this :> obj\n\n    [<Inline>]\n    static member Compare(x: string, y: string) =\n        Unchecked.compare x y\n\n    [<Inline>]\n    member this.CompareTo(s: string) =\n        Unchecked.compare (this :> obj) (s :> obj)\n\n    [<Inline>]\n    static member Concat(strings: string seq) =\n        Join \"\" (Array.ofSeq strings)\n\n    [<Inline \"$strings.join('')\">]\n    static member Concat([<System.ParamArray>] strings: string[]) = X<string>\n\n    [<Inline \"$this.indexOf($s) != -1\">]\n    member this.Contains(s: string) = X<bool>\n\n    [<Inline>]\n    member this.CopyTo(s: int, d: char [], off: int, ct: int) =\n        CopyTo (As this) s d off ct\n\n    static member Empty with [<Inline \"''\">] get () = X<string>\n\n    [<Inline>]\n    member this.EndsWith(other: string) = EndsWith (As this) other\n\n    [<Inline \"$x === $y\">]\n    static member Equals(x: string, y: string) = X<bool>\n\n    [<Inline>]\n    member this.GetEnumerator() = Enumerator.Get (unbox<seq<char>> this) |> As<System.CharEnumerator>\n\n    [<Inline \"$this.indexOf($s)\">]\n    member this.IndexOf(s: string) = X<int>\n\n    [<Inline \"$this.indexOf($c)\">]\n    member this.IndexOf(c: char) = X<int>\n\n    [<Inline \"$this.indexOf($s,$i)\">]\n    member this.IndexOf(s: string, i: int) = X<int>\n\n    [<Inline>]\n    member this.IndexOf(c: char, i: int) = IndexOf (As this) c i\n\n    [<Inline>]\n    static member IsNullOrEmpty(x: string) = IsNullOrEmpty x\n\n    [<Inline>]\n    static member IsNullOrWhiteSpace(x: string) = IsNullOrWhiteSpace x\n\n    member this.Item\n        with    [<Inline \"$this[$pos]\">]\n                get (pos: int) = X<char>\n\n    [<Inline>]\n    static member Join(sep: string, values: string seq) =\n        Join sep (Array.ofSeq values)\n\n    [<Inline>]\n    static member Join(sep: string, [<System.ParamArray>] values: string[]) =\n        Join sep values\n\n    [<Inline \"$this.lastIndexOf($s)\">]\n    member this.LastIndexOf(s: string) = X<int>\n\n    [<Inline \"$this.lastIndexOf($c)\">]\n    member this.LastIndexOf(c: char) = X<int>\n\n    [<Inline \"$this.lastIndexOf($s,$i)\">]\n    member this.LastIndexOf(s: string, i: int) = X<int>\n\n    [<Inline>]\n    member this.LastIndexOf(c: char, i: int) =\n        LastIndexOf (As this) c i\n\n    member this.Length with [<Inline \"$this.length\">]\n                            get () = X<int>\n\n    [<Inline>]\n    member this.PadLeft(i: int) =\n        PadLeft (As this) i\n\n    [<Inline>]\n    member this.PadLeft(i: int, c: char) =\n        PadLeftWith (As this) i c\n\n    [<Inline>]\n    member this.PadRight(i: int) =\n        PadRight (As this) i\n\n    [<Inline>]\n    member this.PadRight(i: int, c: char) =\n        PadRightWith (As this) i c\n\n    [<Inline \"$this.substring(0,$ix)\">]\n    member this.Remove(ix: int) = X<string>\n\n    [<Inline>]\n    member this.Remove(ix: int, count: int) = Remove (As this) ix count\n\n    [<Inline>]\n    member this.ToCharArray() = ToCharArray (As this)\n\n    [<Inline>]\n    member this.Replace(subj: string, repl: string) =\n        Replace (As this) subj repl\n\n    [<Inline>]\n    member this.Replace(subj: char, repl: char) =\n        ReplaceChar (As this) subj repl\n\n    [<Inline>]\n    member this.Split([<System.ParamArray>] sep: char[]) =\n        SplitChars (As this) sep  System.StringSplitOptions.None\n\n    [<Inline>]\n    member this.Split(sep: char[], opts: System.StringSplitOptions) =\n        SplitChars (As this) sep opts\n\n    [<Inline>]\n    member this.Split(sep: string[], opts: System.StringSplitOptions) =\n        SplitStrings (As this) sep opts\n\n    [<Inline>]\n    member this.StartsWith(s: string) =\n        StartsWith (As this) s\n\n    [<Inline \"$this.substring($ix)\">]\n    member this.Substring(ix: int) = X<string>\n\n    [<Inline>]\n    member this.Substring(ix: int, ct: int) =\n        Substring (As this) ix ct\n\n    [<Inline>]\n    member this.ToCharArray(i: int, l: int) =\n        ToCharArrayRange (As this) i l\n\n    [<Inline \"$this.toLowerCase()\">]\n    member this.ToLower() = X<string>\n\n    [<Inline \"$this.toUpperCase()\">]\n    member this.ToUpper() = X<string>\n\n    [<Inline>]\n    member this.Trim() = Trim (As this)\n\n    [<Inline>]\n    member this.TrimStart(t: char[]) = TrimStart (As this) t\n\n    [<Inline>]\n    member this.TrimEnd(t: char[]) = TrimEnd (As this) t\n\n    [<Inline \"$a + $b\">]\n    static member (+) (a: string, b: string) = X<string>\n\n    [<Inline>]\n    static member (+) (a: obj, b: string) = string a + b \n\n    [<Inline>]\n    static member (+) (a: string, b: obj) = a + string b\n\n    [<Inline \"$a === $b\">]\n    static member op_Equality(a: string, b: string) = X<bool>\n\n    [<Inline \"$a !== $b\">]\n    static member op_Inequality(a: string, b: string) = X<bool>\n\n    [<Macro(typeof<M.StringFormat>)>]\n    [<Inline>]\n    static member Format(format: string, [<System.ParamArray>] arguments: obj []) = SFormat format arguments\n\n    [<Macro(typeof<M.StringFormat>)>]\n    [<Inline>]\n    static member Format(format: string, arg0: obj): string = SFormat format [|arg0|]\n\n    [<Macro(typeof<M.StringFormat>)>]\n    [<Inline>]\n    static member Format(format: string, arg0: obj, arg1: obj): string = SFormat format [|arg0; arg1|]\n\n    [<Macro(typeof<M.StringFormat>)>]\n    [<Inline>]\n    static member Format(format: string, arg0: obj, arg1: obj, arg2: obj): string = SFormat format [|arg0; arg1; arg2|]\n\nlet protect (s : string) =\n    if s = null then \"\" else s\n\n[<Inline \"$strings.join($sep)\">]\nlet join (strings: string[]) (sep: string) = X<string>\n\n[<Name \"collect\">]\nlet Collect (f: char -> string) (s: string) : string =\n    System.String.Concat(Array.init s.Length (fun i -> f s.[i]))\n\n[<Name \"concat\">]\nlet Concat (separator: string) (strings: seq<string>) : string =\n    join (Seq.toArray strings) separator\n\n[<Name \"exists\">]\nlet Exists (f: char -> bool) (s: string) : bool =\n    Seq.exists f (protect s)\n\n[<Name \"forall\">]\nlet ForAll (f: char -> bool) (s: string) : bool =\n    Seq.forall f (protect s)\n\n[<Name \"init\">]\nlet Initialize (count: int) (f: int -> string) : string =\n    System.String.Concat(Array.init count f)\n\n[<Name \"iter\">]\nlet Iterate (f: char -> unit) (s: string) : unit =\n    Seq.iter f (protect s)\n\n[<Name \"iteri\">]\nlet IterateIndexed (f: int -> char -> unit) (s: string) : unit =\n    Seq.iteri f (protect s)\n\n[<Name \"length\">]\nlet Length (s: string) : int =\n    (protect s).Length\n\n[<Name \"map\">]\nlet Map (f: char -> char) (s: string) : string =\n    Collect (fun x -> string (f x)) (protect s)\n\n[<Name \"mapi\">]\nlet MapIndexed (f: int -> char -> char) (s: string) : string =\n    System.String.Concat (Seq.toArray (Seq.mapi (fun i x -> string (f i x)) s))\n\n[<Name \"replicate\">]\nlet Replicate (count: int) (s: string) : string =\n    Initialize count (fun _ -> s)\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen WebSharper.JavaScript\n\nopen System.Threading\nopen System.Threading.Tasks\n\n[<Proxy(typeof<Task>); Name \"Task\">]\ntype private TaskProxy(action: System.Action, token: CT, status, exc) =\n    [<Name \"status\">]\n    let mutable status = status\n    [<Name \"continuations\">]\n    let continuations = [||] : TaskProxy[]\n    [<Name \"exc\">]\n    let mutable exc = exc : System.AggregateException\n\n    abstract Execute : unit -> unit\n    default this.Execute() = action.Invoke()\n\n    member this.Exception = exc\n\n    member this.IsCanceled = \n        status = TaskStatus.Canceled\n\n    member this.IsCompleted = \n        status = TaskStatus.RanToCompletion || status = TaskStatus.Faulted || status = TaskStatus.Canceled\n\n    member this.IsFaulted =\n        status = TaskStatus.Faulted\n\n    member this.Status = status\n\n    new (action) = TaskProxy(action, CT.None, TaskStatus.Created, null)\n\n    new (action, ct) = TaskProxy(action, ct, TaskStatus.Created, null)\n    \n    member this.OnCompleted(cont : unit -> unit) =\n        if this.IsCompleted then \n            cont()\n        else \n            if this.Status = TaskStatus.Created then this.Start()\n            this.ContinueWith(fun (_: Task) -> cont()) |> ignore\n\n    member this.RunContinuations() =\n        for c in continuations do\n            c.StartContinuation()    \n\n    member this.ContinueWith(action: System.Action<Task>) =\n        this.ContinueWith(action, CT.None)\n\n    member this.ContinueWith(action: System.Action<Task>, ct) =\n        let res = TaskProxy((fun () -> action.Invoke (As<Task> this)), ct, TaskStatus.WaitingForActivation, null)\n        if this.IsCompleted then\n            res.StartContinuation()     \n        else\n            continuations.JS.Push res |> ignore\n        As<Task> res\n\n    [<Inline>]\n    member this.ContinueWith(func: System.Func<Task,'T>) =\n        this.ContinueWith(func, CT.None)\n\n    member this.ContinueWith(func: System.Func<Task,'T>, ct) =\n        let res = TaskProxy<'T>((fun () -> func.Invoke (As<Task> this)), ct, TaskStatus.WaitingForActivation, null, JS.Undefined)\n        if this.IsCompleted then\n            res.StartContinuation()     \n        else\n            continuations.JS.Push res |> ignore\n        As<Task<'T>> res\n\n    member this.StartContinuation() =\n        if status = TaskStatus.WaitingForActivation then\n            status <- TaskStatus.WaitingToRun\n            Concurrency.fork (fun () -> \n                if status = TaskStatus.WaitingToRun then\n                    status <- TaskStatus.Running\n                    try\n                        this.Execute()\n                        status <- TaskStatus.RanToCompletion\n                    with e ->\n                        exc <- System.AggregateException(e)\n                        status <- TaskStatus.Faulted\n                    this.RunContinuations()\n            )\n\n    member this.Start() =\n        if status = TaskStatus.Created then\n            status <- TaskStatus.WaitingToRun\n            Concurrency.fork (fun () -> \n                status <- TaskStatus.Running\n                try\n                    this.Execute()\n                    status <- TaskStatus.RanToCompletion\n                with\n                | :? OCE as e when e.CancellationToken = token ->\n                    Console.Log(\"Task cancellation caught:\", e)\n                    exc <- System.AggregateException(e)\n                    status <- TaskStatus.Canceled\n                | e ->\n                    Console.Log(\"Task error caught:\", e)\n                    exc <- System.AggregateException(e)\n                    status <- TaskStatus.Faulted\n                this.RunContinuations()\n            )\n        else\n            invalidOp \"Task not in initial state\"\n        \n    static member FromCanceled ct = \n        As<Task> (TaskProxy(null, ct, TaskStatus.Canceled, null)) \n\n    static member FromCanceled(ct: CT) = \n        As<Task<_>> (TaskProxy<_>(null, ct, TaskStatus.Canceled, null, As null)) \n\n    static member FromException (exc: exn) =\n        As<Task> (TaskProxy(null, CT.None, TaskStatus.Faulted, System.AggregateException(exc)))\n\n    static member FromException (exc: exn) =\n        As<Task<_>> (TaskProxy<_>(null, CT.None, TaskStatus.Faulted, System.AggregateException(exc), As null))\n\n    static member FromResult (res: 'T) = \n        As<Task<'T>> (TaskProxy<'T>(null, CT.None, TaskStatus.RanToCompletion, null, res)) \n\n    [<Inline>]\n    static member Run(action : System.Action) =\n       TaskProxy.Run(action, CT.None)\n        \n    static member Run(action : System.Action, ct) =\n        let res = TaskProxy(action, ct, TaskStatus.Created, null)\n        res.Start()\n        As<Task> res\n\n    [<Inline>]\n    static member Run(func : System.Func<Task>) =\n        TaskProxy.Run(func, CT.None)\n\n    static member Run(func : System.Func<Task>, ct: CT) =\n        let task = func.Invoke()\n        if ct.IsCancellationRequested then TaskProxy.FromCanceled ct : Task else\n        if task.Status = TaskStatus.Created then\n            task.Start()\n        task\n\n    [<Inline>]\n    static member Run(func : System.Func<'T>) =\n        TaskProxy.Run(func, CT.None)\n\n    static member Run(func : System.Func<'T>, ct) =\n        let res = TaskProxy<'T>(func, ct, TaskStatus.Created, null, JS.Undefined)\n        res.Start()\n        As<Task<'T>> res   \n\n    [<Inline>]\n    static member Run(func : System.Func<Task<'T>>) =\n        TaskProxy.Run(func, CT.None)\n\n    static member Run(func : System.Func<Task<'T>>, ct: CT) =\n        let task = func.Invoke()\n        if ct.IsCancellationRequested then TaskProxy.FromCanceled<'T> ct else\n        if task.Status = TaskStatus.Created then\n            task.Start()\n        task\n\n    static member Delay(time: int) =   \n        Async.StartAsTask (Async.Sleep time) :> Task\n             \n    static member Delay(time: int, ct) =        \n        Async.StartAsTask (Async.Sleep time, cancellationToken = ct) :> Task\n\n    [<Inline>]\n    static member Delay(time: System.TimeSpan) =        \n        TaskProxy.Delay(As<int> time)\n             \n    [<Inline>]\n    static member Delay(time: System.TimeSpan, ct) =        \n        TaskProxy.Delay(As<int> time, ct)\n\n    static member WhenAny(tasks: Task[]) =\n        let tcs = System.Threading.Tasks.TaskCompletionSource<_>()\n        for t in tasks do t.ContinueWith (fun t -> tcs.TrySetResult t |> ignore) |> ignore\n        tcs.Task\n            \n    [<Inline>]                         \n    static member WhenAny(tasks: seq<Task>) = TaskProxy.WhenAny(Array.ofSeq tasks)\n\n    static member WhenAny(tasks: Task<'T>[]) =\n        let tcs = System.Threading.Tasks.TaskCompletionSource<Task<'T>>()\n        for t in tasks do t.ContinueWith (fun t -> tcs.TrySetResult t |> ignore) |> ignore\n        tcs.Task\n            \n    [<Inline>]                         \n    static member WhenAny(tasks: seq<Task<'T>>) = TaskProxy.WhenAny(Array.ofSeq tasks)\n\n    static member WhenAll(tasks: Task[]) =\n        let target = tasks.Length\n        let completed = ref 0\n        let tcs = System.Threading.Tasks.TaskCompletionSource<_>()\n        for i = 0 to target - 1 do\n            tasks.[i].ContinueWith (fun t -> \n                if t.IsFaulted then\n                    tcs.TrySetException t.Exception |> ignore\n                elif t.IsCanceled then\n                    tcs.TrySetCanceled() |> ignore\n                else\n                    incr completed\n                    if !completed = target then tcs.TrySetResult() |> ignore \n            ) |> ignore\n        tcs.Task :> Task\n\n    [<Inline>]                         \n    static member WhenAll(tasks: seq<Task>) = TaskProxy.WhenAll(Array.ofSeq tasks)\n\n    static member WhenAll(tasks: Task<'T>[]) =\n        let target = tasks.Length\n        let completed = ref 0\n        let results = JavaScript.Array(target)\n        let tcs = System.Threading.Tasks.TaskCompletionSource<_>()\n        for i = 0 to target - 1 do\n            tasks.[i].ContinueWith (fun (t: Task<'T>) -> \n                if t.IsFaulted then\n                    tcs.TrySetException t.Exception |> ignore\n                elif t.IsCanceled then\n                    tcs.TrySetCanceled() |> ignore\n                else\n                    incr completed\n                    results.[i] <- t.Result\n                    if !completed = target then tcs.SetResult results.Self\n            ) |> ignore\n        tcs.Task\n\n    [<Inline>]                         \n    static member WhenAll(tasks: seq<Task<'T>>) = TaskProxy.WhenAll(Array.ofSeq tasks)\n\n//    // TODO : return type System.Runtime.CompilerServices.YieldAwaitable \n//    static member Yield() =\n//        Async.Sleep 0 |> Async.StartAsTask  \n\nand [<Proxy(typeof<Task<_>>); Name \"Task1\">] private TaskProxy<'T>(func: System.Func<'T>, token: CT, status, exc, result) =\n    inherit TaskProxy(null, token, status, exc)\n    \n    [<Name \"result\">]\n    let mutable result = result\n\n    member this.Result = result\n\n    override this.Execute () =\n        result <- func.Invoke()\n\n    [<Inline>]\n    member this.ContinueWith(action: System.Action<Task<'T>>) =\n        this.ContinueWith(As<System.Action<Task>> action)\n\n    [<Inline>]\n    member this.ContinueWith(action: System.Action<Task<'T>>, ct) =\n        this.ContinueWith(As<System.Action<Task>> action, ct)\n\n    [<Inline>]\n    member this.ContinueWith<'R>(func: System.Func<Task<'T>, 'R>) =\n        this.ContinueWith(As<System.Func<Task, 'R>> func) \n\n    [<Inline>]\n    member this.ContinueWith<'R>(func: System.Func<Task<'T>, 'R>, ct) =\n        this.ContinueWith(As<System.Func<Task, 'R>> func, ct) \n\n[<Proxy(typeof<TaskCompletionSource<_>>)>]\n[<Name \"TaskCompletionSource\">]\ntype private TaskCompletionSourceProxy<'T>() =\n    let task = new TaskProxy<'T>(null, CT.None, TaskStatus.WaitingForActivation, null, JS.Undefined)\n\n    member this.Task = As<Task<'T>> task\n\n    member this.SetCanceled() =\n        if task.IsCompleted then\n            failwith \"Task already completed.\"\n        task?status <- TaskStatus.Canceled\n        task.RunContinuations()\n\n    member this.SetException(exc: exn) =\n        if task.IsCompleted then\n            failwith \"Task already completed.\"\n        task?status <- TaskStatus.Faulted\n        task?exc <- System.AggregateException(exc)\n        task.RunContinuations()\n\n    member this.SetException(exs : seq<exn>) =\n        this.SetException(System.AggregateException(exs))\n\n    member this.SetResult(res: 'T) =\n        if task.IsCompleted then\n            failwith \"Task already completed.\"\n        task?status <- TaskStatus.RanToCompletion\n        task?result <- res \n        task.RunContinuations()\n\n    member this.TrySetCanceled() =\n        if not task.IsCompleted then\n            task?status <- TaskStatus.Canceled\n            task.RunContinuations()\n            true\n        else false\n\n    member this.TrySetCanceled(ct: CT) =\n        if not task.IsCompleted then\n            task?status <- TaskStatus.Canceled\n            task.RunContinuations()\n            true\n        else false\n\n    member this.TrySetException(exc: exn) =\n        if not task.IsCompleted then\n            task?status <- TaskStatus.Faulted\n            task?exc <- System.AggregateException(exc)\n            task.RunContinuations()\n            true\n        else false\n\n    member this.TrySetException(exs : seq<exn>) =\n        this.TrySetException(System.AggregateException(exs))\n\n    member this.TrySetResult(res: 'T) =        \n        if not task.IsCompleted then\n            task?status <- TaskStatus.RanToCompletion\n            task?result <- res \n            task.RunContinuations()\n            true\n        else false\n    ", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n/// Implements generic comparison, equality and hashing.\n[<WebSharper.Name \"Unchecked\">]\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Core.Operators+Unchecked, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.UncheckedProxy\n\nopen WebSharper.JavaScript\n\n[<Inline \"$a instanceof Array\">]\nlet isArray (a: obj) = X<bool>\n\n[<Inline \"$a instanceof Date\">]\nlet isDate (a: obj) = X<bool>\n\nlet rec compareArrays (a: obj []) (b: obj []) =\n    if a.Length < b.Length   then -1\n    elif a.Length > b.Length then 1\n    else\n        let mutable cmp = 0\n        let mutable i = 0\n        while cmp = 0 && i < a.Length do\n            cmp <- Unchecked.compare a.[i] b.[i]\n            i <- i + 1\n        cmp\n\n[<Inline \"$d.getTime()\">]\nlet getTime (d: obj) : int = X\n\nlet rec compareDates (a: obj) (b: obj) =\n    compare (getTime a) (getTime b)\n\n/// Compares two values generically.\nlet Compare<'T> (a: 'T) (b: 'T) : int =\n    let objCompare (a: obj) (b: obj) =\n        let cmp = ref 0\n        JS.ForEach a (fun k ->\n            if not (JS.HasOwnProperty a k) then\n                false\n            elif not (JS.HasOwnProperty b k) then\n                cmp := 1; true\n            else\n                cmp := Unchecked.compare a?(k) b?(k); !cmp <> 0)\n        if !cmp = 0 then\n            JS.ForEach b (fun k ->\n                if not (JS.HasOwnProperty b k) then\n                    false\n                elif not (JS.HasOwnProperty a k) then\n                    cmp := -1; true\n                else false)\n        !cmp\n    if a ===. b then 0 else\n        match JS.TypeOf a with\n        | JS.Undefined ->\n            match JS.TypeOf b with\n            | JS.Undefined -> 0\n            | _ -> -1\n        | JS.Function ->\n            failwith \"Cannot compare function values.\"\n        | JS.Boolean | JS.Number | JS.String ->\n            if a <. b then -1 else 1\n        | JS.Object ->\n            if a ===. null then -1\n            elif b ===. null then 1\n            elif JS.In \"CompareTo\" a then (As<System.IComparable<_>> a).CompareTo(b)\n            elif JS.In \"CompareTo0\" a then (As<System.IComparable> a).CompareTo(b)\n            elif isArray a && isArray b then compareArrays (As a) (As b)\n            elif isDate a && isDate b then compareDates a b\n            else objCompare (As a) (As b)\n\n/// Produces an undefined value.\n[<Macro(typeof<Macro.DefaultOf>)>]\n[<Inline \"undefined\">]\nlet DefaultOf<'T> = X<'T>\n\nlet arrayEquals (a: obj []) (b: obj []) =\n    if a.Length = b.Length then\n        let mutable eq = true\n        let mutable i = 0\n        while eq && i < a.Length do\n            if not (Unchecked.equals a.[i] b.[i]) then\n                eq <- false\n            i <- i + 1\n        eq\n    else\n        false\n\nlet dateEquals a b =\n    getTime a ===. getTime b\n\n[<Inline \"$a.Equals($b)\">]\nlet private equals (a: obj) (b: obj) = X<bool>\n\n/// Tests if two values are equal.\nlet Equals (a: 'T) (b: 'T) : bool =\n    let objEquals (a: obj) (b: obj) =\n        let eqR = ref true\n        JS.ForEach a (fun k ->\n            eqR := not (JS.HasOwnProperty a k) || JS.HasOwnProperty b k && Unchecked.equals a?(k) b?(k)\n            not !eqR)\n        if !eqR then\n            JS.ForEach b (fun k ->\n                eqR := not (JS.HasOwnProperty b k) || JS.HasOwnProperty a k\n                not !eqR)\n        !eqR\n    if a ===. b then true else\n        match JS.TypeOf a with\n        | JS.Object ->\n            if a ===. null || a ===. JS.Undefined || b ===. null || b ===. JS.Undefined then false\n            elif JS.In \"Equals\" a then equals a b\n            elif isArray a && isArray b then arrayEquals (As a) (As b)\n            elif isDate a && isDate b then dateEquals a b\n            else objEquals (As a) (As b)\n        | JS.Function ->\n            if JS.In \"$Func\" a then\n                a?``$Func`` ===. b?``$Func`` && a?``$Target`` ===. b?``$Target``\n            elif JS.In \"$Invokes\" a && JS.In \"$Invokes\" b then\n                arrayEquals a?``$Invokes`` b?``$Invokes``  \n            else false\n        | _ ->\n            false\n\nlet hashMix (x: int) (y: int) : int =\n    (x <<< 5) + x + y\n\nlet hashArray (o: obj []) =\n    let mutable h = -34948909\n    for i in 0 .. o.Length - 1 do\n        h <- hashMix h (Unchecked.hash o.[i])\n    h\n\nlet hashString (s: string) : int =\n    if s ===. null then 0 else\n        let mutable hash = 5381\n        for i = 0 to s.Length - 1 do\n            hash <- hashMix hash (int s.[i])\n        hash\n\n[<Inline \"$o.GetHashCode()\">]\nlet getHashCode(o: obj) = X<int>\n\nlet hashObject (o: obj) =\n    if JS.In \"GetHashCode\" o then getHashCode o else\n        let (++) = hashMix\n        let h = ref 0\n        JS.ForEach o (fun key ->\n            h := !h ++ hashString key ++ Unchecked.hash ((?) o key)\n            false)\n        !h\n\n/// Computes the hash of an object.\nlet Hash<'T> (o: 'T) : int =\n    match JS.TypeOf o with\n    | JS.Undefined -> 0\n    | JS.Function  -> 0\n    | JS.Boolean   -> if As o then 1 else 0\n    | JS.Number    -> As o\n    | JS.String    -> hashString (As o)\n    | JS.Object    -> if o ==. null then 0\n                      elif isArray o then hashArray (As o)\n                      else hashObject o\n\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen WebSharper.JavaScript\n\nmodule M = WebSharper.Macro\n\n[<JavaScript>]\n[<Name \"Numeric\">]\ntype internal N =\n    static member Parse<'T>(s: string, min: 'T, max: 'T, overflowMsg) =\n        let x : float = JS.Plus s\n        if x !==. (x -. (x %. 1)) then\n            raise (System.FormatException \"Input string was not in a correct format.\")\n        elif (x <. min) || (x >. max) then\n            raise (System.OverflowException overflowMsg)\n        else As<'T> x\n\n    static member TryParse<'T>(s: string, min: 'T, max: 'T, r: byref<'T>) =\n        let x : float = JS.Plus s\n        let ok = x ===. (x -. (x %. 1)) && (x >=. min) && (x <=. max)\n        if ok then r <- As<'T> x\n        ok\n\n[<Macro(typeof<M.NumericMacro>)>]\n[<Proxy(typeof<System.Byte>)>]\ntype internal NB =\n\n    [<Name \"WebSharper.Numeric.ParseByte\">]\n    static member Parse(s: string) : System.Byte =\n        N.Parse(s, System.Byte.MinValue, System.Byte.MaxValue, \"Value was either too large or too small for an unsigned byte.\")\n\n    [<Name \"WebSharper.Numeric.TryParseByte\">]\n    static member TryParse(s: string, r: byref<System.Byte>) : bool =\n        N.TryParse(s, System.Byte.MinValue, System.Byte.MaxValue, &r)\n\n[<Macro(typeof<M.NumericMacro>)>]\n[<Proxy(typeof<System.SByte>)>]\ntype internal NSB =\n\n    [<Name \"WebSharper.Numeric.ParseSByte\">]\n    static member Parse(s: string) : System.SByte =\n        N.Parse(s, System.SByte.MinValue, System.SByte.MaxValue, \"Value was either too large or too small for a signed byte.\")\n\n    [<Name \"WebSharper.Numeric.TryParseSByte\">]\n    static member TryParse(s: string, r: byref<System.SByte>) : bool =\n        N.TryParse(s, System.SByte.MinValue, System.SByte.MaxValue, &r)\n\n[<Macro(typeof<M.NumericMacro>)>]\n[<Proxy(typeof<System.Int16>)>]\n[<Name \"Int16\">]\ntype internal NI16 =\n\n    [<Name \"WebSharper.Numeric.ParseInt16\">]\n    static member Parse(s: string) : System.Int16 =\n        N.Parse(s, System.Int16.MinValue, System.Int16.MaxValue, \"Value was either too large or too small for an Int16.\")\n\n    [<Name \"WebSharper.Numeric.TryParseInt16\">]\n    static member TryParse(s: string, r: byref<System.Int16>) : bool =\n        N.TryParse(s, System.Int16.MinValue, System.Int16.MaxValue, &r)\n\n[<Macro(typeof<M.NumericMacro>)>]\n[<Proxy(typeof<System.Int32>)>]\n[<Name \"Int32\">]\ntype internal NI32 =\n\n    [<Name \"WebSharper.Numeric.ParseInt32\">]\n    static member Parse(s: string) : System.Int32 =\n        N.Parse(s, System.Int32.MinValue, System.Int32.MaxValue, \"Value was either too large or too small for an Int32.\")\n\n    [<Name \"WebSharper.Numeric.TryParseInt32\">]\n    static member TryParse(s: string, r: byref<System.Int32>) : bool =\n        N.TryParse(s, System.Int32.MinValue, System.Int32.MaxValue, &r)\n\n[<Macro(typeof<M.NumericMacro>)>]\n[<Proxy(typeof<System.UInt16>)>]\n[<Name \"UInt16\">]\ntype internal NUI16 =\n\n    [<Name \"WebSharper.Numeric.ParseUInt16\">]\n    static member Parse(s: string) : System.UInt16 =\n        N.Parse(s, System.UInt16.MinValue, System.UInt16.MaxValue, \"Value was either too large or too small for an UInt16.\")\n\n    [<Name \"WebSharper.Numeric.TryParseUInt16\">]\n    static member TryParse(s: string, r: byref<System.UInt16>) : bool =\n        N.TryParse(s, System.UInt16.MinValue, System.UInt16.MaxValue, &r)\n\n[<Macro(typeof<M.NumericMacro>)>]\n[<Proxy(typeof<System.UInt32>)>]\n[<Name \"UInt32\">]\ntype internal NUI32 =\n\n    [<Name \"WebSharper.Numeric.ParseUInt32\">]\n    static member Parse(s: string) : System.UInt32 =\n        N.Parse(s, System.UInt32.MinValue, System.UInt32.MaxValue, \"Value was either too large or too small for an UInt32.\")\n\n    [<Name \"WebSharper.Numeric.TryParseUInt32\">]\n    static member TryParse(s: string, r: byref<System.UInt32>) : bool =\n        N.TryParse(s, System.UInt32.MinValue, System.UInt32.MaxValue, &r)\n\n[<Macro(typeof<M.NumericMacro>)>]\n[<Proxy(typeof<System.Int64>)>]\n[<Name \"Int64\">]\ntype internal NI64 =\n\n    [<Name \"WebSharper.Numeric.ParseInt64\">]\n    static member Parse(s: string) : System.Int64 =\n        N.Parse(s, System.Int64.MinValue, System.Int64.MaxValue, \"Value was either too large or too small for an Int64.\")\n\n    [<Name \"WebSharper.Numeric.TryParseInt64\">]\n    static member TryParse(s: string, r: byref<System.Int64>) : bool =\n        N.TryParse(s, System.Int64.MinValue, System.Int64.MaxValue, &r)\n\n[<Macro(typeof<M.NumericMacro>)>]\n[<Proxy(typeof<System.UInt64>)>]\n[<Name \"UInt64\">]\ntype internal NUI64 =\n\n    [<Name \"WebSharper.Numeric.ParseUInt64\">]\n    static member Parse(s: string) : System.UInt64 =\n        N.Parse(s, System.UInt64.MinValue, System.UInt64.MaxValue, \"Value was either too large or too small for an UInt64.\")\n\n    [<Name \"WebSharper.Numeric.TryParseUInt64\">]\n    static member TryParse(s: string, r: byref<System.UInt64>) : bool =\n        N.TryParse(s, System.UInt64.MinValue, System.UInt64.MaxValue, &r)\n\n[<Macro(typeof<M.NumericMacro>)>]\n[<Proxy(typeof<System.Single>)>]\ntype internal NS =\n\n    [<Inline \"Math.abs($0) === Infinity\">]\n    static member IsInfinity(f: single) = X<bool>\n\n    [<Inline \"isNaN($0)\">]\n    static member IsNaN(f: single) = X<bool>\n\n    [<Inline \"$0 === -Infinity\">]\n    static member IsNegativeInfinity (f: single) = X<bool>\n\n    [<Inline \"$0 === Infinity\">]\n    static member IsPositiveInfinity (f: single) = X<bool>\n\n[<Macro(typeof<M.NumericMacro>)>]\n[<Proxy(typeof<System.Double>)>]\ntype internal ND =\n\n    [<Inline \"Math.abs($0) === Infinity\">]\n    static member IsInfinity(f: double) = X<bool>\n\n    [<Inline \"isNaN($0)\">]\n    static member IsNaN(f: double) = X<bool>\n\n    [<Inline \"$0 === -Infinity\">]\n    static member IsNegativeInfinity (f: double) = X<bool>\n\n    [<Inline \"$0 === Infinity\">]\n    static member IsPositiveInfinity (f: double) = X<bool>\n\n[<Proxy(typeof<System.Boolean>)>]\ntype internal B = \n    [<Inline>]\n    static member op_LogicalNot(a: bool) = not a\n"],
"names": [],
"mappings": "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"
}
