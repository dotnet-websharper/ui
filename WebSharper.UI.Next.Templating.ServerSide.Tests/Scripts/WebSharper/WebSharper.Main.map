{
"version": 3,
"sourceRoot": "Source",
"sources": ["WebSharper.Main/Macro.fs", "WebSharper.Main/JavaScript.Pervasives.fs", "WebSharper.Main/Json.fs", "WebSharper.Main/Remoting.fs", "WebSharper.Main/Html.fs", "WebSharper.Main/Utils.fs", "WebSharper.Main/Concurrency.fs", "WebSharper.Main/Enumerator.fs", "WebSharper.Main/CollectionInternals.fs", "WebSharper.Main/Object.fs", "WebSharper.Main/IntrinsicFunctions.fs", "WebSharper.Main/Array.fs", "WebSharper.Main/ArrayModule.fs", "WebSharper.Main/Array2DModule.fs", "WebSharper.Main/Async.fs", "WebSharper.Main/Char.fs", "WebSharper.Main/CommonExtensions.fs", "WebSharper.Main/DateTime.fs", "WebSharper.Main/Delegate.fs", "WebSharper.Main/Dictionary.fs", "WebSharper.Main/Exception.fs", "WebSharper.Main/ExtraTopLevelOperators.fs", "WebSharper.Main/HashSet.fs", "WebSharper.Main/Interfaces.fs", "WebSharper.Main/LazyExtensions.fs", "WebSharper.Main/List.fs", "WebSharper.Main/ListModule.fs", "WebSharper.Main/Nullable.fs", "WebSharper.Main/Operators.fs", "WebSharper.Main/OperatorIntrinsics.fs", "WebSharper.Main/OptionModule.fs", "WebSharper.Main/Queue.fs", "WebSharper.Main/Random.fs", "WebSharper.Main/ResultModule.fs", "WebSharper.Main/RuntimeHelpers.fs", "WebSharper.Main/SeqModule.fs", "WebSharper.Main/Stack.fs", "WebSharper.Main/String.fs", "WebSharper.Main/Task.fs", "WebSharper.Main/Unchecked.fs", "WebSharper.Main/Primitives.fs"],
"sourcesContent": ["// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2014 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n/// Defines macros used by proxy definitions.\n[<CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]\nmodule WebSharper.Macro\n\nopen System.Collections.Generic\nopen System.Text.RegularExpressions\n\nopen WebSharper\nopen WebSharper.Core\nopen WebSharper.Core.AST\n\nmodule M = WebSharper.Core.Metadata\nmodule I = IgnoreSourcePos\n\nlet scalarTypes =\n    integralTypes\n    + Set [\n        \"System.Double\"\n        \"System.Single\"\n        \"System.String\" \n        \"System.TimeSpan\"\n        \"System.DateTime\"\n    ]\n\nlet comparableTypes =\n    scalarTypes\n    + Set [\n        \"System.Char\"\n    ]\n\nlet isIn (s: string Set) (t: Type) = \n    match t with\n    | ConcreteType t ->\n        s.Contains t.Entity.Value.FullName\n    | _ ->\n        false\n\nlet traitCallOp (c: MacroCall) args =\n    match c.Method.Generics with\n    | [t; u; v] ->\n        TraitCall(\n            [ t; u ], \n            NonGeneric (\n                Method {\n                    MethodName = c.Method.Entity.Value.MethodName\n                    Parameters = [ t; u ]\n                    ReturnType = v\n                    Generics = 0\n                }\n            ),\n            args\n        )\n    | _ ->\n        failwith \"F# Operator value expecting 3 type arguments\"\n    \nlet utilsModule =\n    TypeDefinition {\n        FullName = \"WebSharper.Utils\"\n        Assembly = \"WebSharper.Main\"\n    }\nlet utils (comp: M.ICompilation) f args = \n    let m = comp.GetClassInfo(utilsModule).Value.Methods.Keys |> Seq.find (fun m -> m.Value.MethodName = f)\n    Call(None, NonGeneric utilsModule, NonGeneric m, args)\n\nlet translateOperation (c: MacroCall) (t: Type) args leftNble rightNble op =\n    match args with\n    | [x; y] ->\n        let a, b, lambda =\n            if leftNble || rightNble then\n                let a = Id.New \"a\"\n                let b = Id.New \"b\"\n                Var a, Var b, fun res -> CurriedLambda([a; b], res)\n            else\n                x, y, id\n        let res =\n            if op = BinaryOperator.``/`` then\n                if isIn smallIntegralTypes t\n                then (a ^/ b) ^>> !~(Int 0)\n                elif isIn bigIntegralTypes t\n                then Application(Global [\"Math\"; \"trunc\"], [a ^/ b], Pure, Some 1)\n                elif isIn scalarTypes t\n                then a ^/ b\n                else traitCallOp c [a; b]\n            else\n                if isIn scalarTypes t then\n                    Binary(a, op, y)\n                else traitCallOp c [a; b]\n        match leftNble, rightNble with\n        | false, false -> res\n        | true , false -> utils c.Compilation \"nullableOpL\" [ x; y; lambda res ]\n        | false, true  -> utils c.Compilation \"nullableOpR\" [ x; y; lambda res ]\n        | true , true  -> utils c.Compilation \"nullableOp\"  [ x; y; lambda res ]\n        |> MacroOk\n    | _ -> MacroError \"arithmetic macro error\"\n\n[<Sealed>]\ntype Arith() =\n    inherit Macro()\n    override this.TranslateCall(c) =\n        let opName = c.Method.Entity.Value.MethodName\n        let leftNble = opName.StartsWith \"op_Qmark\"\n        let rightNble = opName.EndsWith \"Qmark\"\n        let simpleOpName = if leftNble || rightNble then opName.Replace(\"Qmark\", \"\") else opName\n        let op =\n            match simpleOpName with\n            | BinaryOpName op -> op\n            | \"op_Plus\" -> BinaryOperator.``+``\n            | \"op_Minus\" -> BinaryOperator.``-``\n            | \"op_Divide\" -> BinaryOperator.``/``\n            | \"op_Percent\" -> BinaryOperator.``%``\n            | n -> failwithf \"unrecognized operator for Arith macro: %s\" n\n        match c.Method.Generics with\n        | t :: _ ->\n            translateOperation c t c.Arguments leftNble rightNble op\n        | _ -> MacroError \"arithmetic macro error\"\n\ntype Comparison =\n    | ``<``  = 0\n    | ``<=`` = 1\n    | ``>``  = 2\n    | ``>=`` = 3\n    | ``=``  = 4\n    | ``<>`` = 5\n\nlet toBinaryOperator cmp =\n    match cmp with\n    | Comparison.``<``  -> BinaryOperator.``<``\n    | Comparison.``<=`` -> BinaryOperator.``<=``\n    | Comparison.``>``  -> BinaryOperator.``>``\n    | Comparison.``>=`` -> BinaryOperator.``>=``\n    | Comparison.``=``  -> BinaryOperator.``===``\n    | _                 -> BinaryOperator.``!==``\n\nlet opUncheckedTy, equalsMeth, compareMeth =\n    match <@ Unchecked.equals 1 1 @> with\n    | FSharp.Quotations.Patterns.Call (_, mi, _) ->\n        let cmi = mi.DeclaringType.GetMethod(\"Compare\")\n        Reflection.ReadTypeDefinition mi.DeclaringType,\n        Reflection.ReadMethod mi,\n        Reflection.ReadMethod cmi\n    | _ -> failwith \"Expecting a Call pattern\"\n\nlet makeComparison cmp x y =\n    let eq x y = Call (None, NonGeneric opUncheckedTy, NonGeneric equalsMeth, [x; y]) \n    let c b i = Binary (Call(None, NonGeneric opUncheckedTy, NonGeneric compareMeth, [x; y]), b, Value(Int i))\n    match cmp with\n    | Comparison.``<``  -> c BinaryOperator.``===`` -1\n    | Comparison.``<=`` -> c BinaryOperator.``<=`` 0\n    | Comparison.``>``  -> c BinaryOperator.``===`` 1\n    | Comparison.``>=`` -> c BinaryOperator.``>=`` 0\n    | Comparison.``=``  -> eq x y\n    | _                 -> Unary (UnaryOperator.``!``, eq x y)\n\nlet cInt i = Value (Int i)\nlet cString s = Value (Literal.String s)\n\nlet isComparison = function\n    | BinaryOperator.``<`` | BinaryOperator.``>`` | BinaryOperator.``<=`` \n    | BinaryOperator.``>=`` | BinaryOperator.``==`` | BinaryOperator.``!=`` -> true\n    | _ -> false\n\nlet isOperation = function\n    | BinaryOperator.``%`` | BinaryOperator.``*`` | BinaryOperator.``+``\n    | BinaryOperator.``-`` | BinaryOperator.``/``\n    | BinaryOperator.``<<`` | BinaryOperator.``>>`` | BinaryOperator.``|``\n    | BinaryOperator.``&`` | BinaryOperator.``^``\n    | BinaryOperator.``&&`` | BinaryOperator.``||`` -> true\n    | _ -> false\n\nlet toComparison = function\n    | BinaryOperator.``<`` -> Comparison.``<``\n    | BinaryOperator.``>`` -> Comparison.``>``\n    | BinaryOperator.``<=`` -> Comparison.``<=``\n    | BinaryOperator.``>=`` -> Comparison.``>=``\n    | BinaryOperator.``==`` -> Comparison.``=``\n    | BinaryOperator.``!=`` -> Comparison.``<>``\n    | _ -> failwith \"Operation wasn't a comparison\"\n\nlet translateComparison (c: M.ICompilation) t args leftNble rightNble cmp =\n    match args with\n    | [x; y] ->\n        let a, b, lambda =\n            if leftNble || rightNble then\n                let a = Id.New \"a\"\n                let b = Id.New \"b\"\n                Var a, Var b, fun res -> CurriedLambda([a; b], res)\n            else\n                x, y, id\n        let comp x y =\n            Binary (x, toBinaryOperator cmp, y)\n        let res =\n            if isIn comparableTypes t then\n                comp a b\n            else\n                // optimization for checking against argumentless union cases \n                let tryGetSingletonUnionCaseTag (x: Expression) =\n                    match x with\n                    | I.NewUnionCase(ct, case, []) ->\n                        match c.GetCustomTypeInfo ct.Entity with\n                        | M.FSharpUnionInfo ui when not ui.HasNull ->\n                            ui.Cases |> Seq.mapi (fun i c ->\n                                if c.Name = case && c.Kind = M.SingletonFSharpUnionCase then Some i else None\n                            ) |> Seq.tryPick id         \n                        | _ -> None\n                    | _ -> None\n                    \n                match tryGetSingletonUnionCaseTag x, tryGetSingletonUnionCaseTag y with\n                | Some i, Some j -> comp (cInt i) (cInt j)\n                | Some i, _ -> comp (cInt i) (y.[cString \"$\"])\n                | _, Some j -> comp (x.[cString \"$\"]) (cInt j)\n                | _ -> makeComparison cmp a b\n        match leftNble, rightNble with\n        | false, false -> res\n        | true , false -> utils c \"nullableCmpL\" [ x; y; lambda res ]\n        | false, true  -> utils c \"nullableCmpR\" [ x; y; lambda res ]\n        | true , true  -> \n            match cmp with\n            | Comparison.``<=`` \n            | Comparison.``>=`` \n            | Comparison.``=`` \n                -> utils c \"nullableCmpE\" [ x; y; lambda res ]\n            | _ -> utils c \"nullableCmp\"  [ x; y; lambda res ] \n        |> MacroOk\n    | _ ->\n        MacroError \"comparisonMacro error\"\n\n[<Sealed>]\ntype Comp() =\n    inherit Macro()\n    override this.TranslateCall(c) =\n        let opName = c.Method.Entity.Value.MethodName\n        let leftNble = opName.StartsWith \"op_Qmark\"\n        let rightNble = opName.EndsWith \"Qmark\"\n        let simpleOpName = if leftNble || rightNble then opName.Replace(\"Qmark\", \"\") else opName\n        let cmp =\n            match simpleOpName with\n            | BinaryOpName op -> toComparison op\n            | \"op_Equals\" -> Comparison.``=``\n            | \"op_LessGreater\" -> Comparison.``<>``\n            | \"op_Greater\" -> Comparison.``>``\n            | \"op_Less\" -> Comparison.``<``\n            | \"op_GreaterEquals\" -> Comparison.``>=``\n            | \"op_LessEquals\" -> Comparison.``<=``\n            | n -> failwithf \"unrecognized operator for for Comp macro: %s\" n\n        match c.Method.Generics with\n        | t :: _ ->\n            translateComparison c.Compilation t c.Arguments leftNble rightNble cmp\n        | _ ->\n            MacroError \"comparisonMacro error\"\n\nlet formatExceptionTy, formatExceptionCtor =\n    match <@ new System.FormatException() @> with\n    | FSharp.Quotations.Patterns.NewObject (ci, _) ->\n        Reflection.ReadTypeDefinition ci.DeclaringType,\n        Reflection.ReadConstructor ci\n    | _ -> failwith \"Expected constructor call\"\n\nlet parseInt x =\n    Application(Global [\"parseInt\"], [x], Pure, Some 1)\nlet toNumber x =\n    Application(Global [\"Number\"], [x], Pure, Some 1)\n\n[<Sealed>]\ntype NumericMacro() =\n    inherit Macro()\n\n    let exprParse parsed tru fls =\n        let id = Id.New(mut = false)\n        Let (id, parsed,\n            Conditional(Application(Global [\"isNaN\"], [Var id], Pure, Some 1),\n                tru id,\n                fls id\n            )\n        )\n\n    override this.TranslateCall(c) =\n        let name = c.DefiningType.Entity.Value.FullName\n\n        let ex =\n            Ctor(\n                NonGeneric formatExceptionTy,\n                formatExceptionCtor,\n                [Value (String \"Input string was not in a correct format.\")]\n            )\n\n        let isNble t =\n            match t with\n            | VoidType -> true\n            | ConcreteType { Entity = td } when td.Value.FullName = \"System.Nullable`1\" -> true\n            | _ -> false\n\n        match c.Method.Entity.Value.MethodName with\n        | BinaryOpName op when isOperation op ->\n            let leftNble, rightNble =\n                match c.Method.Generics with\n                | [lt; rt] -> isNble lt, isNble rt\n                | _ -> false, false\n            translateOperation c (ConcreteType c.DefiningType) c.Arguments leftNble rightNble op\n        | BinaryOpName op when isComparison op ->\n            let leftNble, rightNble =\n                match c.Method.Generics with\n                | [lt; rt] -> isNble lt, isNble rt\n                | _ -> false, false\n            let cmp = toComparison op\n            translateComparison c.Compilation (ConcreteType c.DefiningType) c.Arguments leftNble rightNble cmp\n        | UnaryOpName op ->\n            match c.Arguments with\n            | [x] -> Unary (op, x) |> MacroOk\n            | _ -> MacroError \"numericMacro error\"\n        | \"op_Increment\" ->\n            match c.Arguments with\n            | [x] ->\n                MacroOk (Binary(x, BinaryOperator.``+``, Value (Int 1)))\n            | _ -> MacroError \"numericMacro error\"\n        | \"op_Decrement\" ->\n            match c.Arguments with\n            | [x] ->\n                MacroOk (Binary(x, BinaryOperator.``-``, Value (Int 1)))\n            | _ -> MacroError \"numericMacro error\"\n        | \"ToString\" ->\n            match c.This with\n            | Some self ->\n                // TODO refactor to separate method\n                if c.DefiningType.Entity.Value.AssemblyQualifiedName = \"System.Char, mscorlib\" then\n                    self\n                else \n                    Application(Global [\"String\"], [self], Pure, Some 1)\n                |> MacroOk \n            | _ -> MacroError \"numericMacro error\"\n        | \"Parse\" ->\n            match c.Arguments with\n            | [x] ->\n                if name = \"System.Single\" || name = \"System.Double\" then\n                    exprParse\n                    <| toNumber x\n                    <| fun _ -> ex\n                    <| fun id -> Var id\n                    |> MacroOk\n                else MacroError \"numericMacro error\"\n            | _ -> MacroError \"numericMacro error\"\n        | \"TryParse\" ->\n            match c.Arguments with\n            | [x; y] ->\n                if name = \"System.Single\" || name = \"System.Double\" then\n                    exprParse\n                    <| toNumber x\n                    <| fun _ -> Value (Bool false)\n                    <| fun id ->\n                        Expression.Sequential [\n                            SetRef y (Var id)\n                            Value (Bool true)\n                        ]\n                    |> MacroOk\n                else MacroError \"numericMacro error\"\n            | _ -> MacroError \"numericMacro error\"\n        | _ -> MacroFallback\n\nlet charTy, charParse =\n    let t = typeof<System.Char>\n    Reflection.ReadTypeDefinition t,\n    Reflection.ReadMethod (t.GetMethod \"Parse\")\n\n[<Sealed>]\ntype Char() =\n    inherit Macro()\n    override this.TranslateCall(c) =\n        match c.Arguments with\n        | [x] ->\n            match c.Method.Generics with\n            | t :: _ ->\n                let fromNum() = \n                    Application(Global [\"String\"; \"fromCharCode\"], [x], Pure, Some 1)\n                    |> MacroOk\n                if isIn integralTypes t then fromNum() else\n                    match t with\n                    | ConcreteType d ->\n                        match d.Entity.Value.FullName with\n                        | \"System.String\" ->\n                            Call (None, NonGeneric charTy, NonGeneric charParse, [x])\n                            |> MacroOk\n                        | \"System.Char\" -> MacroOk x\n                        | \"System.Double\"\n                        | \"System.Single\" -> fromNum()\n                        | _ -> MacroError \"charMacro error\"\n                    | _ ->\n                        MacroError \"charMacro error\"\n            | _ ->\n                MacroError \"charMacro error\"\n        | _ ->\n            MacroError \"charMacro error\"\n\n[<Sealed>]\ntype Range() =\n    inherit Macro()\n    override this.TranslateCall(c) =\n        match c.Method.Generics with\n        | t :: _ ->\n            match t with\n            | ConcreteType d ->\n                match d.Entity.Value.FullName with\n                | \"System.Char\" -> \n                    utils c.Compilation \"charRange\" c.Arguments |> MacroOk   \n                | _ -> MacroFallback\n            | _ -> MacroFallback\n        | _ -> MacroError \"Range macro error\"\n\n[<Sealed>]\ntype Conversion() =\n    inherit Macro()\n    override this.TranslateCall(c) =\n        let isNble =\n            c.DefiningType.Entity.Value.FullName = \"Microsoft.FSharp.Linq.NullableModule\"\n        let m = c.Method\n        let x = c.Arguments.Head\n        let a, withNbleSupport = \n            if isNble then\n                let a = Id.New \"a\"\n                Var a, fun res -> utils c.Compilation \"nullableConv\" [ x; Lambda([a], res) ] \n            else \n                x, id\n        let (|OptNbleTypeDef|_|) t =\n            match t with\n            | ConcreteType { Entity = tt; Generics = g } ->\n                if tt.Value.FullName = \"System.Nullable`1\" then\n                    match g.Head with\n                    | ConcreteType { Entity = tt } -> Some tt\n                    | _ -> None\n                else Some tt\n            | _ -> None\n            \n        match m.Generics.Head, m.Entity.Value.ReturnType with\n        | OptNbleTypeDef ft, OptNbleTypeDef tt ->\n            NumericConversion ft tt a |> withNbleSupport |> MacroOk\n        | TypeParameter _, OptNbleTypeDef tt ->\n            let tn = tt.Value.FullName\n            let warnAboutChar res =\n                MacroWarning (\"Unsafe generic conversion for client-side, make sure input cannot be a char\", MacroOk res)\n            if integralTypes.Contains tn then\n                parseInt a |> withNbleSupport |> warnAboutChar\n            elif scalarTypes.Contains tn then\n                toNumber a |> withNbleSupport |> warnAboutChar\n            elif tn = \"System.Char\" then\n                Application(Global [\"String\"; \"fromCharCode\"], [a], Pure, Some 1) |> warnAboutChar\n            else\n                MacroError (\"Conversion macro error: generic to \" + tn)\n        | f, t -> MacroError (sprintf \"Conversion macro error: %O to %O\" f t)\n\n[<Sealed>]\ntype String() =\n    inherit Macro()\n    override this.TranslateCall(c) =\n        match c.Arguments with\n        | [x] ->\n            match c.Method.Generics with\n            | t :: _ ->\n                match t with\n                | ConcreteType d ->\n                    match d.Entity.Value.FullName with\n                    | \"System.Char\" ->\n                        x\n                    | \"System.DateTime\" ->\n                        Application(ItemGet(New(Global [ \"Date\" ], [x]), Value (Literal.String \"toLocaleString\"), Pure), [], Pure, None)\n                    | _ ->\n                        Application(Global [\"String\"], [x], Pure, Some 1)   \n                | _ -> \n                    Application(Global [\"String\"], [x], Pure, Some 1)   \n                |> MacroOk \n            | _ ->\n                MacroError \"stringMacro error\"\n        | [] ->\n            // when unit argument is erased\n            MacroOk (Value (Literal.String \"\"))\n        | _ ->\n            MacroError \"stringMacro error\"\n\nlet fsharpListDef =\n    TypeDefinition {\n        Assembly = \"FSharp.Core\"\n        FullName = \"Microsoft.FSharp.Collections.FSharpList`1\"  \n    }\n\nlet listModuleDef =\n    TypeDefinition {\n        Assembly = \"FSharp.Core\"\n        FullName = \"Microsoft.FSharp.Collections.ListModule\"\n    }\n\nlet listOfArrayDef =\n    Method {\n        MethodName = \"OfArray\"\n        Parameters = [ ArrayType (TypeParameter 0, 1) ]\n        ReturnType = GenericType fsharpListDef [ TypeParameter 0 ]\n        Generics = 1      \n    }\n\nlet getFieldsList q =\n    let ``is (=>)`` (td: TypeDefinition) (m: Method) =\n        td.Value.FullName = \"WebSharper.JavaScript.Pervasives\"\n        && m.Value.MethodName = \"op_EqualsGreater\"\n    let rec getFieldsListTC l q =\n        let trItem i =\n            match IgnoreExprSourcePos i with    \n            | NewArray [I.Value (String n); v] -> n, v \n            | Call (_, td, m, [I.Value (String n); v])\n                when ``is (=>)`` td.Entity m.Entity -> n, v\n            | _ -> failwith \"Wrong type of array passed to New\"\n        match IgnoreExprSourcePos q with\n        | NewUnionCase (_, _, [I.NewArray [I.Value (String n); v]; t]) ->\n            getFieldsListTC ((n, v) :: l) t         \n        | NewUnionCase (_, _, [I.Call (_, td, m, [I.Value (String n); v]); t])\n            when ``is (=>)`` td.Entity m.Entity ->\n            getFieldsListTC ((n, v) :: l) t         \n        | NewUnionCase (_, _, []) -> Some (l |> List.rev) \n        | Call(None, td, m, [ I.NewArray items ]) when td.Entity = listModuleDef && m.Entity = listOfArrayDef ->\n            items |> List.map trItem |> Some\n        | NewArray (items) ->\n            items |> List.map trItem |> Some\n        | _ -> None\n    getFieldsListTC [] q\n\n[<Sealed>]\ntype New() =\n    inherit Macro()\n    override this.TranslateCall(c) =\n        match c.Arguments with\n        | [x] -> \n            match getFieldsList x with\n            | Some xl ->\n                MacroOk <| Object (xl |> List.map (fun (n, v) -> n, v))\n            | _ -> MacroFallback\n        | _ -> MacroError \"New macro Error\"\n\n//type FST = Reflection.FSharpType\n\nmodule JSRuntime =\n    let private runtime = [\"Runtime\"; \"IntelliFactory\"]\n    let private runtimeFunc f p args = Application(GlobalAccess (Address (f :: runtime)), args, p, Some (List.length args))\n    let GetOptional value = runtimeFunc \"GetOptional\" Pure [value]\n    let SetOptional obj field value = runtimeFunc \"SetOptional\" NonPure [obj; field; value]\n    let CreateFuncWithArgs f = runtimeFunc \"CreateFuncWithArgs\" Pure [f]\n    let CreateFuncWithArgsRest length f = runtimeFunc \"CreateFuncWithArgsRest\" Pure [length; f]\n    let CreateFuncWithThis f = runtimeFunc \"CreateFuncWithThis\" Pure [f]\n\n[<Sealed>]\ntype FuncWithArgs() =\n    inherit Macro()\n    override this.TranslateCtor(c) =\n        match c.Arguments with\n        | [func] ->\n            match c.DefiningType.Generics.[0] with\n            | TupleType _ ->\n                JSRuntime.CreateFuncWithArgs func |> MacroOk\n            | _ ->\n                MacroError \"Wrong type argument on FuncWithArgs: 'TArgs must be a tuple\"\n        | _ ->\n            MacroError \"funcWithArgsMacro error\"\n\n[<Sealed>]\ntype FuncWithArgsRest() =\n    inherit Macro()\n    override this.TranslateCtor(c) =\n        match c.Arguments with\n        | [func] ->\n            match c.DefiningType.Generics.[0] with\n            | TupleType (ts, _) ->\n                JSRuntime.CreateFuncWithArgsRest (Value (Int (List.length ts))) func |> MacroOk\n            | _ ->\n                MacroError \"Wrong type argument on FuncWithArgsRest: 'TArgs must be a tuple\"\n        | _ ->\n            MacroError \"funcWithArgsMacro error\"\n\n[<Sealed>]\ntype FuncWithThis() =\n    inherit Macro()\n    override this.TranslateCtor(c) =\n        match c.Arguments with\n        | [func] ->\n            match c.DefiningType.Generics.[0] with\n            | FSharpFuncType _ ->\n                JSRuntime.CreateFuncWithThis func |> MacroOk\n            | ConcreteType td when \n                (\n                    let n = td.Entity.Value.FullName\n                    n = \"WebSharper.JavaScript.Function\" || n.StartsWith \"WebSharper.JavaScript.FuncWith\" \n                ) ->\n                JSRuntime.CreateFuncWithThis func |> MacroOk\n            | _ ->\n                MacroError \"Wrong type argument on FuncWithThis: 'TFunc must be an F# function or JavaScript function type\"\n        | _ ->\n            MacroError \"funcWithArgsMacro error\"\n\nlet ApplItem(on, item, args) = Application(ItemGet(on, Value (AST.String item), Pure), args, NonPure, None)\n\n[<Sealed>]\ntype JSThisCall() =\n    inherit Macro()\n    override __.TranslateCall(c) =\n        match c.This with\n        | Some func ->\n            MacroOk (ApplItem(func, \"call\", c.Arguments))\n        | _ -> MacroError \"JSCall macro error\"\n\n[<Sealed>]\ntype JSParamsCall() =\n    inherit Macro()\n    override __.TranslateCall(c) =\n        match c.This, List.rev c.Arguments with\n        | Some func, pars :: revArgs ->\n            let args = ApplItem(NewArray (List.rev revArgs), \"concat\", [pars])\n            MacroOk (ApplItem(func, \"apply\", [Undefined; args]))\n        | _ -> MacroError \"JSParamsCall macro error\"\n\n[<Sealed>]\ntype JSThisParamsCall() =\n    inherit Macro()\n    override __.TranslateCall(c) =\n        match c.This, c.Arguments with\n        | Some func, this :: afterThis ->\n            match List.rev afterThis with\n            | pars :: revArgs ->    \n                let args = ApplItem(NewArray (List.rev revArgs), \"concat\", [pars])\n                MacroOk (ApplItem(func, \"apply\", [this; args]))\n            | _ -> MacroError \"JSThisParamsCall macro error\"\n        | _ -> MacroError \"JSThisParamsCall macro error\"\n\n[<Sealed>]\ntype GetJS() =\n    inherit Macro()\n    override __.TranslateCall(c) =\n        match c.Arguments with\n        | [ obj ] -> MacroOk obj\n        | [ obj; I.NewArray items ] ->\n            if items |> List.forall (function I.Value _ -> true | _ -> false) then\n                items |> List.fold (fun x i -> ItemGet(x, i, NonPure)) obj |> MacroOk\n            else MacroFallback\n        | [ _; _ ] -> MacroFallback\n        | _ -> MacroError (sprintf \"GetJS macro error, arguments: %+A\" c.Arguments)\n\n/// Set of helpers to parse format string\n/// Source: https://github.com/fsharp/fsharp/blob/master/src/fsharp/FSharp.Core/printf.fs\nmodule private FormatString =\n    [<System.Flags>]\n    type FormatFlags = \n        | None = 0\n        | LeftJustify = 1\n        | PadWithZeros = 2\n        | PlusForPositives = 4\n        | SpaceForPositives = 8\n\n    let inline hasFlag flags (expected : FormatFlags) = (flags &&& expected) = expected\n    let inline isLeftJustify flags = hasFlag flags FormatFlags.LeftJustify\n    let inline isPadWithZeros flags = hasFlag flags FormatFlags.PadWithZeros\n    let inline isPlusForPositives flags = hasFlag flags FormatFlags.PlusForPositives\n    let inline isSpaceForPositives flags = hasFlag flags FormatFlags.SpaceForPositives\n\n    /// Used for width and precision to denote that user has specified '*' flag\n    [<Literal>]\n    let StarValue = -1\n    /// Used for width and precision to denote that corresponding value was omitted in format string\n    [<Literal>]\n    let NotSpecifiedValue = -2\n\n    [<NoComparison; NoEquality>]\n    type FormatSpecifier =\n        {\n            TypeChar : char\n            Precision : int\n            Width : int\n            Flags : FormatFlags\n        }\n        member this.IsStarPrecision = this.Precision = StarValue\n        member this.IsPrecisionSpecified = this.Precision <> NotSpecifiedValue\n        member this.IsStarWidth = this.Width = StarValue\n        member this.IsWidthSpecified = this.Width <> NotSpecifiedValue\n\n    let inline isDigit c = c >= '0' && c <= '9'\n    let intFromString (s : string) pos = \n        let rec go acc i =\n            if isDigit s.[i] then \n                let n = int s.[i] - int '0'\n                go (acc * 10 + n) (i + 1)\n            else acc, i\n        go 0 pos\n\n    let parseFlags (s : string) i : FormatFlags * int = \n        let rec go flags i = \n            match s.[i] with\n            | '0' -> go (flags ||| FormatFlags.PadWithZeros) (i + 1)\n            | '+' -> go (flags ||| FormatFlags.PlusForPositives) (i + 1)\n            | ' ' -> go (flags ||| FormatFlags.SpaceForPositives) (i + 1)\n            | '-' -> go (flags ||| FormatFlags.LeftJustify) (i + 1)\n            | _ -> flags, i\n        go FormatFlags.None i\n\n    let parseWidth (s : string) i : int * int = \n        if s.[i] = '*' then StarValue, (i + 1)\n        elif isDigit (s.[i]) then intFromString s i\n        else NotSpecifiedValue, i\n\n    let parsePrecision (s : string) i : int * int = \n        if s.[i] = '.' then\n            if s.[i + 1] = '*' then StarValue, i + 2\n            elif isDigit (s.[i + 1]) then intFromString s (i + 1)\n            else failwith \"invalid precision value\"\n        else NotSpecifiedValue, i\n    \n    let parseTypeChar (s : string) i : char * int = \n        s.[i], (i + 1)\n\n    type Part =\n        | StringPart of string\n        | FormatPart of FormatSpecifier\n\n    /// modified version of FSharp.Core findNextFormatSpecifier, parses whole format string\n    let parseAll (s : string) = \n        let parts = ResizeArray() \n        let rec go i (buf : System.Text.StringBuilder) =\n            if i >= s.Length then \n                if buf.Length > 0 then parts.Add (StringPart (string buf))\n            else\n                let c = s.[i]\n                if c = '%' then\n                    if i + 1 < s.Length then\n                        let f, i1 = parseFlags s (i + 1)\n                        let w, i2 = parseWidth s i1\n                        let p, i3 = parsePrecision s i2\n                        let typeChar, i4 = parseTypeChar s i3\n                        // shortcut for the simpliest case\n                        // if typeChar is not % or it has star as width\\precision - resort to long path\n                        if typeChar = '%' && not (w = StarValue || p = StarValue) then \n                            buf.Append('%') |> ignore\n                            go i4 buf\n                        else \n                            if buf.Length > 0 then parts.Add (StringPart (string buf))\n                            parts.Add (\n                                FormatPart {\n                                    TypeChar  = typeChar\n                                    Precision = p\n                                    Width     = w\n                                    Flags     = f\n                                }\n                            )\n                            go i4 (buf.Clear())\n                    else\n                        failwith \"Missing format specifier\"\n                else \n                    buf.Append(c) |> ignore\n                    go (i + 1) buf\n        go 0 (System.Text.StringBuilder())\n        parts.ToArray()\n\nlet flags =\n    System.Reflection.BindingFlags.Public\n    ||| System.Reflection.BindingFlags.NonPublic\n\nlet stringModule = \n    TypeDefinition {\n        FullName = \"Microsoft.FSharp.Core.StringModule\"\n        Assembly = \"FSharp.Core\"\n    }\nlet stringProxy (comp: M.ICompilation) f args =\n    let m = comp.GetClassInfo(stringModule).Value.Methods.Keys |> Seq.find (fun m -> m.Value.MethodName = f)\n    Call(None, NonGeneric stringModule, NonGeneric m, args)\n\nlet cCall e f args = Application (ItemGet(e, !~ (Literal.String f), Pure), args, Pure, None)\nlet cCallG a args = Application (Global a, args, Pure, None)\n\n//type FST = Reflection.FSharpType\n\nlet (^+) (a: Expression) (b: Expression) =\n    match a, b with\n    | I.Value (String av), I.Value (String bv) -> Value (AST.String (av + bv))\n    | I.Value av, I.Value bv -> Value (AST.String (av.Value.ToString() + bv.Value.ToString()))\n    | _ -> a ^+ b\n\nlet createPrinter (comp: M.ICompilation) (ts: Type list) fs =\n    let parts = FormatString.parseAll fs\n    let args = ts |> List.map (fun t -> Id.New(mut = false), Some t)\n        \n    let rArgs = ref args\n    let nextVar() =\n        match !rArgs with\n        | (a, t) :: r ->\n            rArgs := r\n            Var a, t\n        | _ -> failwithf \"wrong number of Printer type arguments found: %d\" (List.length ts)  \n        \n    let withPadding (f: FormatString.FormatSpecifier) t =\n        if f.IsWidthSpecified then\n            let width = if f.IsStarWidth then nextVar() |> fst else cInt f.Width\n            let s = t (nextVar())\n            if FormatString.isLeftJustify f.Flags then\n                stringProxy comp \"PadRight\" [s; width]\n            else\n                if FormatString.isPadWithZeros f.Flags then\n                    utils comp \"padNumLeft\" [s; width]\n                else\n                    stringProxy comp \"PadLeft\" [s; width]\n        else t (nextVar())\n        \n    let numberToString (f: FormatString.FormatSpecifier) t =\n        withPadding f (fun (n, _) ->\n            if FormatString.isPlusForPositives f.Flags then utils comp \"plusForPos\" [n; t n]\n            elif FormatString.isSpaceForPositives f.Flags then utils comp \"spaceForPos\" [n; t n]\n            else t n\n        )\n\n    let prettyPrint (t: Type) o = \n        let rec pp (t: Type) (o: Expression) = \n            match t with\n            | TupleType (ts, _) ->\n                seq {\n                    yield cString \"(\"\n                    for i = 0 to ts.Length - 1 do \n                        yield pp ts.[i] o.[cInt i] \n                        if i < ts.Length - 1 then yield cString \", \"\n                    yield cString \")\"\n                }\n                |> Seq.reduce (^+)\n            | ArrayType (a, r) ->\n                let x = Id.New(mut = false)\n                match r with \n                | 1 -> utils comp \"printArray\" [ Lambda([x], pp a (Var x)) ; o ]\n                | 2 -> utils comp \"printArray2D\" [ Lambda([x], pp a (Var x)) ; o ]\n                | _ -> utils comp \"prettyPrint\" [o]\n            | VoidType -> cString \"null\" \n            | FSharpFuncType _ -> cString \"<fun>\"\n            | ConcreteType ct ->\n                match comp.GetCustomTypeInfo ct.Entity with\n                | M.FSharpRecordInfo fields ->\n                    let td, m = \n                        let key = M.CompositeEntry [ M.StringEntry \"Printf\"; M.TypeEntry t ]\n                        match comp.GetMetadataEntries key with\n                        | M.CompositeEntry [ M.TypeDefinitionEntry gtd; M.MethodEntry gm ] :: _ ->\n                            gtd, gm\n                        | _ ->\n                            let gtd, gm, _ = comp.NewGenerated([ \"GeneratedPrintf\"; \"p\"])\n                            comp.AddMetadataEntry(key, M.CompositeEntry [ M.TypeDefinitionEntry gtd; M.MethodEntry gm ])\n                            let body = \n                                let x = Id.New(mut = false)\n                                Lambda([x], \n                                    seq {\n                                        yield cString \"{\"\n                                        let fields = Array.ofList fields\n                                        let gs = ct.Generics |> Array.ofList\n                                        for i = 0 to fields.Length - 1 do\n                                            let f = fields.[i]\n                                            let ftypRes = f.RecordFieldType.SubstituteGenerics gs\n                                            let item =\n                                                if f.Optional then\n                                                    JSRuntime.GetOptional (ItemGet(Var x, cString f.JSName, Pure))\n                                                else \n                                                    (Var x).[cString f.JSName]\n                                            yield cString (f.Name + \" = \") ^+ pp ftypRes item\n                                            if i < fields.Length - 1 then yield cString \"; \"\n                                        yield cString \"}\"\n                                    }\n                                    |> Seq.reduce (^+)\n                                ) \n                            comp.AddGeneratedCode(gm, body) |> ignore\n                            gtd, gm\n                    Call(None, NonGeneric td, NonGeneric m, [o])\n                | M.FSharpUnionInfo u ->\n                    if ct.Entity.Value.FullName = \"Microsoft.FSharp.Collections.FSharpList`1\" then\n                        let x = Id.New(mut = false)\n                        utils comp \"printList\" [ Lambda([x], pp ct.Generics.[0] (Var x)) ; o ]    \n                    else\n                        let td, m =\n                            let key = M.CompositeEntry [ M.StringEntry \"Printf\"; M.TypeEntry t ]\n                            match comp.GetMetadataEntries key with\n                            | M.CompositeEntry [ M.TypeDefinitionEntry gtd; M.MethodEntry gm ] :: _ ->\n                                gtd, gm\n                            | _ ->\n                                let gtd, gm, _ = comp.NewGenerated([ comp.AssemblyName.Replace(\".\",\"$\") + \"_GeneratedPrintf\"; \"p\" ])\n                                comp.AddMetadataEntry(key, M.CompositeEntry [ M.TypeDefinitionEntry gtd; M.MethodEntry gm ])\n                                let gs = ct.Generics |> Array.ofList\n                                let body =\n                                    let x = Id.New(mut = false)\n                                    Lambda([x],                                         \n                                        let caseInfo =\n                                            u.Cases |> Seq.mapi (fun tag c ->\n                                                match c.Kind with\n                                                | M.ConstantFSharpUnionCase cVal -> \n                                                    if cVal = Null then Choice3Of3 () \n                                                    else Choice1Of3 (cVal, cString c.Name)\n                                                | M.SingletonFSharpUnionCase ->\n                                                    Choice2Of3(tag, cString c.Name)    \n                                                | M.NormalFSharpUnionCase fs -> \n                                                    Choice2Of3(\n                                                        tag,\n                                                        match fs.Length with\n                                                        | 0 -> cString c.Name\n                                                        | 1 ->\n                                                            let ityRes = fs.[0].UnionFieldType.SubstituteGenerics gs \n                                                            cString (c.Name + \" \") ^+ pp ityRes (Var x).[cString \"$0\"]\n                                                        | _ -> \n                                                            seq {\n                                                                yield cString (c.Name + \" (\")\n                                                                for i = 0 to fs.Length - 1 do\n                                                                    let ityRes = fs.[i].UnionFieldType.SubstituteGenerics gs\n                                                                    yield pp ityRes (Var x).[cString (\"$\" + string i)]\n                                                                    if i < fs.Length - 1 then yield cString \", \"\n                                                                yield cString \")\"\n                                                            }\n                                                            |> Seq.reduce (^+)\n                                                    )\n                                            )\n                                        let withoutNullCheck =\n                                            caseInfo\n                                            |> Seq.fold (fun s cInfo ->\n                                                match s with\n                                                | None -> \n                                                    match cInfo with\n                                                    | Choice1Of3 (_, e) \n                                                    | Choice2Of3 (_, e) -> Some e\n                                                    | Choice3Of3 () -> None\n                                                | Some s -> \n                                                    match cInfo with\n                                                    | Choice1Of3 (cVal, e) -> Some <| Conditional (Var x ^== Value cVal, e, s)\n                                                    | Choice2Of3 (tag, e) -> Some <| Conditional ((Var x).[cString \"$\"] ^== cInt tag, e, s)\n                                                    | Choice3Of3 () -> Some s\n                                            ) None |> Option.get\n                                        if caseInfo |> Seq.exists (function Choice3Of3 () -> true | _ -> false) then\n                                            Conditional(Var x ^== Value Null, cString \"null\", withoutNullCheck)    \n                                        else withoutNullCheck    \n                                    )\n                                comp.AddGeneratedCode(gm, body) |> ignore\n                                gtd, gm\n                        Call(None, NonGeneric td, NonGeneric m, [o])\n                | _ ->\n                    utils comp \"prettyPrint\" [o]\n            | _ -> utils comp \"prettyPrint\" [o]\n        pp t o\n\n    let inner = \n        if Array.isEmpty parts then cString \"\" else\n        parts\n        |> Seq.map (function\n            | FormatString.StringPart s -> cString s\n            | FormatString.FormatPart f ->\n                match f.TypeChar with\n                | 'b'\n                | 'O' -> \n                    withPadding f (fun (o, _) -> cCallG [\"String\"] [o])\n                | 'A' -> \n                    withPadding f (function \n                        | o, Some t -> \n                            prettyPrint t o\n                        | o, _ -> utils comp \"prettyPrint\" [o]\n                    )\n                | 'c' -> \n                    withPadding f (fun (s, _) -> s)   \n                | 's' -> \n                    withPadding f (fun (s, _) -> utils comp \"toSafe\" [s])\n                | 'd' | 'i' ->\n                    numberToString f (fun n -> cCallG [\"String\"] [n])\n                | 'x' ->                                           \n                    numberToString f (fun n -> cCall n \"toString\" [cInt 16])\n                | 'X' ->                                           \n                    numberToString f (fun n -> cCall (cCall n \"toString\" [cInt 16]) \"toUpperCase\" [])\n                | 'o' ->                                           \n                    numberToString f (fun n -> cCall n \"toString\" [cInt 8])\n                | 'e' ->\n                    numberToString f (fun n -> cCall n \"toExponential\" []) \n                | 'E' ->\n                    numberToString f (fun n -> cCall (cCall n \"toExponential\" []) \"toUpperCase\" []) \n                | 'f' | 'F' | 'M' ->\n                    numberToString f (fun n ->\n                        let prec =\n                            if f.IsPrecisionSpecified then\n                                if f.IsStarPrecision then nextVar() |> fst else cInt f.Precision\n                            else cInt 6 // Default precision\n                        cCall n \"toFixed\" [prec]\n                    )\n                | c -> failwithf \"Failed to parse format string: '%%%c' is not supported.\" c\n        )\n        |> Seq.reduce (^+)\n    \n    let k = Id.New(mut = false) \n    Lambda([k],\n        args |> List.rev |> List.fold (fun c (a, _) -> Lambda([a], c)) (Var k).[[inner]]\n    )\n  \nlet objty, objArrTy =\n    let t = typeof<System.Object>\n    let arrt = typeof<System.Object []>\n    Reflection.ReadTypeDefinition t,\n    Reflection.ReadTypeDefinition arrt\n  \n[<Sealed>]\ntype PrintF() =\n    inherit Macro()\n    override this.TranslateCtor(c) =\n        let rec getFunctionArgs f =\n            match f with\n            | FSharpFuncType(a, r) -> \n                a :: getFunctionArgs r\n            | _ -> \n                []\n        match c.Arguments with\n        | [I.Value (Literal.String fs)] ->\n            let ts = c.DefiningType.Generics.Head |> getFunctionArgs |> List.map (fun t -> t.SubstituteGenericsToSame(NonGenericType objty))\n            createPrinter c.Compilation ts fs |> MacroOk\n        | _ -> MacroError \"printfMacro error\"\n\n[<JavaScript>]\ntype private EquatableEqualityComparer<'T when 'T :> System.IEquatable<'T>>() =\n    inherit System.Collections.Generic.EqualityComparer<'T>()\n    override this.Equals(x, y) = (x :> System.IEquatable<_>).Equals(y)\n    override this.GetHashCode(x) = (box x).GetHashCode()\n\n[<JavaScript>]\ntype private BaseEqualityComparer<'T>() =\n    inherit System.Collections.Generic.EqualityComparer<'T>()\n    override this.Equals(x, y) = obj.Equals(box x, box y)\n    override this.GetHashCode(x) = (box x).GetHashCode()\n\nlet rec isImplementing (comp: M.ICompilation) typ intf =\n    comp.GetClassInfo typ\n    |> Option.map (fun cls ->\n        cls.Implementations |> Seq.exists (fun (KeyValue ((i, _), _)) -> i = intf)\n        || cls.BaseClass |> Option.exists (fun b -> isImplementing comp b intf |> Option.exists id) \n    )\n\n[<Sealed>]\ntype EqualityComparer() =\n    inherit Macro()\n\n    static let ieqTy =\n        TypeDefinition {\n            Assembly = \"mscorlib\"\n            FullName = \"System.IEquatable`1\"\n        } \n\n    static member GetDefault(comp: M.ICompilation, t: Type) =\n        if t.IsParameter then MacroNeedsResolvedTypeArg t else\n        match t with\n        | ConcreteType ct ->\n            match isImplementing comp ct.Entity ieqTy with\n            | Some isEquatable ->\n                let td : TypeDefinitionInfo =\n                    { Assembly = \"WebSharper.Main\"\n                      FullName =\n                        if isEquatable then\n                            \"WebSharper.MacroModule+EquatableEqualityComparer`1\"\n                        else\n                            \"WebSharper.MacroModule+BaseEqualityComparer`1\" }\n                Ctor (\n                    { Entity = Hashed td; Generics = [t] },\n                    Constructor { CtorParameters = [] },\n                    []\n                ) |> MacroOk\n            | _ -> MacroError \"\"\n        | _ -> MacroError \"Type form not recognized\"\n\n    override this.TranslateCall(c) =\n        match c.Method.Entity.Value.MethodName with\n        | \"get_Default\" -> EqualityComparer.GetDefault(c.Compilation, c.DefiningType.Generics.[0])\n        | _ -> MacroError \"Not implemented\"\n\n[<JavaScript>]\ntype private ComparableComparer<'T when 'T :> System.IComparable<'T>>() =\n    inherit System.Collections.Generic.Comparer<'T>()\n    override this.Compare(x, y) = (x :> System.IComparable<'T>).CompareTo(y)\n\n[<JavaScript>]\ntype private BaseComparer<'T when 'T : comparison>() =\n    inherit System.Collections.Generic.Comparer<'T>()\n    override this.Compare(x, y) = compare x y\n\n[<Sealed>]\ntype Comparer() =\n    inherit Macro()\n\n    static let icmpTy =\n        TypeDefinition {\n            Assembly = \"mscorlib\"\n            FullName = \"System.IComparable`1\"\n        } \n\n    static member GetDefault(comp: M.ICompilation, t: Type) =\n        if t.IsParameter then MacroNeedsResolvedTypeArg t else\n        match t with\n        | ConcreteType ct ->\n            match isImplementing comp ct.Entity icmpTy with\n            | Some isEquatable ->\n                let td : TypeDefinitionInfo =\n                    { Assembly = \"WebSharper.Main\"\n                      FullName =\n                        if isEquatable then\n                            \"WebSharper.MacroModule+ComparableComparer`1\"\n                        else\n                            \"WebSharper.MacroModule+BaseComparer`1\" }\n                Ctor(\n                    {Entity = Hashed td; Generics = [t]},\n                    Hashed<ConstructorInfo> { CtorParameters = [] },\n                    [])\n                |> MacroOk\n            | _ -> MacroError \"\"\n        | _ -> MacroError \"Type form not recognized\"\n\n    override this.TranslateCall(c) =\n        match c.Method.Entity.Value.MethodName with\n        | \"get_Default\" -> Comparer.GetDefault(c.Compilation, c.DefiningType.Generics.[0])\n        | _ -> MacroError \"Not implemented\"\n\n/// Returns 0 for number types, undefined for others.\n/// TODO: this is wrong for non-number value types!\n/// TODO: also always returns undefined when called generically.\n[<Sealed>]\ntype DefaultOf() =\n    inherit Macro()\n\n    override __.TranslateCall(c) =\n        let t = c.Method.Generics.[0]\n        if t.IsParameter then MacroNeedsResolvedTypeArg t else\n        match t with\n        | ConcreteType td when\n            (td.Entity.Value.Assembly.StartsWith \"mscorlib\" &&\n                match td.Entity.Value.FullName with\n                | \"System.SByte\"\n                | \"System.Byte\"\n                | \"System.Int16\"\n                | \"System.UInt16\"\n                | \"System.Int32\"\n                | \"System.UInt32\"\n                | \"System.Int64\"\n                | \"System.UInt64\"\n                | \"System.Decimal\"\n                | \"System.Single\"\n                | \"System.Double\"\n                | \"System.DateTime\"\n                | \"System.TimeSpan\" -> true\n                | _ -> false)\n            -> MacroOk (Value (Int 0))\n        | ConcreteType td -> \n            match c.Compilation.GetCustomTypeInfo td.Entity with\n            | M.StructInfo ->\n                let cdef = Hashed { CtorParameters = [] }\n                MacroOk (Ctor(td, cdef, []))\n            | _ ->\n                MacroOk (Value (Null))\n        | _ ->\n            MacroOk (Value (Null))\n\n[<Sealed>]\ntype DefaultToUndefined() =\n    inherit Macro()\n\n    static let tr =\n        { new Transformer() with\n            override this.TransformCall(thisObj, typ, meth, args) =\n                if Option.isNone thisObj && IsDefaultValue typ.Entity meth.Entity && List.isEmpty args then\n                    Undefined\n                else\n                    base.TransformCall(thisObj, typ, meth, args)  \n        }.TransformExpression\n\n    override __.TranslateCall(c) =\n        MacroOk <| tr c.Arguments.[0]\n\n[<Sealed>]\ntype TypeTest() =\n    inherit Macro()\n\n    override __.TranslateCall(c) =\n        TypeCheck(c.Arguments.Head, c.Method.Generics.Head) |> MacroOk\n\n[<Sealed>]\ntype InlineJS() =\n    inherit Macro()\n\n    override __.TranslateCall(c) =\n        match c.Arguments.Head with\n        | I.Value (String inl) ->\n            let args =\n                match c.Arguments with\n                | [_] -> [] \n                | [_; I.NewArray args] -> args\n                | _ -> failwith \"InlineJS error: arguments cannot be passed as an array\"\n            c.Compilation.ParseJSInline(inl, args) |> MacroOk\n        | _ -> failwith \"InlineJS error: first argument must be a constant string\"\n\nlet stringTy, lengthMeth, padLeft, padRight =\n    let t = typeof<System.String>\n    Reflection.ReadTypeDefinition t,\n    Reflection.ReadMethod (t.GetMethod \"get_Length\"),\n    Reflection.ReadMethod (t.GetMethod(\"PadLeft\", [|typeof<int>|])),\n    Reflection.ReadMethod (t.GetMethod(\"PadRight\", [|typeof<int>|]))\n\n[<Sealed>]\ntype StringFormat() =\n    inherit Macro()\n\n    let regExp = Regex(\"(?:(.*?){(0|[1-9]\\d*)(?:,(-?[1-9]\\d*|0))?(?::(.*?))?})|(.+)$\", RegexOptions.Singleline)\n\n    let safeToString expr =\n        Conditional(\n            expr ^== (Value Literal.Null),\n            cString \"\",\n            cCallG [\"String\"] [expr]\n        )\n\n    override __.TranslateCall(c) =\n        match c.DefiningType.Entity.Value.FullName, c.Method.Entity.Value.MethodName with\n        | \"System.String\", \"Format\" ->\n            match c.Arguments with\n            | (I.Value (String format)) :: args when args.Length < 4 ->\n                let args =\n                    match c.Method.Entity.Value.Parameters with\n                    | [_; x] ->\n                        try \n                            if x.TypeDefinition = objty then\n                                NewArray [args.[0]]\n                            else\n                                args.[0]\n                        with _ ->\n                            // Array type has no typedef\n                            args.[0]\n                    | [_; x1; x2] -> NewArray [args.[0]; args.[1]]\n                    | [_; x1; x2; x3] -> NewArray [args.[0]; args.[1]; args.[2]]\n                    | _ -> failwith \"Wrong number of arguments for String.Format\"\n\n                let warning = ref None\n                let argsId = Id.New(mut = false)\n               \n                let parts =\n                    regExp.Matches(format)\n                    |> Seq.cast<Match>\n                    |> Array.ofSeq\n\n                let body =\n                    if Array.isEmpty parts then cString \"\" else\n                    parts\n                    |> Seq.map (fun m ->\n                        if m.Groups.[5].Value <> \"\" then\n                            Value (Literal.String m.Groups.[5].Value)\n                        else\n                            let prefix = m.Groups.[1].Value\n                            let prefix s = Value (Literal.String prefix) ^+ s\n                            let idx = int m.Groups.[2].Value\n\n                            let r =\n                                Application(Global [\"WebSharper\"; \"Arrays\"; \"get\"], [Var argsId; cInt idx], Pure, Some 2)\n                                |> safeToString\n\n                            let spec = m.Groups.[4].Value\n                            if spec <> \"\" then\n                                warning := Some (sprintf \"String format specifiers are not supported: %s\" spec)\n\n                            if m.Groups.[3].Value <> \"\" then\n                                let w1 = int m.Groups.[3].Value\n                                let w2 = abs w1\n\n                                let expr =\n                                    Conditional(\n                                        cInt w2 ^> Call (None, NonGeneric stringTy, NonGeneric lengthMeth, [r]),\n                                        (\n                                            if w1 > 0 then\n                                                Call (None, NonGeneric stringTy, NonGeneric padLeft, [r; cInt w2])\n                                            else\n                                                Call (None, NonGeneric stringTy, NonGeneric padRight, [r; cInt w2])\n                                        ),\n                                        r\n                                    )\n                                prefix expr\n                            else prefix r\n                    )\n                    |> Seq.reduce (^+)\n\n                let result = Let(argsId, args, body)\n\n                let warningRes = !warning |> Option.map (fun w -> MacroWarning(w, MacroOk result))\n\n                defaultArg warningRes (MacroOk result)\n            \n            | _ -> MacroFallback\n        | _ -> MacroError \"proxy is for System.String.Format\"", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n/// Defines operators and functions that are automatically available whenever\n/// `WebSharper` is open.\n[<AutoOpen>]\nmodule WebSharper.JavaScript.Pervasives\n\nopen WebSharper\nmodule M = WebSharper.Macro\n\n/// Casts an object to the desired type.\n[<Inline \"$x\">]\nlet As<'T> (x: obj) = X<'T>\n\n[<Inline \"$x * $y\">]\nlet ( *. ) x y = X<obj>\n\n[<Inline \"$x / $y\">]\nlet ( /. ) x y = X<obj>\n\n[<Inline \"$x % $y\">]\nlet ( %. ) x y = X<obj>\n\n[<Inline \"$x + $y\">]\nlet ( +. ) x y = X<obj>\n\n[<Inline \"$x - $y\">]\nlet ( -. ) x y = X<obj>\n\n[<Inline \"$x << $y\">]\nlet ( <<. ) x y = X<obj>\n\n[<Inline \"$x >> $y\">]\nlet ( >>. ) x y = X<obj>\n\n[<Inline \"$x >>> $y\">]\nlet ( >>>. ) x y = X<obj>\n\n[<Inline \"$x < $y\">]\nlet ( <. ) x y = X<bool>\n\n[<Inline \"$x > $y\">]\nlet ( >. ) x y = X<bool>\n\n[<Inline \"$x >= $y\">]\nlet ( >=. ) x y = X<bool>\n\n[<Inline \"$x <= $y\">]\nlet ( <=. ) x y = X<bool>\n\n[<Inline \"$x == $y\">]\nlet ( ==. ) x y = X<bool>\n\n[<Inline \"$x === $y\">]\nlet ( ===. ) x y = X<bool>\n\n[<Inline \"$x != $y\">]\nlet ( !=. ) x y = X<bool>\n\n[<Inline \"$x !== $y\">]\nlet ( !==. ) x y = X<bool>\n\n[<Inline \"$x | $y\">]\nlet ( |. ) x y = X<obj>\n\n[<Inline \"$x & $y\">]\nlet ( &. ) x y = X<obj>\n\n[<Inline \"$x ^ $y\">]\nlet ( ^. ) x y = X<obj>\n\n[<Inline \"$obj[$field]\">]\nlet ( ? ) (obj: obj) (field: string) = X<'T>\n\n[<Inline \"void ($obj[$key] = $value)\">]\nlet ( ?<- ) (obj: obj) (key: string) (value: obj) = X<unit>\n\n[<Inline \"[$x,$y]\">]\nlet ( => ) (x: string) (y: obj) = (x, y)\n\ntype JS =\n    /// Parses and inlines JavaScript code\n    [<Macro(typeof<M.InlineJS>)>]\n    static member Inline<'T> (inlineString: string, [<System.ParamArray>] args: obj[]) = X<'T>\n\n[<JavaScript>]\nlet private NewFromSeq<'T> (fields: seq<string * obj>) : 'T =\n    let r = JS.Inline \"{}\"\n    for (k, v) in fields do\n        (?<-) r k v\n    As r\n\n/// Constructs a new object as if an object literal was used.\n[<Macro(typeof<M.New>); Inline>]\nlet New<'T> (fields: seq<string * obj>) = NewFromSeq<'T> fields\n\n/// Constructs an proxy to a remote object instance.\n[<Constant null>]\nlet Remote<'T> = X<'T>\n\n/// Gets JavaScript properties in sequence dynamically from an object.\n[<JavaScript; Macro(typeof<M.GetJS>)>]\nlet GetJS<'T> (x: obj) (items: seq<string>) =\n    let mutable x = x\n    for i in items do\n        x <- x?(i)\n    As<'T> x    \n\n/// Erases generic parameters inside this expression during WebSharper translation.\n/// You can get use this to translate `defaultof` inside a generic function.\n[<Macro(typeof<M.DefaultToUndefined>)>]\nlet DefaultToUndefined<'T> (x: 'T) = x\n\nmodule Optional =\n    /// Converts an F# option value to a JavaScript erased option\n    [<Inline>]\n    let ofOption x =\n        match x with\n        | None -> Undefined\n        | Some v -> Defined v\n\n    /// Converts a JavaScript erased option to an F# option value\n    [<Inline>]\n    let toOption x =\n        match x with\n        | Undefined -> None\n        | Defined v -> Some v\n\nmodule Union =\n// {{ generated by genInterop.fsx, do not modify\n    /// Converts an F# Choice value to a JavaScript erased union\n    [<Inline \"$x.$1\">]\n    let ofChoice2 (x: Choice<'T1, 'T2>) = X<Union<'T1, 'T2>>\n    /// Converts a JavaScript erased union to an F# Choice value\n    [<Inline>]\n    let toChoice2 x =\n        match x with\n        | Union1Of2 v -> Choice1Of2 v\n        | Union2Of2 v -> Choice2Of2 v\n    /// Converts an F# Choice value to a JavaScript erased union\n    [<Inline \"$x.$1\">]\n    let ofChoice3 (x: Choice<'T1, 'T2, 'T3>) = X<Union<'T1, 'T2, 'T3>>\n    /// Converts a JavaScript erased union to an F# Choice value\n    [<Inline>]\n    let toChoice3 x =\n        match x with\n        | Union1Of3 v -> Choice1Of3 v\n        | Union2Of3 v -> Choice2Of3 v\n        | Union3Of3 v -> Choice3Of3 v\n    /// Converts an F# Choice value to a JavaScript erased union\n    [<Inline \"$x.$1\">]\n    let ofChoice4 (x: Choice<'T1, 'T2, 'T3, 'T4>) = X<Union<'T1, 'T2, 'T3, 'T4>>\n    /// Converts a JavaScript erased union to an F# Choice value\n    [<Inline>]\n    let toChoice4 x =\n        match x with\n        | Union1Of4 v -> Choice1Of4 v\n        | Union2Of4 v -> Choice2Of4 v\n        | Union3Of4 v -> Choice3Of4 v\n        | Union4Of4 v -> Choice4Of4 v\n    /// Converts an F# Choice value to a JavaScript erased union\n    [<Inline \"$x.$1\">]\n    let ofChoice5 (x: Choice<'T1, 'T2, 'T3, 'T4, 'T5>) = X<Union<'T1, 'T2, 'T3, 'T4, 'T5>>\n    /// Converts a JavaScript erased union to an F# Choice value\n    [<Inline>]\n    let toChoice5 x =\n        match x with\n        | Union1Of5 v -> Choice1Of5 v\n        | Union2Of5 v -> Choice2Of5 v\n        | Union3Of5 v -> Choice3Of5 v\n        | Union4Of5 v -> Choice4Of5 v\n        | Union5Of5 v -> Choice5Of5 v\n    /// Converts an F# Choice value to a JavaScript erased union\n    [<Inline \"$x.$1\">]\n    let ofChoice6 (x: Choice<'T1, 'T2, 'T3, 'T4, 'T5, 'T6>) = X<Union<'T1, 'T2, 'T3, 'T4, 'T5, 'T6>>\n    /// Converts a JavaScript erased union to an F# Choice value\n    [<Inline>]\n    let toChoice6 x =\n        match x with\n        | Union1Of6 v -> Choice1Of6 v\n        | Union2Of6 v -> Choice2Of6 v\n        | Union3Of6 v -> Choice3Of6 v\n        | Union4Of6 v -> Choice4Of6 v\n        | Union5Of6 v -> Choice5Of6 v\n        | Union6Of6 v -> Choice6Of6 v\n    /// Converts an F# Choice value to a JavaScript erased union\n    [<Inline \"$x.$1\">]\n    let ofChoice7 (x: Choice<'T1, 'T2, 'T3, 'T4, 'T5, 'T6, 'T7>) = X<Union<'T1, 'T2, 'T3, 'T4, 'T5, 'T6, 'T7>>\n    /// Converts a JavaScript erased union to an F# Choice value\n    [<Inline>]\n    let toChoice7 x =\n        match x with\n        | Union1Of7 v -> Choice1Of7 v\n        | Union2Of7 v -> Choice2Of7 v\n        | Union3Of7 v -> Choice3Of7 v\n        | Union4Of7 v -> Choice4Of7 v\n        | Union5Of7 v -> Choice5Of7 v\n        | Union6Of7 v -> Choice6Of7 v\n        | Union7Of7 v -> Choice7Of7 v\n// }}\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nmodule WebSharper.Json\n\nopen WebSharper.JavaScript\nmodule Js = WebSharper.Core.Json\nmodule Re = WebSharper.Core.Resources\n\ntype Resource() =\n    interface Re.IResource with\n        member this.Render ctx =\n            let name = if ctx.DebuggingEnabled then \"Json.js\" else \"Json.min.js\"\n            let ren = Re.Rendering.GetWebResourceRendering(ctx, typeof<Resource>, name)\n            fun html ->\n                let html = html Re.Scripts\n                html.WriteLine \"<!--[if lte IE 7.0]>\"\n                ren.Emit(html, Re.Js)\n                html.WriteLine \"<![endif]-->\"\n\n[<Inline \"$obj[$field]\">]\nlet ( ? ) (obj: obj) (field: string) = X<'T>\n\n[<Inline \"void ($obj[$key] = $value)\">]\nlet ( ?<- ) (obj: obj) (key: string) (value: obj) = X<unit>\n\n[<Inline \"$x\">]\nlet As<'T> (x: obj) = X<'T>\n\n[<Inline \"JSON.parse($json)\">]\n[<Require(typeof<Resource>)>]\nlet Parse (json: string) = X<obj>\n\n[<Inline \"JSON.stringify($obj)\">]\n[<Require(typeof<Resource>)>]\nlet Stringify (obj: obj) = X<string>\n\n/// Lookups an object by its FQN.\n[<JavaScript>]\nlet lookup<'T> (x: string []) : obj =\n    let k = x.Length\n    let mutable r = JS.Global\n    let mutable i = 0\n    while i < k do\n        let n  = x.[i]\n        let rn = (?) r n\n        if JS.TypeOf rn <> JS.Undefined then\n            r <- rn\n            i <- i + 1\n        else\n            failwith (\"Invalid server reply. Failed to find type: \" + n)\n    r\n\n/// Does a shallow generic mapping over an object.\n[<JavaScript>]\nlet shallowMap (f: obj -> obj) (x: obj) : obj =\n    if x :? System.Array then\n        As (Array.map f (As x))\n    else\n        match JS.TypeOf x with\n        | JS.Object ->\n            let r = New []\n            JS.ForEach x (fun y -> (?<-) r y (f ((?) x y)); false)\n            r\n        | _ ->\n            x\n\n[<JavaScript>]\n[<Require(typeof<Resource>)>]\nlet Activate<'T> (json: obj) : 'T =\n    let types = As<obj[]> ((?) json \"$TYPES\")\n    for i = 0 to types.Length - 1 do\n        types.[i] <- lookup (As types.[i])\n    let rec decode (x: obj) : obj =\n        if x = null then x else\n            match JS.TypeOf x with\n            | JS.Object ->\n                if x :? System.Array then\n                    shallowMap decode x\n                else\n                    let o  = shallowMap decode ((?) x \"$V\")\n                    let ti = (?) x \"$T\"\n                    if JS.TypeOf ti = JS.Kind.Undefined then o else\n                        let t = types.[ti]\n                        if t ===. JS.Global?WebSharper?List?T then\n                            box (List.ofArray (As<obj[]> o))\n                        else\n                            let r = JS.New types.[ti]\n                            JS.ForEach o (fun k -> (?<-) r k ((?) o k); false)\n                            r\n            | _ ->\n                x\n    As (decode ((?) json \"$DATA\"))\n\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nmodule WebSharper.Remoting\n\nopen WebSharper.JavaScript\n\nmodule R = WebSharper.Core.Remoting\n\n[<JavaScript>]\nlet mutable EndPoint = \"?\"\n\n[<JavaScript>]\nlet UseHttps() =\n    try\n        if not (JS.Window.Location.Href.StartsWith \"https://\") then\n            EndPoint <- JS.Window.Location.Href.Replace(\"http://\", \"https://\")\n            true\n        else false\n    with _ ->\n        // This function is intended to be callable from the top-level in a module,\n        // which means that it will be (unnecessarily) called on the server too\n        // and throw NotImplementedException. Just silence it.\n        false\n\ntype Data = string\ntype Headers = obj\ntype Url = string\n\n[<JavaScript>]\ntype IAjaxProvider =\n    [<Name \"Async\">]\n    abstract member Async : Url -> Headers -> Data -> (Data -> unit) -> (exn -> unit) -> unit\n\n    [<Name \"Sync\">]\n    abstract member Sync : Url -> Headers -> Data -> Data\n\n[<Direct @\"\n    var xhr = new XMLHttpRequest();\n    var csrf = document.cookie.replace(new RegExp('(?:(?:^|.*;)\\\\s*csrftoken\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$'), '$1');\n    xhr.open('POST', $url, $async);\n    if ($async == true) {\n        xhr.withCredentials = true;\n    }\n    for (var h in $headers) {\n        xhr.setRequestHeader(h, $headers[h]);\n    }\n    if (csrf) {\n        xhr.setRequestHeader('x-csrftoken', csrf);\n    }\n    function k() {\n        if (xhr.status == 200) {\n            $ok(xhr.responseText)\n        } else if ($csrf && xhr.status == 403 && xhr.responseText == 'CSRF') {\n            $csrf();\n        } else {\n            var msg = 'Response status is not 200: ';\n            $err(new Error(msg + xhr.status));\n        }\n    }\n    if ('onload' in xhr) {\n        xhr.onload = xhr.onerror = xhr.onabort = k;\n    } else {\n        xhr.onreadystatechange = function () {\n            if (xhr.readyState == 4) {\n                k();\n            }\n        };\n    }\n    xhr.send($data);\n\">]\nlet private ajax (async: bool) (url: Url) (headers: Headers) (data: Data)\n    (ok: Data -> unit) (err: exn -> unit) (csrf: unit -> unit) = ()\n\ntype XhrProvider [<JavaScript>] () =\n    interface IAjaxProvider with\n\n        [<JavaScript>]\n        member this.Async url headers data ok err =\n            ajax true url headers data ok err\n                (fun () -> ajax true url headers data ok err JS.Undefined)\n\n        [<JavaScript>]\n        member this.Sync url headers data =\n            let res = ref Unchecked.defaultof<_>\n            ajax false url headers data\n                (fun x -> res := x)\n                (fun e -> raise e)\n                (fun () ->\n                    ajax false url headers data\n                        (fun x -> res := x)\n                        (fun e -> raise e)\n                        JS.Undefined)\n            !res\n\n[<JavaScript>]\nlet mutable AjaxProvider = XhrProvider() :> IAjaxProvider\n\n[<JavaScript>]\nlet private makeHeaders (m: string) =\n    New [\n        \"content-type\" => \"application/json\"   \n        \"x-websharper-rpc\" => m\n    ]\n\n[<JavaScript>]\nlet private makePayload (data: obj []) =\n    Json.Stringify data\n\n[<JavaScript>]\ntype IRemotingProvider =\n    [<Name \"Sync\">]\n    abstract member Sync : string -> obj[] -> obj\n    [<Name \"Async\">]\n    abstract member Async : string -> obj[] -> Async<obj>\n    [<Name \"Task\">]\n    abstract member Task : string -> obj[] -> System.Threading.Tasks.Task<obj>\n    [<Name \"Send\">]\n    abstract member Send : string -> obj[] -> unit\n\n[<JavaScript>]\n[<Name \"WebSharper.Remoting.AjaxRemotingProvider\">]\ntype AjaxRemotingProvider() =\n    abstract EndPoint : string\n    override this.EndPoint = EndPoint\n\n    abstract AsyncBase : string * obj[] -> Async<obj> \n    override this.AsyncBase(m, data) = \n        async {\n            let headers = makeHeaders m\n            let payload = makePayload data\n            let! token = Async.CancellationToken\n            return! Async.FromContinuations (fun (ok, err, cc) ->\n                let waiting = ref true\n                let reg =\n                    token.Register(fun () ->\n                        if !waiting then\n                            waiting := false\n                            cc (new System.OperationCanceledException(token))\n                    )\n                let ok (x: Data) = \n                    if !waiting then\n                        waiting := false\n                        (reg :> System.IDisposable).Dispose()\n                        ok (Json.Activate (Json.Parse x))\n                let err (e: exn) =\n                    if !waiting then\n                        waiting := false\n                        (reg :> System.IDisposable).Dispose()\n                        err e\n                AjaxProvider.Async this.EndPoint headers payload ok err)\n        }\n\n    interface IRemotingProvider with\n        member this.Sync m data : obj =\n            let data = AjaxProvider.Sync this.EndPoint (makeHeaders m) (makePayload data)\n            Json.Activate (Json.Parse data)\n\n        member this.Async m data : Async<obj> =\n            this.AsyncBase(m, data)\n\n        member this.Task m data : System.Threading.Tasks.Task<obj> =\n            this.AsyncBase(m, data) |> Async.StartAsTask   \n\n        member this.Send m data =\n            Async.Start (Async.Ignore (this.AsyncBase(m, data)))\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen WebSharper\nopen WebSharper.JavaScript\nopen WebSharper.JQuery\nmodule M = WebSharper.Core.Metadata\nmodule J = WebSharper.Core.Json\n\n/// An interface that has to be implemented by controls\n/// that depend on resources.\ntype IRequiresResources =\n    abstract member Requires : seq<M.Node>\n    abstract member Encode : M.Info * J.Provider -> list<string * J.Encoded>\n\n/// HTML content that can be used as the Body of a web Control.\n/// Can be zero, one or many DOM nodes.\ntype IControlBody =\n    /// Replace the given node with the HTML content.\n    /// The node is guaranteed to be present in the DOM.\n    /// Called exactly once on startup on an IControl's Body.\n    [<JavaScript; Name \"ReplaceInDom\">]\n    abstract ReplaceInDom : Dom.Node -> unit\n\n/// An interface that has to be implemented by controls that\n/// are subject to activation, ie. server-side controls that\n/// contain client-side elements.\ntype IControl =\n    inherit IRequiresResources\n    [<JavaScript; Name \"Body\">]\n    abstract member Body : IControlBody\n    abstract member Id : string\n\n[<AutoOpen>]\nmodule HtmlContentExtensions =\n\n    [<JavaScript>]\n    type private SingleNode(node: Dom.Node) =\n        interface IControlBody with\n            member this.ReplaceInDom(old) =\n                node.ParentNode.ReplaceChild(node, old) |> ignore\n\n    [<JavaScript>]\n    type IControlBody with\n        /// Create HTML content comprised of a single DOM node.\n        static member SingleNode (node: Dom.Node) =\n            new SingleNode(node) :> IControlBody\n\nmodule Activator =\n\n    /// The identifier of the meta tag holding the controls.\n    [<Literal>]\n    let META_ID = \"websharper-data\"\n\n    [<Direct \"typeof document !== 'undefined'\">]\n    let private hasDocument () = false\n\n    [<JavaScript>]\n    let private Activate() =\n        if hasDocument () then\n            let meta = JS.Document.GetElementById(META_ID)\n            if (As meta) then\n                JQuery.Of(JS.Document).Ready(fun () ->\n                    let text = meta.GetAttribute(\"content\")\n                    let obj = Json.Activate (Json.Parse text)\n                    JS.GetFields obj\n                    |> Array.iter (fun (k, v) ->\n                        let p = (As<IControl> v).Body\n                        let old = JS.Document.GetElementById k\n                        p.ReplaceInDom old)\n                ).Ignore\n\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n/// Defines macros used by proxy definitions.\nmodule private WebSharper.Utils\n\nopen WebSharper.JavaScript\n\n[<JavaScript>]\nlet toSafe (s: string) =\n    if s ==. null then \"\" else s  \n\n[<JavaScript>]\nlet plusForPos (n: obj, s) =\n    if 0 <=. n then \"+\" + s else s     \n\n[<JavaScript>]\nlet spaceForPos (n: obj, s) =\n    if 0 <=. n then \" \" + s else s      \n\n[<Inline \"$s.substr(1)\">]\nlet skip1 (s: string) = X<string>\n\n[<JavaScript>]\nlet padNumLeft (s: string, l) =\n    let f = (As<string[]> s).[0]\n    if f = \" \" || f = \"+\" || f = \"-\" then\n        f + (skip1 s).PadLeft(l - 1, '0')\n    else s.PadLeft(l, '0')\n\n[<JavaScript>]\nlet printList (p: obj -> string, o: obj list) =\n    \"[\" + (o |> Seq.map p |> String.concat \"; \") + \"]\" \n\n[<JavaScript>]\nlet printArray (p: obj -> string, o: obj[]) =\n    if o ===. null then \"null\" else\n    \"[|\" + (o |> Array.map p |> String.concat \"; \") + \"|]\" \n\n[<JavaScript>]\nlet printArray2D (p: obj -> string, o: obj[,]) =\n    if o ===. null then \"null\" else\n     \"[[\" + (\n        seq {\n            let l2 = Array2D.length2 o\n            for i in 0 .. Array2D.length1 o - 1 ->\n                seq { for j in 0 .. l2 - 1 -> p o.[i, j] } \n                |> String.concat \"; \"\n        }\n        |> String.concat \"][\"\n     ) + \"]]\" \n\n[<JavaScript>]\nlet rec prettyPrint (o: obj) =\n    let printObject (o: obj) =\n        let s = string o\n        if s = \"[object Object]\" then\n            \"{\" + (JS.GetFields o |> Array.map (fun (k, v) -> k + \" = \" + prettyPrint v) |> String.concat \"; \") + \"}\"\n        else s\n    if o ===. null then \"null\" else\n    let t = JS.TypeOf o\n    if t  ==. JS.String then\n        \"\\\"\" + As o + \"\\\"\"\n    elif t  ==. JS.Object then\n        if o :? System.Array then\n            \"[|\" + (As o |> Array.map prettyPrint |> String.concat \"; \") + \"|]\"\n        else printObject o\n    else string o\n\n[<JavaScript>]\n[<Name \"WebSharper.Operators.charRange\">]\nlet charRange (min: char) (max: char) : seq<char> =\n    let minv = int min\n    let count = 1 + int max - minv\n    if count <= 0 then Seq.empty\n    else Seq.init count (fun x -> char (x + minv))\n\n[<JavaScript>]\n[<Name \"WebSharper.Nullable.op\">]\nlet nullableOp (a: obj) (b: obj) f = if a ==. null || b ==. null then null else f a b\n\n[<JavaScript>]\n[<Name \"WebSharper.Nullable.opL\">]\nlet nullableOpL (a: obj) (b: obj) f = if a ==. null then null else f a b\n\n[<JavaScript>]\n[<Name \"WebSharper.Nullable.opR\">]\nlet nullableOpR (a: obj) (b: obj) f = if b ==. null then null else f a b\n\n[<JavaScript>]\n[<Name \"WebSharper.Nullable.cmp\">]\nlet nullableCmp (a: obj) (b: obj) f = if a ==. null || b ==. null then false else f a b\n\n[<JavaScript>]\n[<Name \"WebSharper.Nullable.cmpE\">]\nlet nullableCmpE (a: obj) (b: obj) f =\n    if a ==. null then\n        b ==. null\n    elif b ==. null then \n        false \n    else f a b\n\n[<JavaScript>]\n[<Name \"WebSharper.Nullable.cmpL\">]\nlet nullableCmpL (a: obj) (b: obj) f = if a ==. null then false else f a b\n\n[<JavaScript>]\n[<Name \"WebSharper.Nullable.cmpR\">]\nlet nullableCmpR (a: obj) (b: obj) f = if b ==. null then false else f a b\n\n[<JavaScript>]\n[<Name \"WebSharper.Nullable.conv\">]\nlet nullableConv (a: obj) f = if a ==. null then null else f a", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n/// Implements concurrency primitives.\nmodule internal WebSharper.Concurrency\n\nopen WebSharper\nopen WebSharper.JavaScript\n\ntype private OCE = System.OperationCanceledException\n\n[<JavaScript; Prototype false>]\ntype Result<'T> =\n    | Ok of 'T\n    | No of exn\n    | Cc of OCE\n  \n[<JavaScript; Prototype false>]\ntype CT =\n    { \n        [<Name \"c\">] mutable IsCancellationRequested : bool \n        [<Name \"r\">] Registrations : (unit -> unit)[]\n    }\n\n[<Inline \"$arr.push($item)\">]\nlet private push arr item = X<int>\n\n[<JavaScript>]\nlet internal noneCT =           \n    { \n        IsCancellationRequested = false\n        Registrations = [||]\n    }\n\n[<JavaScript>]\nlet internal Register (ct: CT) (callback: unit -> unit) =\n    if ct ===. noneCT then\n        { new System.IDisposable with\n            member this.Dispose() = ()\n        }\n    else\n        let i = push ct.Registrations callback - 1\n        { new System.IDisposable with\n            member this.Dispose() = ct.Registrations.[i] <- ignore\n        }\n\n[<JavaScript; Prototype false>]\ntype AsyncBody<'T> =\n    {\n        k  : Result<'T> -> unit\n        ct : CT\n    }\n\ntype Concurrent<'T>     = AsyncBody<'T> -> unit\nand private C<'T>       = Concurrent<'T>\n\ntype private Queue<'T>  = System.Collections.Generic.Queue<'T>\ntype Milliseconds       = int\n\ntype private Scheduler [<JavaScript>]() =\n    let mutable idle    = true\n    let robin           = Queue<unit->unit>()\n\n    [<JavaScript>]\n    let rec tick () =\n        let t = System.DateTime.Now\n        let mutable loop = true\n        while loop do\n            match robin.Count with\n            | 0 ->\n                idle <- true\n                loop <- false\n            | _ ->\n                robin.Dequeue()()\n                if System.DateTime.Now - t > System.TimeSpan.FromMilliseconds 40. then\n                    JS.SetTimeout tick 0 |> ignore\n                    loop <- false\n\n    [<JavaScript>]\n    member this.Fork(action: unit -> unit) =\n        robin.Enqueue action\n        if idle then\n            idle <- false\n            JS.SetTimeout tick 0 |> ignore\n\n[<JavaScript>]\nlet private scheduler = Scheduler()\n\n[<JavaScript>]\nlet internal defCTS = ref(new System.Threading.CancellationTokenSource())\n\n[<Inline>]\nlet fork action = scheduler.Fork action\n\n[<JavaScript>]\nlet private cancel c = c.k (Cc (new OCE(As<System.Threading.CancellationToken> c.ct)))\n\n[<JavaScript>]\nlet private checkCancel r =\n    ()\n    fun c -> if c.ct.IsCancellationRequested then cancel c else r c\n\n[<JavaScript; Pure>]\nlet Return (x: 'T) : C<'T> =\n    ()\n    fun c -> c.k (Ok x)\n\n[<JavaScript; Pure>]\nlet Zero =\n    Return ()\n\n[<JavaScript; Pure>]\nlet Bind (r: C<'T>, f: 'T -> C<'R>) =\n    checkCancel <| fun c ->\n        r { \n            k = function \n                | Ok x -> fork (fun () -> try f x c with e -> c.k (No e))\n                | res  -> fork (fun () -> c.k (As res)) // error or cancellation\n            ct = c.ct\n        }\n\n[<JavaScript; Pure>]\nlet Combine (a: C<unit>, b: C<'T>) : C<'T> = \n    Bind (a, fun _ -> b)\n\n[<Inline>]\nlet Ignore (r: C<'T>): C<unit> = As<C<unit>> r\n\n[<JavaScript; Pure>]\nlet Delay (mk: unit -> C<'T>) : C<'T> =\n    ()\n    fun c ->\n        try mk () c with e -> c.k (No e)\n\n[<JavaScript; Pure>]\nlet TryFinally (run: C<'T>, f: unit -> unit) : C<'T> =\n    ()\n    fun c ->\n        run {\n            k = fun r -> \n                try f ()\n                    c.k r \n                with e -> c.k (No e)\n            ct = c.ct\n        }\n\n[<JavaScript; Pure>]\nlet TryWith (r: C<'T>, f: exn -> C<'T>) : C<'T> =\n    ()\n    fun c ->\n        r {\n            k = function\n                | Ok x -> c.k (Ok x)\n                | No e as res -> try f e c with e -> c.k (As res)\n                | res -> c.k (As res)\n            ct = c.ct\n        }\n\n[<JavaScript; Pure>]\nlet Catch (r : C<'T>) : C<Choice<'T, exn>> =\n    ()\n    fun c ->\n        try r {\n                k = function \n                    | Ok x -> c.k (Ok (Choice1Of2 x))\n                    | No e -> c.k (Ok (Choice2Of2 e))\n                    | res  -> c.k (As res)\n                ct = c.ct\n            }\n        with e -> c.k (Ok (Choice2Of2 e))\n\n[<JavaScript; Pure>]\nlet GetCT : C<CT> =\n    ()\n    fun c -> c.k (Ok c.ct)\n\n[<JavaScript; Pure>]\nlet FromContinuations (subscribe: ('T -> unit) * (exn -> unit) * (OCE -> unit) -> unit) : C<'T> =\n    ()\n    fun c ->\n        let continued = ref false\n        let once cont : unit =\n            if !continued then failwith \"A continuation provided by Async.FromContinuations was invoked multiple times\" else\n            continued := true\n            fork cont   \n        subscribe (\n            fun a -> once (fun () -> c.k (Ok a))\n        ,   fun e -> once (fun () -> c.k (No e))\n        ,   fun e -> once (fun () -> c.k (Cc e))\n        )\n\n[<JavaScript>]\nlet StartWithContinuations (c: C<'T>, s: 'T -> unit, f: exn -> unit, cc: OCE -> unit, ctOpt) =\n    let ct = defaultArg ctOpt (As !defCTS)\n    if not ct.IsCancellationRequested then\n        c {\n            k = function\n                | Ok x -> s x\n                | No e -> f e\n                | Cc e -> cc e\n            ct = ct\n        }\n\n[<JavaScript>]\nlet UncaughtAsyncError (e: exn) =\n    Console.Log (\"WebSharper: Uncaught asynchronous exception\", e)\n\n[<JavaScript>]\nlet Start (c: C<unit>, ctOpt) =\n    let ct = defaultArg ctOpt (As !defCTS)\n    fork (fun () -> \n        if not ct.IsCancellationRequested then\n            c {\n                k = function\n                    | No e -> UncaughtAsyncError e\n                    | _ -> ()\n                ct = ct\n            }\n    )\n\n[<JavaScript>]\nlet StartImmediate (c: C<unit>, ctOpt) =\n    let ct = defaultArg ctOpt (As !defCTS)\n    if not ct.IsCancellationRequested then\n        c {\n            k = function\n                | No e -> UncaughtAsyncError e\n                | _ -> ()\n            ct = ct\n        }\n\n#nowarn \"40\"\n\n[<JavaScript; Pure>]\nlet AwaitEvent (e: IEvent<'T>, ca: option<unit -> unit>) : C<'T> =\n    ()\n    fun c ->\n        let mutable sub = JS.Undefined<System.IDisposable>\n        let mutable creg = JS.Undefined<System.IDisposable>\n        sub <-\n            e.Subscribe (fun x -> \n                sub.Dispose()\n                creg.Dispose()\n                fork (fun () -> c.k (Ok x))        \n            )\n        creg <-\n            Register c.ct (fun () -> \n                match ca with\n                | Some ca ->\n                    ca()\n                | _ ->\n                    sub.Dispose()\n                    fork (fun () -> cancel c)    \n            ) \n\n[<JavaScript; Pure>]\nlet AwaitTask (t: System.Threading.Tasks.Task) : C<unit> =\n    FromContinuations (fun (ok, err, cc) ->\n        if t.Status = System.Threading.Tasks.TaskStatus.Created then\n            t.Start()\n        t.ContinueWith(fun t ->\n            if t.IsCanceled then\n                cc (OCE())\n            elif t.IsFaulted then\n                err t.Exception\n            else\n                ok()   \n        ) |> ignore\n    )\n\n[<JavaScript; Pure>]\nlet AwaitTask1 (t: System.Threading.Tasks.Task<'T>) : C<'T> =\n    FromContinuations (fun (ok, err, cc) ->\n        if t.Status = System.Threading.Tasks.TaskStatus.Created then\n            t.Start()\n        t.ContinueWith(fun (t: System.Threading.Tasks.Task<'T>) ->\n            if t.IsCanceled then\n                cc (OCE())\n            elif t.IsFaulted then\n                err t.Exception\n            else\n                ok t.Result  \n        ) |> ignore\n    )\n\n[<JavaScript>]\nlet StartAsTask (c: C<'T>, ctOpt) =\n    let tcs = System.Threading.Tasks.TaskCompletionSource<'T>()\n    StartWithContinuations (c, tcs.SetResult, tcs.SetException, (fun _ -> tcs.SetCanceled()), ctOpt)\n    tcs.Task\n\n[<JavaScript; Pure>]\nlet Sleep (ms: Milliseconds) : C<unit> =\n    ()\n    fun c ->\n        let mutable pending = JS.Undefined<JS.Handle>\n        let mutable creg = JS.Undefined<System.IDisposable>\n        pending <-\n            JS.SetTimeout (fun () -> \n                creg.Dispose()\n                fork (fun () -> c.k (Ok ()))\n            ) ms\n        creg <-\n            Register c.ct (fun () -> \n                JS.ClearTimeout pending\n                fork (fun () -> cancel c)\n            )\n\n[<JavaScript; Pure>]\nlet Parallel (cs: seq<C<'T>>) : C<'T[]> =\n    let cs = Array.ofSeq cs\n    if cs.Length = 0 then Return [||] else\n    fun c ->\n        let n = Array.length cs\n        let o = ref n\n        let a = As<'T[]>(JavaScript.Array(n))\n        let accept i x =\n            match !o, x with\n            | 0, _     -> ()\n            | 1, Ok x  -> a.[i] <- x; o := 0; c.k (Ok a)\n            | n, Ok x  -> a.[i] <- x; o := n - 1\n            | n, res   -> o := 0; c.k (As res)\n        Array.iteri (fun i run ->\n            fork (fun () -> run { k = accept i; ct = c.ct }))\n            cs\n\n[<JavaScript; Pure>]\nlet StartChild (r : C<'T>, t: Milliseconds option) : C<C<'T>> =\n    ()\n    fun c ->\n        let inTime = ref true\n        let cached = ref None\n        let queue  = Queue()\n        let tReg =\n            match t with\n            | Some timeout ->\n                JS.SetTimeout (fun () ->\n                    inTime := false\n                    let err = No (System.TimeoutException())\n                    while queue.Count > 0 do\n                        queue.Dequeue() err\n                ) timeout |> Some     \n            | _ -> None\n        fork (fun _ ->\n            if not c.ct.IsCancellationRequested then\n                r {\n                    k = fun res ->\n                        if !inTime then\n                            cached := Some res\n                            match tReg with\n                            | Some r -> JS.ClearTimeout r\n                            | _ -> ()\n                            while queue.Count > 0 do\n                                queue.Dequeue() res\n                    ct = c.ct\n                }\n        )\n        let r2 c2 =            \n            if !inTime then\n                match cached.Value with\n                | Some x    -> c2.k x\n                | None      -> queue.Enqueue c2.k\n            else c2.k (No (System.TimeoutException()))\n        c.k (Ok r2)\n\n[<JavaScript; Pure>]\nlet OnCancel (action: unit -> unit) : C<System.IDisposable> =\n    ()\n    fun c -> c.k (Ok (Register c.ct action))\n\n[<JavaScript; Pure>]\nlet TryCancelled (run: C<'T>, comp: OCE -> unit) : C<'T> =\n    ()\n    fun c ->\n        run {\n            k = function\n                | Cc e as res ->\n                    comp e\n                    c.k res\n                | res -> c.k res\n            ct = c.ct\n        }\n\n[<JavaScript; Pure>]\nlet Using (x: 'U, f: 'U -> C<'T>) =\n    TryFinally (f x, fun () -> (x :> System.IDisposable).Dispose())\n\n[<JavaScript; Pure>]\nlet rec While (g: unit -> bool, c: C<unit>) : C<unit> = \n    if g() then \n        Bind (c, fun () -> While (g, c)) \n    else\n        Return ()\n\n[<JavaScript; Pure>]\nlet rec For (s: seq<'T>, b: 'T -> C<unit>) =\n    Using (s.GetEnumerator(), fun ie -> \n        While ((fun () -> ie.MoveNext()), \n            Delay (fun () -> b ie.Current)))\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n/// Provides an `IEnumerator` implementation.\nmodule private WebSharper.Enumerator\n\nopen WebSharper.JavaScript\ntype IE<'T> = System.Collections.Generic.IEnumerator<'T>\n\n/// Represents an unfolding enumerator.\n[<Sealed>]\ntype T<'S,'T> [<JavaScript>] (s: 'S, c: 'T, n: T<'S,'T> -> bool, d: T<'S,'T> -> unit) =\n    [<Inline; JavaScript>] \n    member this.MoveNext() = n this\n    member this.State with [<Inline; JavaScript>] get() = s and [<Inline; JavaScript>] set (v: 'S) = this?s <- v\n    member this.Current with [<Inline; JavaScript>] get() = c and [<Inline; JavaScript>] set (v: 'T) = this?c <- v\n\n    interface System.Collections.IEnumerator with\n        [<JavaScript>] \n        member this.MoveNext() = n this\n        [<JavaScript>]\n        member this.Current with get() = box c\n        member this.Reset() = failwith \"IEnumerator.Reset not supported\"\n\n    interface System.Collections.Generic.IEnumerator<'T> with\n        [<JavaScript>]\n        member this.Current with get() = c\n\n    interface System.IDisposable with\n        [<JavaScript>] \n        member this.Dispose() = if As d then d this\n\n/// Constructs a new `IEnumerator` by unfolding a function.\n[<Inline>]\n[<JavaScript>]\nlet New<'S,'T> (state: 'S) (next: T<'S,'T> -> bool) =\n    As<IE<'T>> (new T<'S,'T>(state, As null, next, As JS.Undefined)) \n\n[<Inline>]\n[<JavaScript>]\nlet NewDisposing<'S,'T> (state: 'S) dispose (next: T<'S,'T> -> bool) =\n    As<IE<'T>> (new T<'S,'T>(state, As null, next, dispose))\n\n[<Inline \"$x.GetEnumerator()\">]\nlet getEnumerator (x: obj) : IE<'T> = X\n\n[<JavaScript>]\nlet ArrayEnumerator (s: obj[]) =\n    New 0 (fun e ->\n        let i = e.State\n        if i < s.Length then\n            e.Current <- As s.[i]\n            e.State <- i + 1\n            true\n        else\n            false)\n\n[<JavaScript>]\nlet StringEnumerator (s: string) =\n    New 0 (fun e ->\n        let i = e.State\n        if i < s.Length then\n            e.Current <- As s.[i]\n            e.State <- i + 1\n            true\n        else\n            false)\n\n[<JavaScript>]\nlet Get (x: seq<'T>) : IE<'T> =\n    if x :? System.Array then\n        ArrayEnumerator (As x)\n    elif JS.TypeOf x = JS.String then\n        StringEnumerator (As x)\n    else\n        getEnumerator x\n\n[<Inline \"'GetEnumerator0' in $x ? $x.GetEnumerator0() : $x.GetEnumerator()\">]\nlet getEnumerator0 (x: obj) : System.Collections.IEnumerator = X\n\n[<JavaScript>]\nlet Get0 (x: System.Collections.IEnumerable) : System.Collections.IEnumerator =\n    if x :? System.Array then\n        As (ArrayEnumerator (As x))\n    elif JS.TypeOf x = JS.String then\n        As (StringEnumerator (As x))\n    else\n        getEnumerator0 x\n\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n/// Provides seq/list/array proxies\n[<JavaScript>]\nmodule internal WebSharper.CollectionInternals\n\nopen WebSharper.JavaScript\n\n[<Name \"WebSharper.Arrays.splitInto\">]\nlet ArraySplitInto count (arr: 'T[]) =\n    if count <= 0 then failwith \"Count must be positive\"\n    let len = arr.Length\n    if len = 0 then\n        [| |]\n    else\n        let count = min count len\n        let res = Array.zeroCreate count : 'T[][]\n        let minChunkSize = len / count\n        let mutable startIndex = 0\n        for i = 0 to len % count - 1 do\n            res.JS.[i] <- Array.sub arr startIndex (minChunkSize + 1)\n            startIndex <- startIndex + minChunkSize + 1\n        for i = len % count to count - 1 do\n            res.JS.[i] <-  Array.sub arr startIndex minChunkSize\n            startIndex <- startIndex + minChunkSize\n        res\n\n[<Name \"WebSharper.Arrays.contains\">]\nlet ArrayContains (item: 'T) (arr: 'T[])  =\n    let mutable c = true\n    let mutable i = 0\n    let l = arr.Length\n    while c && i < l do\n        if arr.JS.[i] = item then\n            c <- false\n        else\n            i <- i + 1\n    not c\n\n[<Name \"WebSharper.Arrays.tryFindBack\">]\nlet ArrayTryFindBack f (arr: _ []) =\n    let mutable res = None\n    let mutable i = Array.length arr - 1\n    while i >= 0 && Option.isNone res do\n        let r = arr.JS.[i]\n        if f r then res <- Some r\n        i <- i - 1\n    res\n\n[<Name \"WebSharper.Arrays.tryFindIndexBack\">]\nlet ArrayTryFindIndexBack f (arr: _ []) =\n    let mutable res = None\n    let mutable i = Array.length arr - 1\n    while i >= 0 && Option.isNone res do\n        if f arr.[i] then res <- Some i\n        i <- i - 1\n    res\n\n[<Name \"WebSharper.Arrays.mapFold\">]\nlet ArrayMapFold<'T, 'S, 'R> (f: 'S -> 'T -> 'R * 'S) (zero: 'S) (arr: 'T[]) : 'R[] * 'S =\n    let r = JavaScript.Array(Array.length arr)\n    let mutable acc = zero\n    for i = 0 to Array.length arr - 1 do\n        let a, b = f acc arr.JS.[i]\n        r.[i] <- a\n        acc <- b \n    r.Self, acc\n\n[<Name \"WebSharper.Arrays.mapFoldBack\">]\nlet ArrayMapFoldBack<'T,'S,'R> (f: 'T -> 'S -> 'R * 'S) (arr: 'T[]) (zero: 'S) : 'R[] * 'S =\n    let r = JavaScript.Array<'R>(Array.length arr)\n    let mutable acc = zero\n    let len = Array.length arr\n    for j = 1 to len do\n        let i = len - j\n        let a, b = f arr.JS.[i] acc\n        r.[i] <- a\n        acc <- b \n    r.Self, acc\n\n[<Name \"WebSharper.Arrays.mapInPlace\">]\nlet mapInPlace (f: 'T1 -> 'T2) (arr: 'T1 []) =\n    for i = 0 to Array.length arr - 1 do\n        arr.JS.[i] <- As (f arr.JS.[i])\n\n[<Name \"WebSharper.Arrays.mapiInPlace\">]\nlet mapiInPlace (f: int -> 'T1 -> 'T2) (arr: 'T1 []) : 'T2[] =\n    for i = 0 to Array.length arr - 1 do\n        arr.JS.[i] <- As (f i arr.JS.[i])\n    As arr\n\n[<Name \"WebSharper.Arrays.sortInPlaceByDescending\">]\nlet ArraySortInPlaceByDescending<'T,'U when 'U: comparison> (f: 'T -> 'U) (arr: 'T []) =\n    (mapiInPlace (fun i x -> x, (f x, i)) arr).JS.Sort(fun (x, y) -> - compare (snd x) (snd y)) |> mapInPlace fst \n\n[<Name \"WebSharper.Seq.tryHead\">]\nlet SeqTryHead (s: seq<'T>) =\n    use e = Enumerator.Get s\n    if e.MoveNext() then Some e.Current else None\n\n[<Name \"WebSharper.Seq.tryItem\">]\nlet SeqTryItem i (s: seq<'T>) =\n    if i < 0 then None else\n    let mutable j = 0\n    use e = Enumerator.Get s\n    let mutable go = true\n    while go && j <= i do\n        if e.MoveNext() then\n            j <- j + 1\n        else\n            go <- false\n    if go then Some e.Current else None\n\n[<Name \"WebSharper.Seq.tryLast\">]\nlet SeqTryLast (s: seq<'T>) =\n    use e = Enumerator.Get s\n    if e.MoveNext() then \n        while e.MoveNext() do ()\n        Some e.Current \n    else None\n\n[<Name \"WebSharper.Seq.chunkBySize\">]\nlet SeqChunkBySize (size: int) (s: seq<'T>) =\n    if size <= 0 then failwith \"Chunk size must be positive\"\n    Enumerable.Of <| fun () ->\n        let o = Enumerator.Get s\n        Enumerator.NewDisposing () (fun _ -> o.Dispose()) <| fun e ->\n            if o.MoveNext() then\n                let res = [|o.Current|]\n                while res.Length < size && o.MoveNext() do \n                    res.JS.Push o.Current |> ignore\n                e.Current <- res\n                true\n            else false\n\n[<Name \"WebSharper.Arrays.countBy\">]\nlet ArrayCountBy (f: 'T -> 'K) (a: 'T[]) : ('K * int)[] =\n    let d = System.Collections.Generic.Dictionary<'K, int>()\n    let keys = JavaScript.Array()\n    for i = 0 to a.Length - 1 do\n        let c = a.JS.[i]\n        let k = f c\n        if d.ContainsKey(k) then\n            d.[k] <- d.[k] + 1 \n        else\n            keys.Push(k) |> ignore\n            d.Add(k, 1)\n    As<'K[]> keys |> mapInPlace (fun k -> (k, d.[k]))\n    As keys\n\n[<Name \"WebSharper.Seq.except\">]\nlet SeqExcept (itemsToExclude: seq<'T>) (s: seq<'T>) =\n    Enumerable.Of <| fun () ->\n        let o  = Enumerator.Get s\n        let seen = System.Collections.Generic.HashSet(itemsToExclude)\n        Enumerator.NewDisposing () (fun _ -> o.Dispose()) <| fun e ->\n            if o.MoveNext() then\n                let mutable cur = o.Current\n                let mutable has = seen.Add(cur)\n                while not has && o.MoveNext() do\n                    cur <- o.Current\n                    has <- seen.Add(cur)\n                if has then\n                    e.Current <- cur\n                    true\n                else\n                    false\n            else\n                false\n\n[<Name \"WebSharper.List.skip\">]\nlet ListSkip i (l : list<'T>) =\n    let mutable res = l\n    for j = 1 to i do\n        match res with \n        | _ :: t ->\n            res <- t\n        | [] -> failwith \"Input list too short.\"\n    res\n\n[<Name \"WebSharper.Arrays.groupBy\">]\nlet ArrayGroupBy (f: 'T -> 'K when 'K : equality) (a: 'T[]) : ('K * 'T[])[] =\n    let d = System.Collections.Generic.Dictionary<'K, 'T[]>()\n    let keys = JavaScript.Array()\n    for i = 0 to a.Length - 1 do\n        let c = a.JS.[i]\n        let k = f c\n        if d.ContainsKey(k) then\n            d.[k].JS.Push(c) |> ignore\n        else\n            keys.Push(k) |> ignore\n            d.Add(k, [| c |])\n    As<'K[]> keys |> mapInPlace (fun k -> (k, d.[k]))\n    As keys\n\n[<Name \"WebSharper.Seq.insufficient\">]\nlet InsufficientElements() =\n    failwith \"The input sequence has an insufficient number of elements.\"\n\n[<Name \"WebSharper.Seq.last\">]\nlet SeqLast (s: seq<_>) =\n    use e = Enumerator.Get s\n    if not <| e.MoveNext() then InsufficientElements()\n    else \n        while e.MoveNext() do ()\n        e.Current\n\n[<Name \"WebSharper.Seq.contains\">]\nlet SeqContains (el: 'T) (s: seq<'T>) =\n    use e = Enumerator.Get s\n    let mutable r = false\n    while not r && e.MoveNext() do\n        r <- e.Current = el\n    r\n\n[<Name \"WebSharper.List.skipWhile\">]\nlet rec ListSkipWhile<'T> (predicate : 'T -> bool) (list : list<'T>) : list<'T> =\n    let mutable rest = list\n    while not (List.isEmpty rest) && predicate (List.head rest) do\n        rest <- List.tail rest \n    rest\n\n[<Name \"WebSharper.Seq.nonNegative\">]\nlet InputMustBeNonNegative() =\n    failwith \"The input must be non-negative.\"\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\n#nowarn \"864\"\nopen WebSharper.JavaScript\n\n[<Proxy(typeof<System.Object>)>]\n[<Name \"WebSharper.Obj\">]\ntype private ObjectProxy() =\n\n    [<Inline>]\n    override this.GetHashCode() = Unchecked.hash this\n\n    [<Inline>]\n    override this.Equals(obj: obj) = Unchecked.equals (this :> obj) obj\n\n    [<Name \"GetHashCode\">]\n    member this.GetHashCodeImpl() = -1\n\n    [<Name \"Equals\">]\n    member this.EqualsImpl(obj: obj) = this ===. obj\n\n    [<Inline>]\n    static member Equals(a: obj, b: obj) = Unchecked.equals a b\n\n    [<Inline>]\n    static member ReferenceEquals(a: obj, b: obj) = a ===. b\n\n    [<Inline>]\n    static member op_Equality(a: obj, b: obj) = Unchecked.equals a b\n\n    [<Inline>]\n    static member op_Inequality(a: obj, b: obj) = not (Unchecked.equals a b)\n\n    [<Inline>]\n    override this.ToString() = string this\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Core.LanguagePrimitives+IntrinsicFunctions, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.IntrinsicFunctionProxy\n\nopen System\nopen WebSharper.JavaScript\n\n[<Inline \"$value\">]\nlet UnboxGeneric<'T> (value: obj) = X<'T>\n\n[<Inline \"$value\">]\nlet UnboxFast<'T> (value: obj) = X<'T>\n\n[<Macro(typeof<Macro.TypeTest>)>]\nlet TypeTestGeneric<'T> (value: obj) = X<bool>\n\n[<Macro(typeof<Macro.TypeTest>)>]\nlet TypeTestFast<'T> (value: obj) = X<bool>\n\n[<Inline \"$arr.length\">]\nlet GetArray2DLength1 (arr: 'T[,]) = X<int>\n\n[<Inline \"$arr.length ? $arr[0].length : 0\">]\nlet GetArray2DLength2 (arr: 'T[,]) =  X<int>\n\n[<Name \"WebSharper.Arrays.checkBounds\">]\nlet checkBounds (arr: 'T[]) (n: int) =\n    if n < 0 || n >= Array.length arr then\n        failwith \"Index was outside the bounds of the array.\"\n\n[<Name \"WebSharper.Arrays.checkBounds2D\">]\nlet checkBounds2D<'T> (arr: 'T[,]) (n1: int) (n2: int) =\n    if n1 < 0 || n2 < 0 || n1 >= GetArray2DLength1 arr\n        || n2 >= GetArray2DLength2 arr then\n        raise (new IndexOutOfRangeException())\n\n[<Name \"WebSharper.Arrays.checkRange\">]\n\nlet checkRange (arr: 'T []) (start: int) (size: int) : unit =\n    if (size < 0) || (start < 0) || (Array.length arr < start + size) then\n        failwith \"Index was outside the bounds of the array.\"\n\n[<Inline \"$arr[$n]\">]\nlet GetArrayInternal<'T> (arr: 'T[]) (n:int) = X<'T>\n\n[<Inline \"void ($arr[$n] = $x)\">]\nlet SetArrayInternal<'T> (arr: 'T[]) (n:int) (x:'T) = ()\n\n[<Name \"WebSharper.Arrays.set\">]\nlet SetArray<'T> (arr: 'T[]) (n: int) (x: 'T) =\n    checkBounds arr n\n    SetArrayInternal arr n x\n\n[<Inline \"$s[$ix]\">]\n[<Name \"WebSharper.Strings.get\">]\nlet GetString (s: string) (ix: int) = X<char>\n\n[<Name \"WebSharper.Arrays.get\">]\nlet GetArray<'T> (arr: 'T[]) (n: int) =\n    checkBounds arr n\n    GetArrayInternal arr n\n\n[<Inline \"$x.slice($start,$start+$length)\">]\nlet private subArray (x: 'T) start length = X<'T>\n\n[<Name \"WebSharper.Arrays.sub\">]\nlet GetArraySub<'T> (arr: 'T[]) start length =\n    checkRange arr start length\n    subArray arr start length\n\n[<Name \"WebSharper.Arrays.setSub\" >]\nlet SetArraySub<'T> (arr: 'T[]) start len (src: 'T[]) =\n    for i = 0 to len - 1 do\n        arr.[start+i] <- src.[i]\n\n[<Inline \"$arr[$n1][$n2]\">]\nlet GetArray2DInternal (arr: 'T[,]) (n1:int) (n2:int) = X<'T>\n\n[<Name \"WebSharper.Arrays.get2D\" >]\nlet GetArray2D (arr: 'T[,]) (n1: int) (n2: int) =\n    checkBounds2D arr n1 n2\n    GetArray2DInternal arr n1 n2\n\n[<Inline \"void ($arr[$n1][$n2] = $x)\">]\nlet SetArray2DInternal (arr: 'T[,]) (n1:int) (n2:int) (x:'T) = ()\n\n\n[<Name \"WebSharper.Arrays.set2D\" >]\nlet SetArray2D (arr: 'T[,]) (n1: int) (n2: int) (x: 'T) =\n    checkBounds2D arr n1 n2\n    SetArray2DInternal arr n1 n2 x\n\n[<Name \"WebSharper.Arrays.zeroCreate2D\" >]\nlet Array2DZeroCreate<'T> (n:int) (m:int) =\n    let arr = As<'T[,]>(Array.init n (fun _ -> Array.zeroCreate m))\n    arr?dims <- 2\n    arr\n\n[<Name \"WebSharper.Arrays.sub2D\" >]\nlet GetArray2DSub<'T> (src: 'T[,]) src1 src2 len1 len2 =\n    let len1 = (if len1 < 0 then 0 else len1)\n    let len2 = (if len2 < 0 then 0 else len2)\n    let dst = Array2DZeroCreate len1 len2\n    for i = 0 to len1 - 1 do\n        for j = 0 to len2 - 1 do\n            dst.[i,j] <- src.[src1 + i, src2 + j]\n    dst\n\n[<Name \"WebSharper.Arrays.setSub2D\" >]\nlet SetArray2DSub<'T> (dst: 'T[,]) src1 src2 len1 len2 (src: 'T[,]) =\n    for i = 0 to len1 - 1 do\n        for j = 0 to len2 - 1 do\n            dst.[src1+i, src2+j] <- src.[i, j]\n\n[<Name \"WebSharper.Arrays.length\" >]\nlet GetLength<'T> (arr: System.Array) =\n    match arr?dims with\n    | 2 -> GetArray2DLength1 (As arr) * GetArray2DLength1 (As arr)\n    | _ -> Array.length (As arr)\n\n[<Name \"WebSharper.checkThis\">]\nlet CheckThis (this: 'T) =\n    if this = null then\n        invalidOp \"The initialization of an object or value resulted in an object or value being accessed recursively before it was fully initialized.\"\n    else this", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen WebSharper.JavaScript\nmodule F = WebSharper.IntrinsicFunctionProxy\n\n[<Proxy(typeof<System.Array>)>]\ntype private ArrayProxy =\n\n    [<Inline \"$array.reverse()\">]\n    static member Reverse(array: System.Array) = X<unit>\n\n    [<Name \"WebSharper.Arrays.reverse\">]\n    static member Reverse(array: System.Array, offset: int, length: int) =\n        let a = Array.rev (Array.sub (As array) offset length)\n        Array.blit a 0 (As array) offset a.Length\n\n    member this.Length\n        with [<Inline>] get() = F.GetLength (As this)   \n\n    [<Inline>]\n    member this.GetEnumerator() = Enumerator.Get0 (As this)         \n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.Name \"Arrays\">]\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Collections.ArrayModule, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.ArrayModuleProxy\n\nopen WebSharper.JavaScript\nopen WebSharper.CollectionInternals\n\nmodule F = WebSharper.IntrinsicFunctionProxy\n\nlet checkLength (arr1: 'T1[]) (arr2: 'T2[]) =\n    if Array.length arr1 <> Array.length arr2 then\n        failwith \"The arrays have different lengths.\"\n\n[<Inline \"$x.push($y)\">]\nlet push (x: obj) (y: obj) = ()\n\n[<Inline \"$arr1.concat($arr2)\">]\nlet Append<'T> (arr1: 'T []) (arr2: 'T []) : 'T [] = arr1\n\n[<Name \"allPairs\">]\nlet AllPairs (array1: 'T1 []) (array2: 'T2 []) =\n    let len1 = Array.length array1\n    let len2 = Array.length array2\n    let res = JavaScript.Array (len1 * len2)\n    for i = 0 to len1-1 do\n        for j = 0 to len2-1 do\n            res.[i * len2 + j] <- (array1.JS.[i],array2.JS.[j])\n    res |> As<('T1 * 'T2) []>\n\n[<Name \"average\">]\nlet inline Average (arr: 'T []): 'T = As (float (Array.sum arr) / float (Array.length arr))\n\n[<Name \"averageBy\">]\nlet inline AverageBy (f: 'T -> 'U) (arr: 'T []) : 'U = As (float (Array.sumBy f arr) / float (Array.length arr))\n\n[<Name \"blit\">]\nlet CopyTo<'T> (arr1: 'T [], start1, arr2: 'T [], start2, length) =\n    F.checkRange arr1 start1 length\n    F.checkRange arr2 start2 length\n    for i = 0 to length - 1 do\n        arr2.JS.[start2 + i] <- arr1.JS.[start1 + i]\n\n[<Name \"choose\">]\nlet Choose<'T,'U> (f: 'T -> option<'U>) (arr: 'T []) : 'U [] =\n    let q : 'U [] = [||]\n    for i = 0 to Array.length arr - 1 do\n        match f arr.JS.[i] with\n        | Some x -> push q x\n        | None   -> ()\n    q\n\n[<Inline \"Array.prototype.concat.apply([], $x)\"; Pure>]\nlet concatArray (x: 'T[][]) = X<'T[]>\n\n[<Name \"collect\">]\nlet Collect<'T,'U> (f: 'T -> 'U[]) (x: 'T []) : 'U[] =\n    concatArray (Array.map f x)\n\n[<Name \"concat\">]\nlet Concat<'T> (xs: seq<'T []>) : 'T [] =\n    concatArray (Array.ofSeq xs)\n\n[<Inline>]\nlet SplitInto count (arr: 'T[]) = ArraySplitInto count arr\n\n[<Inline \"$x.slice()\">]\nlet Copy (x: 'T []) = X<'T []>\n\n[<Name \"create\">]\nlet Create (size: int) value =\n    let r = JavaScript.Array(size)\n    for i = 0 to size - 1 do\n        r.[i] <- value\n    r.Self\n\n[<Inline \"[]\">]\nlet Empty () = X<'T []>\n\n[<Name \"exists\">]\nlet Exists<'T> (f: 'T -> bool) (x: 'T []) =\n    let mutable e = false\n    let mutable i = 0\n    let l = x.Length\n    while not e && i < l do\n        if f x.JS.[i] then\n            e <- true\n        else\n            i <- i + 1\n    e\n\n[<Name \"exists2\">]\nlet Exists2 f (x1: _ []) (x2: _ []) =\n    checkLength x1 x2\n    let mutable e = false\n    let mutable i = 0\n    let l = x1.Length\n    while not e && i < l do\n        if f x1.JS.[i] x2.JS.[i] then\n            e <- true\n        else\n            i <- i + 1\n\n    e\n\n[<Name \"fill\">]\nlet Fill<'T> (arr: 'T []) (start: int) (length: int) (value: 'T) =\n    F.checkRange arr start length\n    for i = start to start + length - 1 do\n        arr.JS.[i] <- value\n\n[<Name \"filter\">]\nlet Filter<'T> f (arr: 'T []) : 'T [] =\n    let r : 'T [] = [||]\n    for i = 0 to Array.length arr - 1 do\n        if f arr.JS.[i] then\n            push r arr.JS.[i]\n    r\n\n[<Name \"find\">]\nlet Find f (arr: _ []) =\n    match Array.tryFind f arr with\n    | Some x -> x\n    | None   -> failwith \"KeyNotFoundException\"\n\n[<Name \"findIndex\">]\nlet FindIndex f (arr: _ []) =\n    match Array.tryFindIndex f arr with\n    | Some x -> x\n    | None   -> failwith \"KeyNotFoundException\"\n\n[<Name \"fold\">]\nlet Fold<'T,'S> (f: 'S -> 'T -> 'S) (zero: 'S) (arr: 'T []) : 'S =\n    let mutable acc = zero\n    for i = 0 to Array.length arr - 1 do\n        acc <- f acc arr.JS.[i]\n    acc\n\n[<Name \"fold2\">]\nlet Fold2<'T1,'T2,'S> f (zero: 'S) (arr1: 'T1 []) (arr2: 'T2 []) : 'S =\n    checkLength arr1 arr2\n    let mutable accum = zero\n    for i in 0 .. Array.length arr1 - 1 do\n        accum <- f accum arr1.JS.[i] arr2.JS.[i]\n    accum\n\n[<Name \"foldBack\">]\nlet FoldBack f (arr: _ []) zero =\n    let mutable acc = zero\n    let len = Array.length arr\n    for i = 1 to len do\n        acc <- f arr.JS.[len - i] acc\n    acc\n\n[<Name \"foldBack2\">]\nlet FoldBack2 f (arr1: _ []) (arr2: _ []) zero =\n    checkLength arr1 arr2\n    let len = Array.length arr1\n    let mutable accum = zero\n    for i in 1 .. len do\n        accum <- f arr1.JS.[len - i] arr2.JS.[len - i] accum\n    accum\n\n[<Name \"forall\">]\nlet ForAll f (x: _ []) =\n    let mutable a = true\n    let mutable i = 0\n    let l = x.Length\n    while a && i < l do\n        if f x.JS.[i] then\n            i <- i + 1\n        else\n            a <- false\n    a\n\n[<Name \"forall2\">]\nlet ForAll2 f (x1: _ []) (x2: _ []) =\n    checkLength x1 x2\n    let mutable a = true\n    let mutable i = 0\n    let l = x1.Length\n    while a && i < l do\n        if f x1.JS.[i] x2.JS.[i] then\n            i <- i + 1\n        else\n            a <- false\n    a\n\n[<Inline>]\nlet Get (arr: _ []) index =\n    F.GetArray arr index\n\n[<Inline>]\nlet Item index (arr: _ []) =\n    F.GetArray arr index\n\n[<Name \"init\">]\nlet Initialize (size: int) f =\n    if size < 0 then\n        failwith \"Negative size given.\"\n    let r = JavaScript.Array(size)\n    for i = 0 to size - 1 do\n        r.[i] <- f i\n    r.Self\n\n[<Inline \"$arr.length == 0\">]\nlet IsEmpty (arr: _ []) = X<bool>\n\n[<Name \"iter\">]\nlet Iterate f (arr: 'T []) =\n    for i = 0 to Array.length arr - 1 do\n        f arr.JS.[i]\n\n[<Name \"iter2\">]\nlet Iterate2 f (arr1: _ []) (arr2: _ []) =\n    checkLength arr1 arr2\n    for i = 0 to Array.length arr1 - 1 do\n        f arr1.JS.[i] arr2.JS.[i]\n\n[<Name \"iteri\">]\nlet IterateIndexed f (arr: 'T []) =\n    for i = 0 to Array.length arr - 1 do\n        f i arr.JS.[i]\n\n[<Name \"iteri2\">]\nlet IterateIndexed2 f (arr1: _ []) (arr2: _ []) =\n    checkLength arr1 arr2\n    for i = 0 to Array.length arr1 - 1 do\n        f i arr1.JS.[i] arr2.JS.[i]\n\n[<Inline \"$arr.length\">]\nlet Length<'T> (arr: 'T []) = X<int>\n\n[<Name \"map\">]\nlet Map<'T1,'T2> (f: 'T1 -> 'T2) (arr: 'T1 []) : 'T2 [] =\n    let r = JavaScript.Array<'T2>(Array.length arr)\n    for i = 0 to Array.length arr - 1 do\n        r.[i] <- f arr.JS.[i]\n    r.Self\n\n[<Name \"map2\">]\nlet Map2 (f: 'T1 -> 'T2 -> 'T3) (arr1: 'T1 []) (arr2: 'T2 []) : 'T3 [] =\n    checkLength arr1 arr2\n    let r = JavaScript.Array<'T3>(Array.length arr2)\n    for i = 0 to Array.length arr2 - 1 do\n        r.[i] <- f arr1.JS.[i] arr2.JS.[i]\n    r.Self\n\n[<Name \"mapi\">]\nlet MapIndexed f (arr: _ []) =\n    let y = JavaScript.Array(Array.length arr)\n    for i = 0 to Array.length arr - 1 do\n        y.[i] <- f i arr.JS.[i]\n    y.Self\n\n[<Name \"mapi2\">]\nlet MapIndexed2 f (arr1: 'T1 []) (arr2: 'T2 []): 'U[] =\n    checkLength arr1 arr2\n    let res = JavaScript.Array(Array.length arr1)\n    for i = 0 to Array.length arr1 - 1 do\n        res.[i] <- f i arr1.JS.[i] arr2.JS.[i]\n    res.Self\n\n[<Inline>]\nlet MapFold<'T,'S,'R> f zero arr = ArrayMapFold<'T, 'S, 'R> f zero arr\n\n[<Inline>]\nlet MapFoldBack f arr zero = ArrayMapFoldBack f arr zero\n\n[<Name \"max\">]\nlet Max x = Array.reduce max x\n\n[<Name \"maxBy\">]\nlet MaxBy f arr =\n    Array.reduce (fun x y -> if f x > f y then x else y) arr\n\n[<Name \"min\">]\nlet Min x = Array.reduce min x\n\n[<Name \"minBy\">]\nlet MinBy f arr =\n    Array.reduce (fun x y -> if f x < f y then x else y) arr\n\n[<Name \"ofList\">]\nlet OfList<'T> (xs: list<'T>) =\n    let q : 'T [] = [||]\n    let mutable l = xs\n    while not (List.isEmpty l) do\n        push q l.Head\n        l <- l.Tail\n    q\n\n[<Name \"ofSeq\">]\nlet OfSeq<'T> (xs: seq<'T>) : 'T [] =\n    if xs :? System.Array then\n        Array.copy (As<'T[]> xs)\n    elif xs :? _ list then\n        Array.ofList (As<'T list> xs)\n    else\n        let q : 'T [] = [||]\n        use o = Enumerator.Get xs\n        while o.MoveNext() do\n            push q o.Current\n        q\n\n[<Name \"partition\">]\nlet Partition f (arr: 'T []) : 'T [] * 'T [] =\n    let ret1 : 'T [] = [||]\n    let ret2 : 'T [] = [||]\n    for i = 0 to Array.length arr - 1 do\n        if f arr.JS.[i] then\n            push ret1 arr.JS.[i]\n        else\n            push ret2 arr.JS.[i]\n    (ret1, ret2)\n\n[<Name \"permute\">]\nlet Permute f (arr: 'T []) =\n    let ret = JavaScript.Array(Array.length arr)\n    for i = 0 to Array.length arr - 1 do\n        ret.[f i] <- arr.JS.[i]\n    ret.Self\n\n[<Name \"pick\">]\nlet Pick f (arr: _ []) =\n    match Array.tryPick f arr with\n    | Some x -> x\n    | None   -> failwith \"KeyNotFoundException\"\n\nlet private nonEmpty (arr: _ []) =\n    if Array.length arr = 0 then\n        failwith \"The input array was empty.\"\n\n[<Name \"reduce\">]\nlet Reduce f (arr: _ []) =\n    nonEmpty arr\n    let mutable acc = arr.JS.[0]\n    for i = 1 to Array.length arr - 1 do\n        acc <- f acc arr.JS.[i]\n    acc\n\n[<Name \"reduceBack\">]\nlet ReduceBack f (arr: _ []) =\n    nonEmpty arr\n    let len = Array.length arr\n    let mutable acc = arr.JS.[len - 1]\n    for i = 2 to len do\n        acc <- f arr.JS.[len - i] acc\n    acc\n\n[<Inline \"$x.slice().reverse()\">]\nlet Reverse (x: 'T []) = X<'T []>\n\n[<Name \"scan\">]\nlet Scan<'T,'S> (f: 'S -> 'T -> 'S) (zero: 'S) (arr: 'T []) : 'S [] =\n    let ret = JavaScript.Array(1 + Array.length arr)\n    ret.[0] <- zero\n    for i = 0 to Array.length arr - 1 do\n        ret.[i + 1] <- f ret.[i] arr.JS.[i]\n    ret.Self\n\n[<Name \"scanBack\">]\nlet ScanBack (f: 'T -> 'S -> 'S) (arr: 'T []) (zero: 'S) : 'S [] =\n    let len = Array.length arr\n    let ret = JavaScript.Array(1 + len)\n    ret.[len] <- zero\n    for i = 0 to len - 1 do\n        ret.[len - i - 1] <- f arr.JS.[len - i - 1] ret.[len - i]\n    ret.Self\n\n[<Inline>]\nlet Set (arr: _ []) i v =\n    F.SetArray arr i v\n\n[<Name \"sort\">]\nlet Sort<'T when 'T: comparison> (arr: 'T []) : 'T [] =\n    (Array.mapi (fun i x -> x, i) arr).JS.Sort(fun (x, y) -> compare x y) |> Array.map fst\n\n[<Name \"sortBy\">]\nlet SortBy<'T,'U when 'U: comparison> (f: 'T -> 'U) (arr: 'T []) : 'T [] =\n    (Array.mapi (fun i x -> x, (f x, i)) arr).JS.Sort(fun (x, y) -> compare (snd x) (snd y)) |> Array.map fst\n\n[<Name \"sortInPlace\">]\nlet SortInPlace<'T when 'T: comparison> (arr: 'T []) =\n    (mapiInPlace (fun i x -> x, i) arr).JS.Sort(fun (x, y) -> compare x y) |> mapInPlace fst\n\n[<Name \"sortInPlaceBy\">]\nlet SortInPlaceBy<'T,'U when 'U: comparison> (f: 'T -> 'U) (arr: 'T []) =\n    (mapiInPlace (fun i x -> x, (f x, i)) arr).JS.Sort(fun (x, y) -> compare (snd x) (snd y)) |> mapInPlace fst \n\n[<Name \"sortInPlaceWith\">]\nlet SortInPlaceWith<'T> (comparer: 'T -> 'T -> int) (arr: 'T []) =\n    arr.JS.Sort(fun (x, y) -> comparer x y) |> ignore\n\n[<Name \"sortWith\">]\nlet SortWith<'T> (comparer: 'T -> 'T -> int) (arr: 'T []) : 'T [] =\n    (Array.copy arr).JS.Sort(fun (x, y) -> comparer x y)\n\n[<Name \"sortByDescending\">]\nlet SortByDescending<'T,'U when 'U: comparison> (f: 'T -> 'U) (arr: 'T []) : 'T [] =\n    (Array.mapi (fun i x -> x, (f x, i)) arr).JS.Sort(fun (x, y) -> - compare (snd x) (snd y)) |> Array.map fst\n\n[<Name \"sortDescending\">]\nlet SortDescending<'T when 'T: comparison> (arr: 'T []) : 'T [] =\n    (Array.mapi (fun i x -> x, i) arr).JS.Sort(fun (x, y) -> - compare x y) |> Array.map fst\n\n[<Inline \"$x.slice($start,$start+$length)\">]\nlet private subArray (x: 'T) start length = X<'T>\n\n[<Inline>]\nlet GetSubArray (arr: 'T []) (start: int) (length: int) : 'T []=\n    F.GetArraySub arr start length\n\n[<Direct \"var sum = 0; for (var i = 0; i < $arr.length; i++) sum += $arr[i]; return sum\">]\n[<Name \"sum\">]\nlet Sum (arr: 'T []) : 'T = X<'T>\n\n[<Direct \"var sum = 0; for (var i = 0; i < $arr.length; i++) sum += $f($arr[i]); return sum\">]\n[<Name \"sumBy\">]\nlet SumBy (f: 'T -> 'U) (arr: 'T []) : 'U =  X<'U>\n\n[<Inline>]\nlet ToList arr = List.ofArray arr\n\n[<Inline \"$arr\">]\nlet ToSeq (arr: _ []) = arr :> seq<_>\n\n[<Name \"tryFind\">]\nlet TryFind f (arr: _ []) =\n    let mutable res = None\n    let mutable i = 0\n    while i < Array.length arr && Option.isNone res do\n        if f arr.JS.[i] then res <- Some arr.JS.[i]\n        i <- i + 1\n    res\n\n[<Inline>]\nlet TryFindBack f (arr: _ []) = ArrayTryFindBack f arr\n\n[<Name \"tryFindIndex\">]\nlet TryFindIndex f (arr: _ []) =\n    let mutable res = None\n    let mutable i = 0\n    while i < Array.length arr && Option.isNone res do\n        if f arr.JS.[i] then res <- Some i\n        i <- i + 1\n    res\n\n[<Inline>]\nlet TryFindIndexBack f (arr: _ []) = ArrayTryFindIndexBack f arr\n\n[<Name \"tryHead\">]\nlet TryHead (arr: 'T[]) =\n    if Array.length arr = 0 then None else Some arr.JS.[0]\n\n[<Name \"tryItem\">]\nlet TryItem i (arr: 'T[]) =\n    if Array.length arr <= i || i < 0 then None else Some arr.JS.[i]\n\n[<Name \"tryLast\">]\nlet TryLast (arr: 'T[]) =\n    let len = Array.length arr\n    if len = 0 then None else Some arr.JS.[len - 1]\n\n[<Name \"tryPick\">]\nlet TryPick f (arr: _ []) =\n    let mutable res = None\n    let mutable i = 0\n    while i < Array.length arr && Option.isNone res do\n        match f arr.JS.[i] with\n        | Some _ as r -> res <- r\n        | _ -> ()\n        i <- i + 1\n    res\n\n[<Name \"unzip\">]\nlet Unzip<'T1,'T2> (arr: ('T1 * 'T2) []) : 'T1 [] * 'T2 [] =\n    let x : 'T1 [] = [||]\n    let y : 'T2 [] = [||]\n    for i = 0 to Array.length arr - 1 do\n        let (a, b) = arr.JS.[i]\n        push x a\n        push y b\n    (x, y)\n\n[<Name \"unzip3\">]\nlet Unzip3<'T1,'T2,'T3> (arr: ('T1 * 'T2 * 'T3) []) =\n    let x : 'T1 [] = [||]\n    let y : 'T2 [] = [||]\n    let z : 'T3 [] = [||]\n    for i = 0 to Array.length arr - 1 do\n        match arr.JS.[i] with\n        | (a, b, c) ->\n            push x a\n            push y b\n            push z c\n    (x, y, z)\n\n[<Inline>]\n[<Name \"zeroCreate\">]\nlet ZeroCreate<'T> (size: int) =\n    Create size Unchecked.defaultof<'T>\n\n[<Name \"zip\">]\nlet Zip (arr1: 'T1 []) (arr2: 'T2 []) =\n    checkLength arr1 arr2\n    let res = Array.zeroCreate (Array.length arr1)\n    for i = 0 to Array.length arr1 - 1 do\n        res.JS.[i] <- (arr1.JS.[i], arr2.JS.[i])\n    res\n\n[<Name \"zip3\">]\nlet Zip3 (arr1: _ [], arr2: _ [], arr3: _ []) =\n    checkLength arr1 arr2\n    checkLength arr2 arr3\n    let res = Array.zeroCreate (Array.length arr1)\n    for i = 0 to Array.length arr1 - 1 do\n        res.JS.[i] <- (arr1.JS.[i], arr2.JS.[i], arr3.JS.[i])\n    res\n\n[<Name \"chunkBySize\">]\nlet ChunkBySize size array =\n    SeqChunkBySize size (Array.toSeq array)\n    |> Seq.toArray\n\n[<Name \"compareWith\">]\nlet CompareWith  (f: 'T -> 'T -> int) (a1: 'T []) (a2: 'T []) : int =\n    Seq.compareWith f (Array.toSeq a1) (Array.toSeq a2)\n\n[<Inline>]\nlet CountBy (f: 'T -> 'K) (a: 'T []) : ('K * int) [] =\n    ArrayCountBy f a\n\n[<Name \"distinct\">]\nlet Distinct<'T when 'T : equality> (l: 'T []) : 'T [] =\n    Seq.distinct (Array.toSeq l)\n    |> Seq.toArray\n\n[<Name \"distinctBy\">]\nlet DistinctBy<'T,'K when 'K : equality>\n        (f: 'T -> 'K) (a: 'T []) : 'T [] =\n    Seq.distinctBy f (Array.toSeq a)\n    |> Seq.toArray\n\n[<Name \"except\">]\nlet Except (itemsToExclude: seq<'T>) (a: 'T []) =\n    SeqExcept itemsToExclude (Array.toSeq a)\n    |> Seq.toArray\n\n[<Name \"findBack\">]\nlet FindBack p (s: _ []) =\n    match TryFindBack p s with\n    | Some x -> x\n    | None   -> failwith \"KeyNotFoundException\"\n\n[<Name \"findIndexBack\">]\nlet FindIndexBack p (s: _ []) =\n    match TryFindIndexBack p s with\n    | Some x -> x\n    | None   -> failwith \"KeyNotFoundException\"\n\n[<Inline>]\nlet GroupBy (f: 'T -> 'K when 'K : equality)\n            (a: 'T []) : ('K * 'T []) [] =\n    ArrayGroupBy f a\n\n[<Name \"head\">]\nlet Head (arr : 'T []) : 'T =\n    nonEmpty arr\n    arr.JS.[0]\n\n[<Name \"last\">]\nlet Last (arr : 'T []) : 'T =\n    nonEmpty arr\n    arr.JS.[Array.length arr - 1]\n\n[<Name \"map3\">]\nlet Map3 (f: 'T1 -> 'T2 -> 'T3 -> 'T4) (arr1: 'T1 []) (arr2: 'T2 []) (arr3: 'T3 []) : 'T4 [] =\n    checkLength arr1 arr2\n    checkLength arr1 arr3\n    let r = JavaScript.Array<'T4>(Array.length arr3)\n    for i = 0 to Array.length arr3 - 1 do\n        r.[i] <- f arr1.JS.[i] arr2.JS.[i] arr3.JS.[i]\n    r.Self\n\n[<Inline>]\nlet Contains (el: 'T) (a: 'T []) =\n    ArrayContains el a\n\n[<Name \"pairwise\">]\nlet Pairwise (a: 'T []) : ('T * 'T) [] =\n    Seq.pairwise (Array.toSeq a)\n    |> Seq.toArray\n\n[<Name \"replicate\">]\nlet Replicate size value =\n    Array.create size value\n\n[<Name \"indexed\">]\nlet Indexed (ar : 'T []) : (int * 'T) [] =\n    Array.mapi (fun a b -> (a, b)) ar\n\n[<Inline>]\nlet Singleton<'T> (x: 'T) =\n    [| x |]\n\n[<Name \"skip\">]\nlet Skip<'T> i (ar : 'T []) =\n    if i < 0 then InputMustBeNonNegative() else\n    if i > Array.length ar then InsufficientElements() else\n    ar.JS.Slice(i)\n\n[<Name \"skipWhile\">]\nlet SkipWhile<'T> (predicate : 'T -> bool) (ar : 'T []) : 'T [] =\n    let len = Array.length ar\n    let mutable i = 0\n    while i < len && predicate ar.JS.[i] do\n        i <- i + 1\n    ar.JS.Slice(i)\n\n[<Name \"tail\">]\nlet Tail<'T> (ar : 'T []) : 'T [] =\n    Skip 1 ar\n\n[<Name \"take\">]\nlet Take<'T> n (ar: 'T []) =\n    if n < 0 then InputMustBeNonNegative() else\n    if n > Array.length ar then InsufficientElements() else\n    ar.JS.Slice(0, n)\n\n[<Name \"takeWhile\">]\nlet TakeWhile<'T> (predicate : 'T -> bool) (ar: 'T []) =\n    let len = Array.length ar\n    let mutable i = 0\n    while i < len && predicate ar.JS.[i] do\n        i <- i + 1\n    ar.JS.Slice(0, i)\n\n[<Inline>]\nlet Truncate<'T> n (ar: 'T []) =\n    ar.JS.Slice(0, n)\n\n[<Name \"exactlyOne\">]\nlet ExactlyOne (ar : 'T []) =\n    if Array.length ar = 1 then\n        ar.JS.[0]\n    else\n        failwith \"The input does not have precisely one element.\"\n\n[<Name \"unfold\">]\nlet Unfold<'T, 'S> (f: 'S -> option<'T * 'S>) (s: 'S) : 'T [] =\n    Seq.unfold f s\n    |> Seq.toArray\n\n[<Inline>]\nlet Where (predicate : 'T -> bool) (s : 'T []) : 'T [] =\n    Filter predicate s\n\n[<Name \"windowed\">]\nlet Windowed (windowSize: int) (s: 'T []) : array<'T []> =\n    Seq.windowed windowSize (Array.toSeq s)\n    |> Seq.toArray\n\n[<Name \"splitAt\">]\nlet SplitAt (n: int) (ar: 'T []) =\n    Take n ar, Skip n ar\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.Name \"Arrays2D\">]\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Collections.Array2DModule, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.Array2DModuleProxy\n\nopen WebSharper.JavaScript\nmodule F = WebSharper.IntrinsicFunctionProxy\n\n[<Inline>]\nlet Length1 (arr: 'T[,]) = F.GetArray2DLength1 arr\n\n[<Inline>]\nlet Length2 (arr: 'T[,]) = F.GetArray2DLength2 arr\n\n[<Inline>]\nlet Get (array: 'T[,]) (n:int) (m:int) = F.GetArray2D array n m\n\n[<Inline>]\nlet Set (array: 'T[,]) (n:int) (m:int) (x:'T) = F.SetArray2D array n m x\n\n[<Inline>]\nlet ZeroCreate (n:int) (m:int) = F.Array2DZeroCreate n m\n    \n[<Inline>]\nlet Create n m (x:'T) =\n    let arr = As<'T[,]>(Array.init n (fun _ -> Array.create m x))\n    arr?dims <- 2\n    arr\n     \n[<Name \"init\">]\nlet Initialize n m f = \n    let array = ZeroCreate n m : 'T[,]  \n    for i = 0 to n - 1 do \n        for j = 0 to m - 1 do \n            array.[i, j] <- f i j\n    array\n\n[<Name \"iter\">]\nlet Iterate f array = \n    let count1 = F.GetArray2DLength1 array \n    let count2 = F.GetArray2DLength2 array \n    for i = 0 to count1 - 1 do \n      for j = 0 to count2 - 1 do \n        f array.[i,j]\n\n[<Name \"iteri\">]\nlet IterateIndexed (f : int -> int -> 'T -> unit) (array:'T[,]) =\n    let count1 = F.GetArray2DLength1 array \n    let count2 = F.GetArray2DLength2 array \n    for i = 0 to count1 - 1 do \n      for j = 0 to count2 - 1 do \n        f i j array.[i,j]\n\n[<Name \"map\">]\nlet Map f array = \n    Initialize (F.GetArray2DLength1 array) (F.GetArray2DLength2 array) (fun i j -> f array.[i,j])\n\n[<Name \"mapi\">]\nlet MapIndexed f array = \n    Initialize (F.GetArray2DLength1 array) (F.GetArray2DLength2 array) (fun i j -> f i j array.[i,j])\n\n[<Name \"copy\">]\nlet Copy array = \n    Initialize (F.GetArray2DLength1 array) (F.GetArray2DLength2 array) (fun i j -> array.[i,j])\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen WebSharper.JavaScript\n\ntype private CT  = System.Threading.CancellationToken\ntype private CTS  = System.Threading.CancellationTokenSource\ntype private CTR  = System.Threading.CancellationTokenRegistration\ntype private OCE = System.OperationCanceledException\nmodule C = WebSharper.Concurrency\n\n[<Proxy(typeof<Async>)>]\ntype private AsyncProxy =\n\n    [<Inline>]\n    static member Catch(a: Async<'T>) : Async<Choice<'T,exn>>  =\n        As (C.Catch (As a))\n\n    [<Inline>]\n    static member Start(computation: Async<unit>, ?t: CT) : unit =\n        C.Start (As computation, As t)\n\n    [<Inline>]\n    static member Ignore (computation: Async<'T>) : Async<unit> =\n        As (C.Ignore (As computation))\n\n    [<Inline>]\n    static member Sleep milliseconds : Async<unit> =\n        As (C.Sleep milliseconds)\n\n    [<Inline>]\n    static member StartWithContinuations(op: Async<'T>,\n                                         c1: 'T -> unit,\n                                         c2: exn -> unit,\n                                         c3: OCE -> unit,\n                                         ?t: CT) : unit =\n        C.StartWithContinuations (As op, c1, c2, c3, As t)\n\n    [<Inline>]\n    static member FromContinuations(callback: (('T -> unit) *\n                                               (exn -> unit) *\n                                               (OCE -> unit)) -> unit)\n                                    : Async<'T> =\n        As (C.FromContinuations callback)\n\n    [<Inline>]\n    static member AwaitEvent(ev: IEvent<'D,'T>, ?t: unit -> unit) : Async<'T> =\n        As (C.AwaitEvent (As ev, t))\n\n    [<Inline>]\n    static member AwaitTask(t : System.Threading.Tasks.Task) : Async<unit> =\n        As (C.AwaitTask t)\n\n    [<Inline>]\n    static member AwaitTask(t : System.Threading.Tasks.Task<'T>) : Async<'T> =\n        As (C.AwaitTask1 t)\n\n    [<Inline>]\n    static member StartChild(a: Async<'T>, ?timeOut: int) : Async<Async<'T>> =\n        As (C.StartChild (As a, timeOut))\n\n    [<Inline>]\n    static member Parallel(cs: seq<Async<'T>>) : Async<'T []> =\n        As (C.Parallel (As cs))\n\n    [<Inline>]\n    static member StartImmediate(c: Async<unit>, ?t: CT) : unit =\n        C.StartImmediate (As c, As t)\n\n    [<Inline>]\n    static member StartAsTask (a: Async<'T>, ?opt :System.Threading.Tasks.TaskCreationOptions, ?t: CT) \n        : System.Threading.Tasks.Task<'T> =\n        C.StartAsTask(As a, As t)        \n\n    [<Inline>]\n    static member DefaultCancellationToken : CT =\n        As !C.defCTS\n\n    [<Inline>]\n    static member CancelDefaultToken() : unit =\n        let cts = !C.defCTS\n        C.defCTS := new CTS()\n        cts.Cancel()    \n\n    [<Inline>]\n    static member CancellationToken : Async<CT> =\n        As C.GetCT\n\n    [<Inline>]\n    static member OnCancel(action: unit -> unit) : Async<System.IDisposable> =\n        As (C.OnCancel action)\n    \n    [<Inline>]\n    static member TryCancelled(p: Async<'T>, f: OCE -> unit) : Async<'T> =\n        As (C.TryCancelled(As p, f))\n\n[<Proxy(typeof<CT>)>]\ntype private CancellationTokenProxy =\n    [<Inline \"$this.c\">]\n    member this.IsCancellationRequested = X<bool>\n\n    [<Inline>]\n    member this.Register(callback: System.Action) =\n        As<CTR> (C.Register (As this) callback.Invoke)\n\n    [<Inline>]\n    member this.ThrowIfCancellationRequested() =\n        if this.IsCancellationRequested then raise (OCE(As<CT> this)) \n\n    [<Inline>]\n    static member None = As<CT> C.noneCT\n        \n[<Proxy(typeof<CTS>)>]\n[<Name \"CancellationTokenSource\">]\ntype private CancellationTokenSourceProxy () =\n    let mutable c = false\n\n    let mutable pending = None\n\n    let r = [||] : (unit -> unit)[]\n\n    [<Inline>]\n    new (delay: int) as this = \n        CancellationTokenSourceProxy() then this.CancelAfter(delay)\n\n    [<Inline>]\n    new (delay: System.TimeSpan) as this = \n        CancellationTokenSourceProxy() then this.CancelAfter(delay)\n\n    [<Inline>]\n    member this.IsCancellationRequested = c\n\n    member this.Token \n        with [<Inline \"$this\">] get() = X<CT>\n\n    member this.Cancel() =\n        if not c then\n            c <- true\n            let errors = \n                r |> Array.choose (fun a -> \n                    try a()\n                        None\n                    with e -> Some e\n                )\n            if errors.Length > 0 then\n                raise (System.AggregateException(errors))    \n            \n    member this.Cancel(throwOnFirstException) =\n        if not throwOnFirstException then\n            this.Cancel()\n        else\n            if not c then\n                c <- true\n                r |> Array.iter (fun a -> a())   \n \n    member this.CancelAfter(delay: int) =\n        if not c then\n            pending |> Option.iter JS.ClearTimeout\n            pending <- Some <| JS.SetTimeout this.Cancel delay\n\n    [<Inline>]\n    member this.CancelAfter(delay: System.TimeSpan) = this.CancelAfter(As<int> delay)\n\n    static member CreateLinkedTokenSource(tokens: CT[]) =\n        let cts = new CTS()\n        tokens |> Array.iter (fun t -> t.Register(fun () -> cts.Cancel()) |> ignore)\n        cts\n\n    static member CreateLinkedTokenSource(t1: CT, t2: CT) =\n        CancellationTokenSourceProxy.CreateLinkedTokenSource [| t1; t2 |]\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen WebSharper.JavaScript\n\n[<Name \"Char\">]\n[<Proxy(typeof<System.Char>)>]\ntype private CharProxy =\n\n    [<Inline \"'\\u0000'\">]\n    new () = {}\n\n    static member GetNumericValue(c: char) : float =\n        if c >= '0' && c <= '9' then float c - float '0' else -1.\n\n    static member IsControl(c: char) : bool =\n        c >= '\\u0000' && c <= '\\u001f'\n        || c >= '\\u0080' && c <= '\\u009f'\n\n    static member IsDigit(c: char) : bool =\n        c >= '0' && c <= '9'\n\n    static member IsLetter(c: char) : bool =\n        c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z'\n\n    static member IsLetterOrDigit(c: char) : bool =\n        System.Char.IsLetter c || System.Char.IsDigit c\n\n    static member IsLower(c: char) : bool =\n        c >= 'a' && c <= 'z'\n\n    static member IsUpper(c: char) : bool =\n        c >= 'A' && c <= 'Z'\n\n    [<Direct @\"$c.match(/\\s/) !== null\">]\n    static member IsWhiteSpace(c: char) = X<bool>\n\n    static member Parse(s: string) =\n        if s.Length = 1 then As<char> s else\n            failwith \"String must be exactly one character long.\"\n\n    [<Inline \"String.fromCharCode($x.charCodeAt() + $y.charCodeAt())\">]\n    static member (+) (x: char, y: char) : char = x + y\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.Name \"Util\">]\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Control.CommonExtensions, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.CommonExtensionsProxy\n\nopen WebSharper.JavaScript\n\nlet observer (h: 'T -> unit) : System.IObserver<'T> =\n    { new System.IObserver<'T> with \n        member this.OnCompleted() = ()\n        member this.OnError _ = ()\n        member this.OnNext args = h args\n    }\n\n[<Inline>]\nlet AddToObservable<'T> (event: System.IObservable<'T>) (h: 'T -> unit) =\n    event.Subscribe(observer h) |> ignore\n\n[<Inline>]\nlet SubscribeToObservable<'T> (event: System.IObservable<'T>) (h: 'T -> unit) =\n    event.Subscribe(observer h)\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen WebSharper.JavaScript\nopen System.Runtime.InteropServices\n\ntype private D = System.DateTime\ntype private K = System.DateTimeKind\ntype private TS = System.TimeSpan\ntype private DO = System.DateTimeOffset\n\n[<JavaScript>]\n[<Name \"DateUtil\">]\nmodule private DateTimeHelpers =\n    let DatePortion (d: int) =\n        let e = Date(d)\n        Date(       \n            e.GetFullYear(),\n            e.GetMonth(),\n            e.GetDate()\n        ).GetTime()\n        |> As<D>        \n\n    let TimePortion (d: int) =\n        let e = Date(d)\n        TS(\n            0,\n            e.GetHours(), \n            e.GetMinutes(), \n            e.GetSeconds(), \n            e.GetMilliseconds()\n        )        \n        |> As<TS>        \n\n    let AddYears(d: int, years) =\n        let e = Date(d)\n        Date(   \n            e.GetFullYear() + years,\n            e.GetMonth(),\n            e.GetDate(),\n            e.GetHours(),\n            e.GetMinutes(),\n            e.GetSeconds(),\n            e.GetMilliseconds()\n        ).GetTime()\n        |> As<D>        \n\n    let AddMonths(d: int, months: int) =\n        let e = Date(d)\n        Date(   \n            e.GetFullYear(),\n            e.GetMonth() + months,\n            e.GetDate(),\n            e.GetHours(),\n            e.GetMinutes(),\n            e.GetSeconds(),\n            e.GetMilliseconds()\n        ).GetTime()    \n        |> As<D>        \n\n    let TryParse (s: string) =\n        let d = Date.Parse(s)   \n        if JS.IsNaN(d) then\n            None\n        else Some d\n\n    let Parse (s: string) =\n        match TryParse s with\n        | Some d -> d\n        | _ ->\n            failwith \"Failed to parse date string.\"\n\n    [<Direct \"(new Date($d)).toLocaleDateString({}, {year: 'numeric', month: 'long', day: 'numeric', weekday: 'long'})\">]\n    let LongDate (d: obj) = X<string>\n     \n    [<Direct \"(new Date($d)).toLocaleTimeString({}, {hour: '2-digit', minute: '2-digit', hour12: false})\">]\n    let ShortTime (d: obj) = X<string>\n\n    [<Direct \"(new Date($d)).toLocaleTimeString({}, {hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false})\">]\n    let LongTime (d: obj) = X<string>\n                \n[<Proxy(typeof<System.DateTime>)>]\ntype private DateTimeProxy =\n    [<Inline \"0\">]\n    new () = {}\n\n    [<Inline \"new Date($y,$mo-1,$d).getTime()\">]\n    new (y: int, mo: int, d: int) = {}\n\n    [<Inline \"new Date($y,$mo-1,$d,$h,$m,$s).getTime()\">]\n    new (y: int, mo: int, d: int, h: int, m: int, s: int) = {}\n\n    [<Inline \"new Date($y,$mo-1,$d,$h,$m,$s,$ms).getTime()\">]\n    new (y: int, mo: int, d: int, h: int, m: int, s: int, ms: int) = {}\n    \n    static member Now\n        with [<Inline \"Date.now()\">] get() = X<D>\n\n    static member UtcNow\n        with [<Inline \"Date.now()\">] get() = X<D>\n    \n    [<Inline \"1\">]\n    member this.Kind = X<System.DateTimeKind>\n\n    member this.Date \n        with [<Inline; JavaScript>] get() : D = DateTimeHelpers.DatePortion(As this)\n\n    static member Today\n        with [<Inline; JavaScript>] get() = DateTimeProxy.Now.Date  \n\n    member this.TimeOfDay \n        with [<Inline; JavaScript>] get() = DateTimeHelpers.TimePortion(As this)\n\n    member this.Year\n        with [<Inline; JavaScript>] get() = Date(As<int> this).GetFullYear()\n\n    member this.Month \n        with [<Inline; JavaScript>] get() = Date(As<int> this).GetMonth() + 1\n\n    member this.Day \n        with [<Inline; JavaScript>] get() = Date(As<int> this).GetDate()\n\n    member this.Hour \n        with [<Inline; JavaScript>] get() = Date(As<int> this).GetHours()\n                                                  \n    member this.Minute \n        with [<Inline; JavaScript>] get() = Date(As<int> this).GetMinutes()\n    \n    member this.Second \n        with [<Inline; JavaScript>] get() = Date(As<int> this).GetSeconds()\n\n    member this.Millisecond \n        with [<Inline; JavaScript>] get() = Date(As<int> this).GetMilliseconds()\n    \n    member this.DayOfWeek \n        with [<Inline; JavaScript>] get() = As<System.DayOfWeek>(Date(As<int> this).GetDay())\n\n    member this.Ticks\n        with [<Inline \"$this * 1E4\">] get() = X<int64>\n\n    [<Inline \"$this + $t\">]\n    member this.Add(t: TS) = X<D>\n                            \n    [<Inline \"$this - $t\">]\n    member this.Subtract(t: TS) = X<D>\n\n    [<Inline \"$this - $d\">]\n    member this.Subtract(d: D) = X<TS>\n\n    [<Inline; JavaScript>]\n    member this.AddYears(years: int) : D = DateTimeHelpers.AddYears(As this, years)\n\n    [<Inline; JavaScript>]\n    member this.AddMonths(months: int) : D = DateTimeHelpers.AddMonths(As this, months)\n\n    [<Inline; JavaScript>]\n    member this.AddDays(days: float) : D =\n        this.Add(TS.FromDays days)\n\n    [<Inline; JavaScript>]\n    member this.AddHours(hours: float) : D =\n        this.Add(TS.FromHours hours)\n\n    [<Inline; JavaScript>]\n    member this.AddMinutes(minutes: float) : D =\n        this.Add (TS.FromMinutes minutes)\n\n    [<Inline; JavaScript>]\n    member this.AddSeconds(seconds: float) : D =\n        this.Add (TS.FromSeconds seconds)\n\n    [<Inline; JavaScript>]\n    member this.AddMilliseconds(msec: float) : D =\n        this.Add (TS.FromMilliseconds msec)\n\n    [<Inline; JavaScript>]\n    member this.AddTicks(ticks: int64) : D =\n        this.Add (TS.FromTicks ticks)\n\n    [<Inline \"new Date($this).toLocaleDateString()\">]\n    member this.ToShortDateString() = X<string>\n    \n    [<Inline; JavaScript>]\n    member this.ToLongDateString() = DateTimeHelpers.LongDate(this)\n    \n    [<Inline; JavaScript>]\n    member this.ToShortTimeString() = DateTimeHelpers.ShortTime(this)\n\n    [<Inline; JavaScript>]\n    member this.ToLongTimeString() = DateTimeHelpers.LongTime(this)\n\n    [<Inline; JavaScript>]\n    static member Parse(s) = As<D>(DateTimeHelpers.Parse(s))\n\n    [<Inline; JavaScript>]\n    static member TryParse(s, [<Out>] res: byref<D>) =\n        match DateTimeHelpers.TryParse s with\n        | Some d ->\n            res <- As<D> d   \n            true\n        | _ -> false    \n\n    static member MaxValue\n        with [<Inline \"8640000000000000\">] get () = X<int>\n\n    static member MinValue\n        with [<Inline \"-8640000000000000\">] get () = X<int>\n\n[<Proxy(typeof<System.DateTimeOffset>)>]\n[<Name \"DateTimeOffset\">]\ntype private DateTimeOffsetProxy(d: int, o: int) =\n\n    [<Inline>]\n    new (d: D) = DateTimeOffsetProxy(As<int> d, 0) \n\n    [<Inline>]\n    member this.DateTime = d |> As<D>\n\n//    static member Now = X<D>\n\n//    static member UtcNow = DateTimeOffsetProxy(DateTime, o: int)\n        \n    member this.ToLocalTime() =\n        DateTimeOffsetProxy(d, As<int>(Date().GetTimezoneOffset())) |> As<DO>   \n        \n    member this.ToUniversalTime() =\n        DateTimeOffsetProxy(d, 0) |> As<DO>\n\n    [<Inline>]\n    member this.UtcDateTime = this.ToUniversalTime().DateTime\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen System\nopen WebSharper.JavaScript\n\n[<Name \"WebSharper.Delegate\">]\n[<Proxy(typeof<Delegate>)>]\ntype internal DelegateProxy =\n//    member this.GetLastInvoke() =\n//        let inv = As<Delegate[]> this?``$Invokes``\n//        if As inv then inv.[inv.Length - 1] else As this\n\n    [<Inline \"$this.apply(null, $args)\">]\n    member this.DynamicInvoke(args: obj[]) = X<obj>\n\n    [<Direct \"$0.$Invokes || [$0]\">]\n    static member InvocationList(del: Delegate) = X<Delegate[]> \n    [<Inline>]\n    member this.GetInvocationList() : Delegate[] =\n        DelegateProxy.InvocationList (As this)\n    \n    static member DelegateTarget(del) =\n        if (JS.Not del) then null\n        elif (JS.In \"$Target\" del) then del?``$Target``\n        elif (JS.In \"$Invokes\" del) then \n            let inv = del?``$Invokes`` : (_ * _)[]\n            snd inv.[inv.Length - 1]\n        else null\n\n    [<Inline>]\n    member this.Target =\n        DelegateProxy.DelegateTarget this\n\n    [<Inline \"$wsruntime.CreateDelegate($0)\">]\n    static member JSCreateDelegate(invokes: Delegate[]) = X<Delegate>\n\n    [<Inline \"$wsruntime.CombineDelegates([$0, $1])\">]\n    static member Combine(a: Delegate, b: Delegate) = X<Delegate>\n\n    [<Inline \"$wsruntime.CombineDelegates($0)\">]\n    static member Combine(delegates: Delegate[]) = X<Delegate>\n\n    [<Inline \"$wsruntime.DelegateEqual($0, $1)\">]\n    static member DelegateEqual(d1: Delegate, d2: Delegate) = X<bool>\n                           \n    static member Remove(source:Delegate, value: Delegate) =\n        let sourceInv = source.GetInvocationList()\n        if value.GetInvocationList().Length > 1 then\n            failwith \"TODO: Remove multicast delegates\"\n        let resInv = [||]\n        let mutable found = false\n        for i = sourceInv.Length - 1 downto 0 do\n            let it = sourceInv.[i]\n            if not found && DelegateProxy.DelegateEqual(it, value) then\n                found <- true\n            else\n                resInv.JS.Unshift(it) |> ignore\n        DelegateProxy.JSCreateDelegate(resInv)         \n\n    static member RemoveAll(source:Delegate, value: Delegate) =\n        let sourceInv = source.GetInvocationList()\n        if value.GetInvocationList().Length > 1 then\n            failwith \"TODO: Remove multicast delegates\"\n        DelegateProxy.JSCreateDelegate(sourceInv |> Array.filter (fun i -> not (i.Equals(value))))         \n\n[<Proxy(typeof<MulticastDelegate>)>]\ntype internal MulticastDelegateProxy =\n    \n    [<Inline>]\n    member this.GetInvocationList() : Delegate[] =\n        DelegateProxy.InvocationList (As this)\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.Collections\n\nopen WebSharper\nopen WebSharper.JavaScript\nopen System.Collections\nopen System.Collections.Generic\n\ntype private KVP<'K,'V> = KeyValuePair<'K,'V>\ntype private D<'K,'V> = Dictionary<'K,'V>\n\n[<JavaScript>]\nmodule internal DictionaryUtil =\n\n    let notPresent () =\n        failwith \"The given key was not present in the dictionary.\"\n\n    let alreadyAdded () =\n        failwith \"An item with the same key has already been added.\"\n\n    let equals (c: IEqualityComparer<'T>) =\n        FuncWithArgs(fun (x, y) -> c.Equals(x, y))\n\n    [<Inline>]\n    let genEquals<'T when 'T : equality> () = \n        FuncWithArgs(fun (x :'T, y) -> x = y)\n\n    let getHashCode (c: IEqualityComparer<'T>) x =\n        c.GetHashCode x\n\nopen DictionaryUtil\nopen System.Runtime.InteropServices\n\n// not really used, a sequence enumerator is cast to this type instead\n// proxy is needed so calls against it compile\n// TODO: lazy iterating\n[<Proxy(typeof<D<_,_>.KeyCollection.Enumerator>)>]\n[<Stub>]\ntype private KeyCollectionEnumeratorProxy<'K,'V> [<JavaScript(false)>] () =\n    [<Inline \"$this.Current()\">]\n    member this.get_Current() = As<'K> 0        \n    member this.MoveNext() = false\n    member this.Dispose() = ()\n\n// not really used, a sequence enumerator is cast to this type instead\n// proxy is needed so calls against it compile\n// TODO: lazy iterating\n[<Proxy(typeof<D<_,_>.ValueCollection.Enumerator>)>]\n[<Stub>]\ntype private ValueCollectionEnumeratorProxy<'K,'V> [<JavaScript(false)>] () =\n    [<Inline \"$this.Current()\">]\n    member this.get_Current() = As<'V> 0        \n    member this.MoveNext() = false\n    member this.Dispose() = ()\n\n[<Name \"WebSharper.Collections.KeyCollection\">]\n[<Proxy(typeof<D<_,_>.KeyCollection>)>]\ntype private KeyCollectionProxy<'K,'V> (d: D<'K,'V>) =\n    member this.Count = d.Count \n\n    member this.GetEnumerator() =\n        As<D<'K,'V>.KeyCollection.Enumerator>(\n            (d |> Seq.map(fun kvp -> kvp.Key)).GetEnumerator())\n            \n    interface IEnumerable<'K> with\n        member this.GetEnumerator() = As<IEnumerator<'K>>(this.GetEnumerator())\n        member this.GetEnumerator() = As<IEnumerator>(this.GetEnumerator())\n\n[<Name \"WebSharper.Collections.ValueCollection\">]\n[<Proxy(typeof<D<_,_>.ValueCollection>)>]\ntype private ValueCollectionProxy<'K,'V> (d: D<'K,'V>) =\n    member this.Count = d.Count \n\n    member this.GetEnumerator() =\n        As<D<'K,'V>.ValueCollection.Enumerator>(\n            (d |> Seq.map(fun kvp -> kvp.Value)).GetEnumerator())\n            \n    interface IEnumerable<'V> with\n        member this.GetEnumerator() = As<IEnumerator<'V>>(this.GetEnumerator())\n        member this.GetEnumerator() = As<IEnumerator>(this.GetEnumerator())\n\n[<Proxy(typeof<D<_,_>.Enumerator>)>]\n[<Stub>]\ntype private DictionaryEnumeratorProxy<'K,'V> [<JavaScript(false)>] () =\n    [<Inline \"$this.Current()\">]\n    member this.get_Current() = As<KVP<'K,'V>> 0        \n    member this.MoveNext() = false\n    member this.Dispose() = ()\n\n/// Implements a proxy for the .NET dictionary.\n[<Name \"WebSharper.Collections.Dictionary\">]\n[<Proxy(typeof<D<_,_>>)>]\ntype internal Dictionary<'K,'V when 'K : equality>\n\n    private (init   : seq<KVP<'K,'V>>,\n             equals : FuncWithArgs<'K * 'K, bool>,\n             hash   : 'K -> int) =\n\n        let mutable count = 0\n        let mutable data  = As<Array<Array<KVP<'K, 'V>>>> [||]\n\n        let get k =\n            let h = hash k\n            let d = data.[h]\n            if As<bool> d then\n                d.Self |> Array.pick (fun (KeyValue(dk, v)) -> \n                    if equals.Call(dk, k) then Some v else None\n                ) \n            else\n                notPresent()\n\n        let set k v =\n            let h = hash k\n            let d = data.[h]\n            if As<bool> d then\n                match d.Self |> Array.tryFindIndex (fun (KeyValue(dk, _)) -> equals.Call(dk, k)) with\n                | Some i ->\n                    d.[i] <- KVP(k, v) \n                | None ->\n                    count <- count + 1\n                    d.Push(KVP(k, v)) |> ignore\n            else\n                count <- count + 1\n                data.[h] <- Array(KVP(k, v))\n                    \n        let add k v =\n            let h = hash k\n            let d = data.[h]\n            if As<bool> d then\n                if d.Self |> Array.exists (fun (KeyValue(dk, _)) -> equals.Call(dk, k)) then\n                    alreadyAdded()                    \n                count <- count + 1\n                d.Push(KVP(k, v)) |> ignore\n            else\n                count <- count + 1\n                data.[h] <- Array(KVP(k, v))\n                    \n        let remove k =\n            let h = hash k \n            let d = data.[h]\n            if As<bool> d then\n                let r = d.Self |> Array.filter (fun (KeyValue(dk, _)) -> not (equals.Call(dk, k)))\n                if r.Length < d.Length then                  \n                    count <- count - 1\n                    data.[h] <- r.JS\n                    true\n                else\n                    false\n            else\n                false\n\n        do for x in init do\n            set x.Key x.Value\n\n        new () = new Dictionary<'K,'V>([||], genEquals<'K>(), hash)\n\n        new (capacity: int) = new Dictionary<'K,'V>()\n\n        new (comparer: IEqualityComparer<'K>) =\n            new Dictionary<'K,'V>([||], equals comparer, getHashCode comparer)\n\n        new (capacity: int, comparer: IEqualityComparer<'K>) =\n            new Dictionary<'K,'V>(comparer)\n\n        new (dictionary: IDictionary<'K,'V>) =\n            new Dictionary<'K,'V>(dictionary, genEquals<'K>(), hash)\n\n        new (dictionary: IDictionary<'K,'V>, comparer: IEqualityComparer<'K>) =\n            new Dictionary<'K,'V>(\n                dictionary,\n                equals comparer,\n                getHashCode comparer\n            )\n\n        member this.Add(k: 'K, v: 'V) =\n            add k v\n\n        member this.Clear() =\n            data <- Array()\n            count <- 0\n\n        member this.ContainsKey(k: 'K) =\n            let h = hash k\n            let d = data.[h]\n            if As<bool> d then\n                d.Self |> Array.exists (fun (KeyValue(dk, _)) -> \n                    equals.Call(dk, k)\n                ) \n            else\n                false\n\n        member this.Count with [<Inline>] get () = count\n\n        member this.Item\n            with get (k: 'K) : 'V = get k\n            and set (k: 'K) (v: 'V) = set k v\n\n        member this.GetEnumerator() = As<D<'K,'V>.Enumerator> ((this :> System.Collections.IEnumerable).GetEnumerator())\n\n        interface System.Collections.IEnumerable with\n            member this.GetEnumerator() = \n                let s = JS.GetFieldValues data\n                (As<KeyValuePair<'K,'V>[][]> s |> Array.concat).GetEnumerator()\n            \n        interface IEnumerable<KeyValuePair<'K,'V>> with\n            member this.GetEnumerator() = As<IEnumerator<KeyValuePair<'K,'V>>> ((this :> System.Collections.IEnumerable).GetEnumerator())\n\n        member this.Remove(k: 'K) =\n            remove k\n\n        member this.TryGetValue(k: 'K, [<Out>] res : byref<'V>) =\n            let h = hash k\n            let d = data.[h]\n            if As<bool> d then\n                let v =\n                    d.Self |> Array.tryPick (fun (KeyValue(dk, v)) -> \n                        if equals.Call(dk, k) then Some v else None\n                    ) \n                match v with \n                | Some v -> \n                    res <- v\n                    true\n                | _ -> false\n            else\n                false\n\n        member this.Values =\n            As<D<'K,'V>.ValueCollection>(ValueCollectionProxy(As<D<'K,'V>>this))\n\n        member this.Keys =\n            As<D<'K,'V>.KeyCollection>(KeyCollectionProxy(As<D<'K,'V>>this))\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen WebSharper.JavaScript\n\n[<Name [| \"Error\" |]>]\n[<Proxy(typeof<System.Exception>)>]\ntype private ExceptionProxy =\n    [<Inline \"Error($message)\">]\n    new (message: string) = { }\n\n    [<Inline \"var e = Error($message); e.inner = $inner; return e\">]\n    new (message: string, inner: exn) = { }\n\n    [<Inline>]\n    new () = ExceptionProxy \"Exception of type 'System.Exception' was thrown.\"\n\n    member this.Message with [<Inline \"$this.message\">] get () = X<string>\n    member this.InnerException with [<Inline \"$this.inner\">] get () = X<System.Exception>\n\n[<Proxy(typeof<MatchFailureException>)>]\n[<Name \"MatchFailureException\">]\ntype private MatchFailureExceptionProxy (message: string, line: int, column: int) =\n    inherit exn(message + \" at \" + string line + \":\" + string column)\n\n[<Proxy(typeof<System.IndexOutOfRangeException>)>]\n[<Name \"IndexOutOfRangeException\">]\ntype private IndexOutOfRangeExceptionProxy(message: string) =\n    inherit exn(message)\n\n    new () = IndexOutOfRangeExceptionProxy \"Index was outside the bounds of the array.\"\n\n[<Proxy(typeof<System.OperationCanceledException>)>]\n[<Name \"OperationCanceledException\">]\ntype private OperationCanceledExceptionProxy(message: string, inner: exn, ct: CT) =\n    inherit exn(message, inner)\n\n    new (ct) = OperationCanceledExceptionProxy (\"The operation was canceled.\", null, ct)\n    \n    [<Inline>]\n    new () = OperationCanceledExceptionProxy (CT.None)\n    [<Inline>]\n    new (message) = OperationCanceledExceptionProxy (message, null, CT.None)\n    [<Inline>]\n    new (message, ct) = OperationCanceledExceptionProxy (message, null, ct)\n    [<Inline>]\n    new (message, inner) = OperationCanceledExceptionProxy (message, inner, CT.None)\n\n    [<Inline>]\n    member this.CancellationToken = ct\n\n[<Proxy(typeof<System.ArgumentException>)>]\n[<Name \"ArgumentException\">]\ntype private ArgumentExceptionProxy(message: string) =\n    inherit exn(message)\n    \n    new () = ArgumentExceptionProxy \"Value does not fall within the expected range.\"\n\n    new (argumentName: string, message: string) =\n        ArgumentExceptionProxy (message + \"\\nParameter name: \" + argumentName)\n\n[<Proxy(typeof<System.ArgumentOutOfRangeException>)>]\n[<Name \"ArgumentOutOfRangeException\">]\ntype private ArgumentOutOfRangeExceptionProxy(message: string) =\n    inherit exn(message)\n    \n    new () = ArgumentOutOfRangeExceptionProxy \"Specified argument was out of the range of valid values.\"\n\n[<Proxy(typeof<System.InvalidOperationException>)>]\n[<Name \"InvalidOperationException\">]\ntype private InvalidOperationExceptionProxy(message: string) =\n    inherit exn(message)\n    \n    new () = InvalidOperationExceptionProxy \"Operation is not valid due to the current state of the object.\"\n\n[<Proxy(typeof<System.AggregateException>)>]\n[<Name \"AggregateException\">]\ntype private AggregateExceptionProxy(message: string, innerExceptions: exn[]) =\n    inherit exn(message)\n\n    new (innerExceptions: exn[]) = AggregateExceptionProxy(\"One or more errors occurred.\", innerExceptions)\n\n    new (innerExceptions: seq<exn>) = AggregateExceptionProxy(\"One or more errors occurred.\", Array.ofSeq innerExceptions)\n\n    new (message, innerExceptions: seq<exn>) = AggregateExceptionProxy(message, Array.ofSeq innerExceptions)\n\n    new (message, innerException: exn) = AggregateExceptionProxy(message, [| innerException |])\n\n    [<Inline>]\n    member this.InnerExceptions \n        with get() = As<System.Collections.ObjectModel.ReadOnlyCollection<exn>> innerExceptions\n\n[<Proxy(typeof<System.TimeoutException>)>]\n[<Name \"TimeoutException\">]\ntype private TimeoutExceptionProxy(message: string) =\n    inherit exn(message)\n    \n    new () = TimeoutExceptionProxy \"The operation has timed out.\"\n\n[<Proxy(typeof<System.FormatException>)>]\n[<Name \"FormatException\">]\ntype private FormatException(message: string) =\n    inherit exn(message)\n\n    new () = FormatException \"One of the identified items was in an invalid format.\"\n\n[<Proxy(typeof<System.OverflowException>)>]\n[<Name \"OverflowException\">]\ntype private OverflowException(message: string) =\n    inherit exn(message)\n\n    new () = OverflowException \"Arithmetic operation resulted in an overflow.\"\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Core.ExtraTopLevelOperators, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.ExtraTopLevelOperatorsProxy\n\nopen WebSharper.JavaScript\nmodule M = WebSharper.Macro\n\n[<Inline \"null\">]\nlet DefaultAsyncBuilder : Control.AsyncBuilder =\n    As (AsyncBuilderProxy())\n\n[<Name \"WebSharper.Arrays.create2D\" >]\nlet CreateArray2D (rows : seq<#seq<'T>>) =\n    let arr = rows |> Seq.map (Array.ofSeq) |> Array.ofSeq |> As<'T[,]>\n    arr?dims <- 2\n    arr\n\n[<Inline \"+$0\">]\nlet ToDouble<'T> (x: 'T) : double = X\n\n[<Inline \"$f(function(x){return x;})\">]\nlet PrintFormatToString (f: Printf.StringFormat<'T>) = X<'T>\n\n[<Inline; JavaScript>]\nlet PrintFormatToStringThen k f = Printf.ksprintf k f \n\n[<Inline; JavaScript>]\nlet PrintFormatLine f = Printf.printfn f \n\n[<Inline; JavaScript>]\nlet PrintFormatToStringThenFail f = Printf.failwithf f \n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.Collections\n\nopen System.Collections\nopen System.Collections.Generic\n\nopen WebSharper\nopen WebSharper.JavaScript\n\n[<AutoOpen>]\nmodule private HashSetUtil =\n    [<Direct \"var r=[]; for(var k in $o) { r.push.apply(r, $o[k]) }; return r\">]\n    let concat (o: Array<Array<'T>>) = X<Array<'T>>\n    \nopen DictionaryUtil\n\n// not really used, an array enumerator is cast to this type instead\n// proxy is needed so calls against it compile\n// TODO: lazy iterating\n[<Proxy(typeof<HashSet<_>.Enumerator>)>]\n[<Stub>]\ntype private HashSetEnumeratorProxy<'T> [<JavaScript(false)>] () =\n    [<Inline \"$this.Current()\">]\n    member this.get_Current() = As<'T> 0        \n    member this.MoveNext() = false\n    member this.Dispose() = ()\n\n[<Proxy(typeof<HashSet<_>>)>]\n[<Name \"HashSet\">]\ntype internal HashSetProxy<'T when 'T : equality>\n\n    private (init   : seq<'T>,\n             equals : FuncWithArgs<'T * 'T, bool>,\n             hash   : 'T -> int) =\n\n        let mutable data  = Array<Array<'T>>()\n        let mutable count = 0\n\n        let arrContains (item: 'T) (arr: Array<'T>)  =\n            let mutable c = true\n            let mutable i = 0\n            let l = arr.Length\n            while c && i < l do\n                if equals.Call(arr.[i], item) then\n                    c <- false\n                else\n                    i <- i + 1\n            not c\n\n        let arrRemove (item: 'T) (arr: Array<'T>)  =\n            let mutable c = true\n            let mutable i = 0\n            let l = arr.Length\n            while c && i < l do\n                if equals.Call(arr.[i], item) then\n                    arr.Splice(i, 1) |> ignore\n                    c <- false\n                else\n                    i <- i + 1\n            not c\n\n        let add (item: 'T) =\n            let h = hash item\n            let arr = data.[h]\n            if arr ==. null then\n                data.[h] <- As [| item |]\n                count <- count + 1\n                true\n            else\n                if arrContains item arr then false else    \n                    arr.Push item |> ignore\n                    count <- count + 1\n                    true\n\n        do for x in init do add x |> ignore\n\n        new () = HashSetProxy<'T>(Seq.empty, genEquals<'T>(), hash)\n\n        new (init: seq<'T>) = new HashSetProxy<'T>(init, genEquals<'T>(), hash)\n\n        new (comparer: IEqualityComparer<'T>) =\n            new HashSetProxy<'T>(Seq.empty, equals comparer, getHashCode comparer)\n\n        new (init: seq<'T>, comparer: IEqualityComparer<'T>) =\n            new HashSetProxy<'T>(init, equals comparer, getHashCode comparer)\n\n        member this.Add(item: 'T) = add item\n\n        member this.Clear() =\n            data <- Array()\n            count <- 0\n\n        member x.Contains(item: 'T) =\n            let arr = data.[hash item]\n            if arr ==. null then false else arrContains item arr\n\n        member x.CopyTo(arr: 'T[]) =\n            let mutable i = 0\n            let all = concat data \n            for i = 0 to all.Length - 1 do \n                arr.[i] <- all.[i]\n\n        member x.Count = count\n\n        member x.ExceptWith(xs: seq<'T>) =\n            for item in xs do\n                x.Remove(item) |> ignore\n\n        [<Inline>]\n        member this.GetEnumerator() =\n           As<HashSet<'T>.Enumerator>((As<seq<'T>>(concat data)).GetEnumerator())\n\n        interface IEnumerable with\n            member this.GetEnumerator() = this.GetEnumerator() :> _\n        \n        interface IEnumerable<'T> with\n            member this.GetEnumerator() = this.GetEnumerator() :> _\n\n        // TODO: optimize methods by checking if other collection\n        // is a HashSet with the same IEqualityComparer\n        \n        member x.IntersectWith(xs: seq<'T>) =\n            let other = HashSetProxy(xs, equals, hash) \n            let all = concat data\n            for i = 0 to all.Length - 1 do\n                let item = all.[i]\n                if other.Contains(item) |> not then\n                    x.Remove(item) |> ignore\n\n        member x.IsProperSubsetOf(xs: seq<'T>) =\n            let other = xs |> Array.ofSeq\n            count < other.Length && x.IsSubsetOf(other)\n\n        member x.IsProperSupersetOf(xs: seq<'T>) =\n            let other = xs |> Array.ofSeq\n            count > other.Length && x.IsSupersetOf(other)\n\n        member x.IsSubsetOf(xs: seq<'T>) =\n            let other = HashSetProxy(xs, equals, hash)\n            As<_[]>(concat data) |> Array.forall other.Contains\n\n        member x.IsSupersetOf(xs: seq<'T>) =\n            xs |> Seq.forall x.Contains\n\n        member x.Overlaps(xs: seq<'T>) =\n            xs |> Seq.exists x.Contains\n\n        member x.Remove(item: 'T) =\n            let h = hash item\n            let arr = data.[h]\n            if arr ==. null then false else\n                if arrRemove item arr then\n                    count <- count - 1\n                    true\n                else false\n\n        member x.RemoveWhere(cond: System.Predicate<'T>) =\n            let all = concat data\n            let mutable res = 0\n            for i = 0 to all.Length - 1 do\n                let item = all.[i]\n                if cond.Invoke item then\n                    if x.Remove(item) then\n                        res <- res + 1\n            res\n\n        member x.SetEquals(xs: seq<'T>) =\n            let other = HashSetProxy(xs, equals, hash)\n            x.Count = other.Count && x.IsSupersetOf(other)\n\n        member x.SymmetricExceptWith(xs: seq<'T>) =\n            for item in xs do\n                if x.Contains item then\n                    x.Remove(item) |> ignore\n                else\n                    x.Add(item) |> ignore\n\n        member x.UnionWith(xs: seq<'T>) =\n            for item in xs do\n                x.Add(item) |> ignore\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen WebSharper.JavaScript\n\n[<Proxy(typeof<System.IComparable>)>]\ntype private IComparableProxy =\n    [<Name \"CompareTo0\">]\n    abstract CompareTo : obj -> int\n\n[<Proxy(typeof<System.IComparable<_>>)>]\ntype private IComparableProxy<'T> =\n    [<Name \"CompareTo\">]\n    abstract CompareTo : 'T -> int\n\n[<Proxy(typeof<System.Collections.IEqualityComparer>)>]\ntype private IEqualityComparerProxy =\n    [<Name \"CEquals0\">]\n    abstract Equals : obj * obj -> bool \n    [<Name \"CGetHashCode0\">]\n    abstract GetHashCode : obj -> int\n\n[<Proxy(typeof<System.Collections.Generic.IEqualityComparer<_>>)>]\ntype private IEqualityComparerProxy<'T> =\n    [<Name \"CEquals\">]\n    abstract Equals : 'T * 'T -> bool \n    [<Name \"CGetHashCode\">]\n    abstract GetHashCode : 'T -> int\n\n[<Proxy(typeof<System.Collections.Generic.EqualityComparer<_>>)>]\n[<Name \"WebSharper.Collections.EqualityComparer\">]\n[<AbstractClass>]\ntype private EqualityComparerProxy<'T>() =\n    abstract Equals : 'T * 'T -> bool \n    abstract GetHashCode : 'T -> int\n    interface System.Collections.Generic.IEqualityComparer<'T> with\n        member this.Equals(x, y) = this.Equals(x, y)\n        member this.GetHashCode(x) = this.GetHashCode(x)\n    interface System.Collections.IEqualityComparer with\n        member this.Equals(x, y) = this.Equals(As x, As y)\n        member this.GetHashCode(x) = this.GetHashCode(As x)\n    [<Macro(typeof<Macro.EqualityComparer>)>]\n    static member Default = X<System.Collections.Generic.EqualityComparer<'T>>\n\n[<Proxy(typeof<System.Collections.IComparer>)>]\ntype private IComparerProxy =\n    [<Name \"Compare0\">]\n    abstract Compare : obj * obj -> int\n\n[<Proxy(typeof<System.Collections.Generic.IComparer<_>>)>]\ntype private IComparerProxy<'T> =\n    [<Name \"Compare\">]\n    abstract Compare : 'T * 'T -> int\n\n[<Proxy(typeof<System.Collections.Generic.Comparer<_>>)>]\n[<Name \"WebSharper.Collections.Comparer\">]\n[<AbstractClass>]\ntype private ComparerProxy<'T>() =\n    abstract Compare : 'T * 'T -> int\n    interface System.Collections.Generic.IComparer<'T> with\n        member this.Compare(x, y) = this.Compare(x, y)\n    interface System.Collections.IComparer with\n        member this.Compare(x, y) = this.Compare(As x, As y)\n    [<Macro(typeof<Macro.Comparer>)>]\n    static member Default = X<System.Collections.Generic.Comparer<'T>>\n\n[<Proxy(typeof<System.IEquatable<_>>)>]\ntype private IEquatableProxy<'T> =\n    [<Name \"EEquals\">]\n    abstract Equals : 'T -> bool\n\n[<Proxy(typeof<System.Collections.IStructuralEquatable>)>]\ntype private IStructuralEquatableProxy =\n    [<Name \"SEquals\">]\n    abstract Equals : obj * System.Collections.IEqualityComparer -> bool \n    [<Name \"SGetHashCode\">]\n    abstract GetHashCode : System.Collections.IEqualityComparer -> int\n\n[<Proxy(typeof<System.Collections.IStructuralComparable>)>]\ntype private IStructuralComparableProxy =\n    [<Name \"SCompareTo\">]\n    abstract CompareTo : obj * System.Collections.IComparer -> int \n\n[<Proxy(typeof<System.IDisposable>)>]\ntype private IDisposableProxy =\n    [<Name \"Dispose\">]\n    abstract member Dispose : unit -> unit\n\n[<Proxy(typeof<System.Collections.IEnumerable>)>]  \ntype private IEnumerableProxy =\n\n    [<Name \"GetEnumerator0\">]\n    abstract GetEnumerator : unit -> System.Collections.IEnumerator\n\n[<Proxy(typeof<seq<_>>)>]  \ntype private IEnumerableProxy<'T> =\n    inherit System.Collections.IEnumerable \n    \n    [<Name \"GetEnumerator\">]\n    abstract GetEnumerator : unit -> System.Collections.Generic.IEnumerator<'T>\n    \n[<Proxy(typeof<System.Collections.IEnumerator>)>]\n[<Name \"WebSharper.IEnumerator\">]\ntype private IEnumeratorProxy =\n    [<Name \"Current0\">]\n    abstract member Current  : obj\n    [<Name \"MoveNext\">]\n    abstract member MoveNext : unit -> bool\n    [<Name \"Reset\">]\n    abstract member Reset    : unit -> unit\n\n[<Proxy(typeof<System.Collections.Generic.IEnumerator<_>>)>]\n[<Name \"WebSharper.IEnumerator1\">]\ntype private IEnumeratorProxy<'T> =\n    [<Name \"Current\">]\n    abstract member Current : 'T\n\n[<Proxy(typeof<System.IObservable<_>>)>]\ntype private IObservableProxy<'T> =\n    [<Name \"Subscribe\">]\n    abstract member Subscribe : System.IObserver<'T> -> System.IDisposable\n\n[<Proxy(typeof<System.IObserver<_>>)>]\ntype private IObserverProxy<'T> =\n    [<Name \"OnCompleted\">]\n    abstract member OnCompleted : unit -> unit\n    [<Name \"OnError\">]\n    abstract member OnError : exn -> unit\n    [<Name \"OnNext\">]\n    abstract member OnNext : 'T -> unit\n\n[<Proxy(typeof<IDelegateEvent<_>>)>]\ntype private IDelegateEventProxy<'D> =\n    [<Name \"AddHandler\">]\n    abstract AddHandler : 'D -> unit\n    [<Name \"RemoveHandler\">]\n    abstract RemoveHandler : 'D -> unit\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.Name \"Lazy\">]\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Control.LazyExtensions, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.LazyExtensionsProxy\n\nopen WebSharper.JavaScript\n\n[<JavaScript; Prototype false>]\ntype LazyRecord<'T> =\n    {\n        [<Name \"c\">] mutable created : bool\n        [<Name \"v\">] mutable evalOrVal : obj\n        [<Name \"f\">] mutable force : unit -> 'T\n    }\n\nlet cachedLazy<'T> () =\n    JS.This.evalOrVal\n\nlet forceLazy<'T> () =\n    let v = (As JS.This.evalOrVal)()\n    JS.This.created <- true\n    JS.This.evalOrVal <- v\n    JS.This.force <- As cachedLazy\n    v\n\nlet Create (f: unit -> 'T) : Lazy<'T> =\n    As {\n        created = false\n        evalOrVal = f\n        force = As forceLazy\n    }\n\nlet CreateFromValue (v: 'T) : Lazy<'T> =\n    As {\n        created = true\n        evalOrVal = v\n        force = As cachedLazy\n    }\n\nlet Force (x: Lazy<'T>) : 'T =\n    As<LazyRecord<'T>>(x).force()\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen WebSharper.JavaScript\n\n[<Proxy(typeof<list<_>>)>]\n[<Name \"WebSharper.List.T\">]\n[<DefaultAugmentation(false)>]\ntype private ListProxy<'T> =\n    | Empty\n    | Cons of Head: 'T * Tail: List<'T>\n\n    [<Inline; Pure>]\n    static member Cons(head: 'T, tail: list<'T>) = head :: tail\n\n    [<Inline; Pure>]\n    static member Empty : list<'T> = []\n\n    member this.Head with [<Inline>] get () = List.head (As this) : 'T\n    member this.Tail with [<Inline>] get () = List.tail (As this) : list<'T>\n    member this.IsEmpty with [<Inline \"$this.$ == 0\">] get () = X<bool>\n\n    member this.Length with get () = List.length (As this)\n\n    member this.Item with get (x: int) : 'T = List.nth (As this) x\n\n    interface System.Collections.IEnumerable with\n        member this.GetEnumerator() = (this :> _ seq).GetEnumerator() :> _\n\n    interface seq<'T> with\n        member this.GetEnumerator() =\n            let data = As<list<'T>> this\n            Enumerator.New data (fun e ->\n                match e.State with\n                | x :: xs ->\n                    e.Current <- x\n                    e.State <- xs\n                    true\n                | [] ->\n                    false)\n\n    member this.GetSlice(start, finish) : list<'T> =\n        match start, finish with\n        | None, None -> As this\n        | Some i, None -> As this |> CollectionInternals.ListSkip i\n        | None, Some j -> As this |> Seq.take (j + 1) |> List.ofSeq  \n        | Some i, Some j -> As this |> CollectionInternals.ListSkip i |> Seq.take (j - i + 1) |> List.ofSeq        \n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.Name \"List\">]\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Collections.ListModule, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.ListModuleProxy\n\nopen WebSharper.JavaScript\nopen WebSharper.CollectionInternals\n\nlet badLengths() =\n    failwith \"The lists have different lengths.\"\n\nlet listEmpty() =\n    failwith \"The input list was empty.\"\n\n[<Inline \"$l.$0\">]\nlet unsafeHead (l: list<'T>) = X<'T> \n\n[<Inline \"$l.$1\">]\nlet unsafeTail (l: list<'T>) = X<list<'T>> \n\n[<Inline>]\nlet setValue (l: list<'T>) (v: 'T) =\n    JS.Set l \"$0\" v\n\n[<Inline>]\nlet setTail (l: list<'T>) (t: list<'T>) =\n    JS.Set l \"$1\" t\n\n[<Inline \"new WebSharper.List.T({$: 1})\"; Pure>]\nlet freshEmptyList() = X<list<'T>>\n\n[<Inline>]\nlet freshTail (l: list<'T>) =\n    let t = freshEmptyList()\n    setTail l t\n    t\n\n[<Inline \"$l.$ == 1\">]\nlet notEmpty (l: list<_>) = X<bool>\n\n[<Name \"allPairs\">]\nlet AllPairs (l1: list<_>) (l2: list<_>) =\n    let arr1 = Array.ofList l1\n    let arr2 = Array.ofList l2\n    let res = Array.allPairs arr1 arr2\n    List.ofArray res\n\n[<Name \"append\">]\nlet Append (x: list<'T>) (y: list<'T>) = \n    if List.isEmpty x then y\n    elif List.isEmpty y then x else\n    let res = freshEmptyList()\n    let mutable r = res\n    let mutable l = x\n    let mutable go = true\n    while go do\n        setValue r (unsafeHead l)\n        l <- unsafeTail l\n        if List.isEmpty l then\n            go <- false\n        else\n            r <- freshTail r\n    setTail r y |> ignore\n    res\n\n[<Inline>]\nlet inline Average (l: list<_>) = Seq.average l\n\n[<Inline>]\nlet inline AverageBy f (l: list<_>) = Seq.averageBy f l\n\n[<Name \"choose\">]\nlet Choose f (l: list<_>) = List.ofSeq (Seq.choose f l)\n\n[<Name \"collect\">]\nlet Collect (f: _ -> list<_>) (l: list<_>) = List.ofSeq (Seq.collect f l)\n\n[<Name \"concat\">]\nlet Concat (s: seq<list<_>>) = List.ofSeq (Seq.concat s)\n\n[<Inline>]\nlet Empty<'T> : list<'T> = []\n\n[<Name \"exists\">]\nlet Exists<'T> (p: 'T -> bool) (x: list<'T>) =\n    let mutable e = false\n    let mutable l = x\n    while not e && notEmpty l do\n        e <- p (unsafeHead l)\n        l <- unsafeTail l\n    e\n\n[<Name \"exists2\">]\nlet Exists2<'T1,'T2> (p : 'T1 -> 'T2 -> bool)\n                        (x1: list<'T1>)\n                        (x2: list<'T2>) =\n    let mutable e = false\n    let mutable l1 = x1\n    let mutable l2 = x2\n    while not e && notEmpty l1 && notEmpty l2 do\n        e <- p (unsafeHead l1) (unsafeHead l2)\n        l1 <- unsafeTail l1\n        l2 <- unsafeTail l2\n    if not e && (notEmpty l1 || notEmpty l2) then\n        badLengths()\n    e\n\n[<Name \"filter\">]\nlet Filter<'T> (p: 'T -> bool) (l: list<'T>) =\n    List.ofSeq (Seq.filter p l)\n\n[<Inline>]\nlet Find p (l: list<_>) = Seq.find p l\n\n[<Inline>]\nlet FindIndex p (l: list<_>) = Seq.findIndex p l\n\n[<Inline>]\nlet Fold<'T,'S> (f: 'S -> 'T -> 'S) (s: 'S) (l: list<'T>) : 'S =\n    Seq.fold f s l\n\n[<Name \"fold2\">]\nlet Fold2<'T1,'T2,'S> (f: 'S -> 'T1 -> 'T2 -> 'S)\n                        (s: 'S)\n                        (l1: list<'T1>)\n                        (l2: list<'T2>) : 'S =\n    Array.fold2 f s (Array.ofList l1) (Array.ofList l2)\n\n[<Name \"foldBack\">]\nlet FoldBack f (l: list<_>) s =\n    Array.foldBack f (Array.ofList l) s\n\n[<Name \"foldBack2\">]\nlet FoldBack2 f (l1: list<_>) (l2: list<_>) s =\n    Array.foldBack2 f (Array.ofList l1) (Array.ofList l2) s\n\n[<Name \"forAll\">]\nlet ForAll p (x: list<_>) =\n    let mutable a = true\n    let mutable l = x\n    while a && notEmpty l do\n        a <- p (unsafeHead l)\n        l <- unsafeTail l\n    a\n\n[<Name \"forall2\">]\nlet ForAll2 p (x1: list<_>) (x2: list<_>) =\n    let mutable a = true\n    let mutable l1 = x1\n    let mutable l2 = x2\n    while a && notEmpty l1 && notEmpty l2 do\n        a <- p (unsafeHead l1) (unsafeHead l2)\n        l1 <- unsafeTail l1\n        l2 <- unsafeTail l2\n    if a && (notEmpty l1 || notEmpty l2) then\n        badLengths()\n    a\n\n[<Name \"head\">]\nlet Head (l: list<'T>) =\n    match l with \n    | h :: _ -> h\n    | _ -> listEmpty()\n\n[<Name \"init\">]\nlet Initialize s f = List.ofArray (Array.init s f)\n\n[<Inline \"$l.$ == 0\">]\nlet IsEmpty (l: list<_>) = X<bool>\n\n[<Name \"iter\">]\nlet Iterate f (l: list<_>) =\n    let mutable r = l\n    while notEmpty r do\n        f r.Head\n        r <- r.Tail\n\n[<Name \"iter2\">]\nlet Iterate2 f (l1: list<_>) (l2: list<_>) =\n    let mutable r1 = l1\n    let mutable r2 = l2\n    while notEmpty r1 do\n        if List.isEmpty r2 then\n            badLengths()\n        f r1.Head r2.Head\n        r1 <- r1.Tail\n        r2 <- r2.Tail\n    if notEmpty r2 then\n        badLengths()\n\n[<Name \"iteri\">]\nlet IterateIndexed f (l: list<_>) =\n    let mutable r = l\n    let mutable i = 0\n    while notEmpty r do\n        f i r.Head\n        r <- r.Tail\n        i <- i + 1\n\n[<Name \"iteri2\">]\nlet IterateIndexed2 f (l1: list<_>) (l2: list<_>) =\n    let mutable r1 = l1\n    let mutable r2 = l2\n    let mutable i = 0\n    while notEmpty r1 do\n        if List.isEmpty r2 then\n            badLengths()\n        f i r1.Head r2.Head\n        r1 <- r1.Tail\n        r2 <- r2.Tail\n        i <- i + 1\n    if notEmpty r2 then\n        badLengths()\n\n[<Name \"length\">]\nlet Length (l: list<_>) =\n    let mutable r = l\n    let mutable i = 0\n    while notEmpty r do\n        r <- r.Tail\n        i <- i + 1\n    i\n\n[<Name \"map\">]\nlet Map (f: 'T1 -> 'T2) (x: list<'T1>) = \n    if List.isEmpty x then As x else\n    let res = freshEmptyList()\n    let mutable r = res\n    let mutable l = x\n    let mutable go = true\n    while go do\n        setValue r (f (unsafeHead l))\n        l <- unsafeTail l\n        if List.isEmpty l then\n            go <- false\n        else\n            r <- freshTail r\n    setTail r []\n    res\n\n[<Name \"map2\">]\nlet Map2 (f: 'T1 -> 'T2 -> 'T3) (x1: list<'T1>) (x2: list<'T2>) =\n    let mutable go = notEmpty x1 && notEmpty x2\n    if not go then \n        if notEmpty x1 || notEmpty x2 then\n            badLengths()\n        else As x1\n    else\n    let res = freshEmptyList()\n    let mutable r = res\n    let mutable l1 = x1\n    let mutable l2 = x2\n    while go do\n        setValue r (f (unsafeHead l1) (unsafeHead l2))\n        l1 <- unsafeTail l1\n        l2 <- unsafeTail l2\n        if notEmpty l1 && notEmpty l2 then\n            r <- freshTail r\n        else \n            go <- false\n    if notEmpty l1 || notEmpty l2 then\n        badLengths()\n    setTail r []\n    res\n\n[<Name \"map3\">]\nlet Map3 (f: 'T1 -> 'T2 -> 'T3 -> 'T4) (x1: list<'T1>) (x2: list<'T2>) (x3: list<'T3>) =\n    let mutable go = notEmpty x1 && notEmpty x2 && notEmpty x3\n    if not go then \n        if notEmpty x1 || notEmpty x2 || notEmpty x3 then\n            badLengths()\n        else As x1\n    else\n    let res = freshEmptyList()\n    let mutable r = res\n    let mutable l1 = x1\n    let mutable l2 = x2\n    let mutable l3 = x3\n    while go do\n        setValue r (f (unsafeHead l1) (unsafeHead l2) (unsafeHead l3))\n        l1 <- unsafeTail l1\n        l2 <- unsafeTail l2\n        l3 <- unsafeTail l3\n        if notEmpty l1 && notEmpty l2 && notEmpty l3 then\n            r <- freshTail r\n        else \n            go <- false\n    if notEmpty l1 || notEmpty l2 || notEmpty l3 then\n        badLengths()\n    setTail r []\n    res\n\n[<Name \"mapi\">]\nlet MapIndexed (f: int -> 'T1 -> 'T2) (x: list<'T1>) =\n    if List.isEmpty x then As x else\n    let res = freshEmptyList()\n    let mutable r = res\n    let mutable l = x\n    let mutable i = 0\n    let mutable go = true\n    while go do\n        setValue r (f i (unsafeHead l))\n        l <- unsafeTail l\n        if List.isEmpty l then \n            go <- false\n        else\n            r <- freshTail r\n            i <- i + 1\n    setTail r []\n    res\n\n[<Name \"mapi2\">]\nlet MapIndexed2 (f: int -> 'T1 -> 'T2 -> 'T3) (x1: list<'T1>) (x2: list<'T2>) =\n    let mutable go = notEmpty x1 && notEmpty x2\n    if not go then \n        if notEmpty x1 || notEmpty x2 then\n            badLengths()\n        else As x1\n    else\n    let res = freshEmptyList()\n    let mutable r = res\n    let mutable l1 = x1\n    let mutable l2 = x2\n    let mutable i = 0\n    while go do\n        setValue r (f i (unsafeHead l1) (unsafeHead l2))\n        l1 <- unsafeTail l1\n        l2 <- unsafeTail l2\n        if notEmpty l1 && notEmpty l2 then\n            r <- freshTail r\n            i <- i + 1\n        else \n            go <- false\n    if notEmpty l1 || notEmpty l2 then\n        badLengths()\n    setTail r []\n    res\n\n[<Name \"max\">]\nlet Max (l: list<_>) = Seq.reduce max l\n\n[<Name \"maxBy\">]\nlet MaxBy f (l: list<_>) =\n    Seq.reduce (fun x y -> if f x > f y then x else y) l\n\n[<Name \"min\">]\nlet Min (l: list<_>) = Seq.reduce min l\n\n[<Name \"minBy\">]\nlet MinBy f (l: list<_>) =\n    Seq.reduce (fun x y -> if f x < f y then x else y) l\n\n[<Inline>]\nlet Get (l: list<_>) ix = Seq.nth ix l\n\n[<Inline>]\nlet Item ix (l: list<_>) = Seq.nth ix l\n\n[<Name \"ofArray\">]\nlet OfArray<'T> (arr: 'T []) =\n    let mutable r = []\n    for i = arr.Length - 1 downto 0 do\n        r <- arr.[i] :: r\n    r\n\n[<Name \"ofSeq\">]\nlet OfSeq (s: seq<'T>) =\n    if s :? _ list then\n        As<'T list> s\n    elif s :? System.Array then\n        List.ofArray (As<'T[]> s)\n    else\n        use e = Enumerator.Get s\n        let mutable go = e.MoveNext()\n        if not go then [] else\n        let res = freshEmptyList()\n        let mutable r = res\n        while go do\n            setValue r e.Current\n            if e.MoveNext() then\n                r <- freshTail r\n            else    \n                go <- false\n        setTail r []\n        res\n\n[<Name \"partition\">]\nlet Partition p (l: list<_>) =\n    let (a, b) = Array.partition p (Array.ofList l)\n    (List.ofArray a, List.ofArray b)\n\n[<Name \"permute\">]\nlet Permute f (l: list<_>) =\n    List.ofArray (Array.permute f (Array.ofList l))\n\n[<Inline>]\nlet Pick f (l: list<_>) = Seq.pick f l\n\n[<Inline>]\nlet Reduce (f: 'T -> 'T -> 'T) (list: list<'T>) : 'T =\n    Seq.reduce f list\n\n[<Name \"reduceBack\">]\nlet ReduceBack f (l: list<_>) =\n    Array.reduceBack f (Array.ofList l)\n\n[<Name \"replicate\">]\nlet Replicate size value =\n    List.ofArray (Array.create size value)\n\n[<Name \"rev\">]\nlet Reverse (l: list<'T>) =\n    let mutable res = []\n    let mutable r = l\n    while notEmpty r do\n        res <- unsafeHead r :: res\n        r <- unsafeTail r\n    res\n\n[<Name \"scan\">]\nlet Scan<'T,'S> (f: 'S -> 'T -> 'S) (s: 'S) (l: list<'T>) : list<'S> =\n    List.ofSeq (Seq.scan f s l)\n\n[<Name \"scanBack\">]\nlet ScanBack f (l: list<_>) s =\n    List.ofArray (Array.scanBack f (Array.ofList l) s)\n\n[<Name \"sort\">]\nlet Sort (l: list<_>) =\n    let a = Array.ofList l\n    Array.sortInPlace a\n    List.ofArray a\n\n[<Name \"sortBy\">]\nlet SortBy f (l: list<_>) =\n    List.sortWith (fun x y -> compare (f x) (f y)) l\n\n[<Name \"sortByDescending\">]\nlet SortByDescending f (l: list<_>) =\n    List.sortWith (fun x y -> - compare (f x) (f y)) l\n\n[<Name \"sortDescending\">]\nlet SortDescending (l: list<_>) =\n    let a = Array.ofList l\n    ArraySortInPlaceByDescending id a\n    List.ofArray a\n\n[<Name \"sortWith\">]\nlet SortWith f (l: list<_>) =\n    let a = Array.ofList l\n    Array.sortInPlaceWith f a\n    List.ofArray a\n\n[<Inline>]\nlet inline Sum (l: list<'T>) : 'T = Seq.sum l\n\n[<Inline>]\nlet inline SumBy (f: 'T -> 'U) (l: list<'T>) : 'U = Seq.sumBy f l\n\n[<Name \"tail\">]\nlet Tail (l: list<'T>) = \n    match l with \n    | _ :: t -> t\n    | _ -> listEmpty()\n\n[<Inline>]\nlet ToArray (l: list<_>) = Array.ofList l\n\n[<Inline \"$x\">]\nlet ToSeq<'T> (x: list<'T>) : seq<'T> = x :> _\n\n[<Inline>]\nlet TryFind p (l: list<_>) = Seq.tryFind p l\n\n[<Inline>]\nlet TryFindIndex p (l: list<_>) = Seq.tryFindIndex p l\n\n[<Inline>]\nlet TryPick p (l: list<_>) = Seq.tryPick p l\n\n[<Name \"unzip\">]\nlet Unzip (l: list<_>) =\n    let x = System.Collections.Generic.Queue<_>()\n    let y = System.Collections.Generic.Queue<_>()\n    for (a, b) in l do\n        x.Enqueue a\n        y.Enqueue b\n    (List.ofArray (x.ToArray()), List.ofArray (y.ToArray()))\n\n[<Name \"unzip3\">]\nlet Unzip3 (l: list<_>) =\n    let x = System.Collections.Generic.Queue<_>()\n    let y = System.Collections.Generic.Queue<_>()\n    let z = System.Collections.Generic.Queue<_>()\n    for (a, b, c) in l do\n        x.Enqueue a\n        y.Enqueue b\n        z.Enqueue c\n    (\n        List.ofArray (x.ToArray()),\n        List.ofArray (y.ToArray()),\n        List.ofArray (z.ToArray())\n    )\n\n[<Name \"zip\">]\nlet Zip (l1: list<_>) (l2: list<_>) =\n    List.map2 (fun x y -> x, y) l1 l2\n\n[<Name \"zip3\">]\nlet Zip3 (l1: list<_>) (l2: list<_>) (l3: list<_>) =\n    Map3 (fun x y z -> (x, y, z)) l1 l2 l3\n\n[<Name \"chunkBySize\">]\nlet ChunkBySize size list =\n    SeqChunkBySize size (List.toSeq list)\n    |> Seq.toList\n    |> List.map Array.toList\n\n[<Name \"compareWith\">]\nlet CompareWith  (f: 'T -> 'T -> int) (l1: list<'T>) (l2: list<'T>) : int =\n    Seq.compareWith f (List.toSeq l1) (List.toSeq l2)\n\n[<Name \"countBy\">]\nlet CountBy (f: 'T -> 'K) (l: list<'T>) : list<'K * int> =\n    ArrayCountBy f (List.toArray l)\n    |> Array.toList\n\n[<Name \"distinct\">]\nlet Distinct<'T when 'T : equality> (l: list<'T>) : list<'T> =\n    Seq.distinct (List.toSeq l)\n    |> Seq.toList\n\n[<Name \"distinctBy\">]\nlet DistinctBy<'T,'K when 'K : equality>\n        (f: 'T -> 'K) (l: list<'T>) : list<'T> =\n    Seq.distinctBy f (List.toSeq l)\n    |> Seq.toList\n\n[<Name \"splitInto\">]\nlet SplitInto count (list: list<'T>) =\n    ArraySplitInto count (List.toArray list)\n    |> Array.toList\n    |> List.map Array.toList\n\n[<Name \"except\">]\nlet Except (itemsToExclude: seq<'T>) (l: list<'T>) =\n    SeqExcept itemsToExclude l\n    |> Seq.toList\n\n[<Name \"tryFindBack\">]\nlet TryFindBack ok (l: list<_>) =\n    ArrayTryFindBack ok (Array.ofList l)\n\n[<Name \"findBack\">]\nlet FindBack p (s: list<_>) =\n    match TryFindBack p s with\n    | Some x -> x\n    | None   -> failwith \"KeyNotFoundException\"\n\n[<Inline>]\nlet TryFindIndexBack ok (l: list<_>) =\n    ArrayTryFindIndexBack ok (Array.ofList l) \n\n[<Name \"findIndexBack\">]\nlet FindIndexBack p (s: list<_>) =\n    match TryFindIndexBack p s with\n    | Some x -> x\n    | None   -> failwith \"KeyNotFoundException\"\n\n[<Name \"groupBy\">]\nlet GroupBy (f: 'T -> 'K when 'K : equality)\n            (l: list<'T>) : list<'K * list<'T>> =\n    let arr = ArrayGroupBy f (List.toArray l)\n    arr |> mapInPlace (fun (k, s) -> (k, Array.toList s))\n    Array.toList (As arr)\n\n[<Name \"last\">]\nlet Last (list : list<'T>) : 'T =\n    if List.isEmpty list then\n        listEmpty()\n    let mutable r = list\n    let mutable t = unsafeTail r\n    while notEmpty t do\n        r <- t\n        t <- unsafeTail r\n    unsafeHead r\n\n[<Name \"contains\">]\nlet Contains (el: 'T) (x: list<'T>) =\n    let mutable c = false\n    let mutable l = x\n    while not c && notEmpty l do\n        c <- el = unsafeHead l\n        l <- unsafeTail l\n    c\n\n[<Name \"mapFold\">]\nlet MapFold<'T, 'S, 'R> (f: 'S -> 'T -> 'R * 'S) zero list =\n    ArrayMapFold f zero (List.toArray list)\n    |> (fun (x, y) ->\n        (Array.toList x, y)\n    )\n\n[<Name \"mapFoldBack\">]\nlet MapFoldBack<'T, 'S, 'R> f list zero =\n    ArrayMapFoldBack<'T, 'S, 'R> f (List.toArray list) zero\n    |> (fun (x, y) ->\n        (Array.toList x, y)\n    )\n\n[<Name \"pairwise\">]\nlet Pairwise (l: list<'T>) : list<'T * 'T> =\n    Seq.pairwise (List.toSeq l)\n    |> Seq.toList\n\n[<Name \"indexed\">]\nlet Indexed (list : list<'T>) : list<int * 'T> =\n    List.mapi (fun a b -> (a, b)) list\n\n[<Inline>]\nlet Singleton<'T> (x: 'T) =\n    [x]\n\n[<Inline>]\nlet Skip<'T> i (l : list<'T>) = ListSkip i l\n\n[<Inline>]\nlet SkipWhile<'T> (predicate : 'T -> bool) (list : list<'T>) : list<'T> =\n    ListSkipWhile predicate list\n\n[<Inline>]\nlet Take<'T> n (list: list<'T>) =\n    Seq.take n list |> List.ofSeq\n\n[<Inline>]\nlet TakeWhile<'T> (predicate : 'T -> bool) (list: list<'T>) =\n    Seq.takeWhile predicate list |> List.ofSeq\n\n[<Inline>]\nlet Truncate<'T> n (list: list<'T>) =\n    Seq.truncate n list |> List.ofSeq\n\n[<Name \"tryHead\">]\nlet TryHead<'T> (list: list<'T>) =\n    match list with\n    | head :: _ ->\n        Some head\n    | [] ->\n        None\n\n[<Inline>]\nlet TryItem<'T> n (list: list<'T>) =\n    SeqTryItem n list \n\n[<Inline>]\nlet TryLast<'T> (list: list<'T>) =\n    SeqTryLast list\n\n[<Name \"exactlyOne\">]\nlet ExactlyOne (list : 'T list) =\n    match list with\n    | head :: [] ->\n        head\n    | _ ->\n        failwith \"The input does not have precisely one element.\"\n\n[<Name \"unfold\">]\nlet Unfold<'T, 'S> (f: 'S -> option<'T * 'S>) (s: 'S) : list<'T> =\n    Seq.unfold f s\n    |> Seq.toList\n\n[<Inline>]\nlet Where (predicate : 'T -> bool) (s : 'T list) : 'T list =\n    Filter predicate s\n\n[<Name \"windowed\">]\nlet Windowed (windowSize: int) (s: 'T list) : list<list<'T>> =\n    Seq.windowed windowSize (List.toSeq s)\n    |> Seq.map List.ofArray |> Seq.toList\n\n[<Name \"splitAt\">]\nlet SplitAt (n: int) (list: 'T list) =\n    (Take n list, Skip n list)\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen WebSharper.JavaScript\n\n[<JavaScript>]\nmodule Nullable =\n    let get (x: obj) =\n        if x ==. null then failwith \"Nullable object must have a value.\" else x\n\n////    let getOrDefault<'T> (x: 'T) =\n//        if x ==. null then Unchecked.defaultof<'T> else x     \n\n    let getOrValue<'T> (x: 'T) (v: 'T)  =\n        if x ==. null then v else x     \n\n[<Proxy(typeof<System.Nullable<_>>)>]\ntype private NullableProxy<'T> =\n    \n    [<Inline \"null\">]\n    new () = {}\n\n    [<Inline \"$v\">]\n    new (v: 'T) = {}\n\n    member this.Value \n        with [<JavaScript; Inline>] get(): 'T = As<'T>(Nullable.get this)\n\n    member this.HasValue\n        with [<JavaScript; Inline>] get() = this !=. null\n\n//    [<Inline>]\n////    member this.GetValueOrDefault() : 'T = Nullable.getOrDefault (As<'T> this)\n\n    [<Inline>]\n    member this.GetValueOrDefault(v: 'T) : 'T = Nullable.getOrValue (As<'T> this) v\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.Name \"Operators\">]\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Core.Operators, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.OperatorsProxy\n\n#nowarn \"86\"\n\nopen WebSharper.JavaScript\n\nmodule M = WebSharper.Macro\n\n[<JavaScript>]\n[<Name \"range\">]\n[<Macro(typeof<M.Range>)>]\nlet ( .. ) (min: 'T) (max: 'T) : seq<'T> =\n    let count = 1 + As max - As min\n    if count <= 0 then Seq.empty\n    else Seq.init count (fun x -> As (x + As min))\n\n[<Name \"step\">]\nlet ( .. .. ) (min: 'T1) (step: 'T2) (max: 'T1) : seq<'T1> =\n    let s = sign (As<int> step)\n    Seq.initInfinite (fun k -> As<int> min + k * As<int> step)\n    |> Seq.takeWhile (fun k -> s * (As<int> max - As<int> k) >= 0)\n    |> As\n\n[<Inline \"$r[0]\">]\nlet ( ! ) (r: ref<'T>) = X<'T>\n\n[<Macro(typeof<M.Arith>)>]\nlet ( % ) (a: 'T1) (b: 'T2) = X<'T3>\n\n[<Inline \"$a & $b\">]\nlet ( &&& ) (a: 'T1) (b: 'T1) = X<'T1>\n\n[<Macro(typeof<M.Arith>)>]\nlet ( * ) (a: 'T1) (b: 'T2) = X<'T3>\n\n[<Inline \"Math.pow($a, $b)\">]\nlet ( ** ) (a: 'T1) (b: 'T2) = X<'T1>\n\n[<Inline \"Math.pow($a, $p)\">]\nlet PowInteger (a: 'T, p: int) = X<'T>\n\n[<Macro(typeof<M.Arith>)>]\nlet ( + ) (a: 'T1) (b: 'T2) = X<'T3>\n\n[<Macro(typeof<M.Arith>)>]\nlet ( - ) (a: 'T1) (b: 'T2) = X<'T3>\n\n[<Macro(typeof<M.Arith>)>]\nlet ( / ) (x: 'T1) (y: 'T2) = X<'T3>\n\n[<Inline \"void ($a[0] = $b)\">]\nlet ( := ) (a: ref<'T>) (b: 'T) = X<unit>\n\n[<Inline>]\nlet ( << ) (f: 'T1 -> 'T2) (g: 'T3 -> 'T1) : 'T3 -> 'T2 = \n    ()\n    fun x -> f (g x)\n\n[<Inline \"$a << $b\">]\nlet inline ( <<< ) (a: 'T) (b: int) = X<'T>\n\n[<Inline>]\nlet ( <| ) (f: 'T -> 'TR) (x: 'T) : 'TR = f x\n\n[<Inline>]\nlet ( <|| ) (f: 'T1 -> 'T2 -> 'TR) (x: 'T1, y: 'T2) : 'TR = f x y\n\n[<Inline>]\nlet ( <||| ) (f: 'T1 -> 'T2 -> 'T3 -> 'TR)\n             (x: 'T1, y: 'T2, z: 'T3) : 'TR = f x y z\n\n[<Macro(typeof<M.Comp>)>]\nlet ( = ) (a: 'T) (b: 'T) = X<bool>\n\n[<Macro(typeof<M.Comp>)>]\nlet ( <> ) (a: 'T) (b: 'T) =  X<bool>\n\n[<Macro(typeof<M.Comp>)>]\nlet ( < ) (a: 'T) (b: 'T) = X<bool>\n\n[<Macro(typeof<M.Comp>)>]\nlet ( > ) (a: 'T) (b: 'T) = X<bool>\n\n[<Macro(typeof<M.Comp>)>]\nlet ( <= ) (a: 'T) (b: 'T) = X<bool>\n\n[<Macro(typeof<M.Comp>)>]\nlet ( >= ) (a: 'T) (b: 'T) = X<bool>\n\n[<Inline>]\nlet ( >> ) (f: 'T1 -> 'T2) (g: 'T2 -> 'T3): 'T1->'T3 = \n    ()\n    fun x -> g (f x)\n\n[<Inline \"$a >> $b\">]\nlet inline ( >>> ) (a: 'T) (b: int) : 'T = a >>> b\n\n[<Inline>]\nlet ( @ ) a b = List.append a b\n\n[<Inline \"$a + $b\">]\nlet ( ^ ) (a: string) (b: string) : string = a + b\n\n[<Inline \"$a ^ $b\">]\nlet ( ^^^ ) (a: 'T) (b: 'T) = X<'T>\n\n[<Inline>]\nlet ( |> ) (x: 'T1) (f: 'T1 -> 'T2) : 'T2 = f x\n\n[<Inline>]\nlet ( ||> ) (x: 'T1, y: 'T2) (f: 'T1 -> 'T2 -> 'TR) : 'TR = f x y\n\n[<Inline \"$a | $b\">]\nlet ( ||| ) (a: 'T) (b: 'T) = X<'T>\n\n[<Inline>]\nlet ( |||> ) (x: 'T1, y: 'T2, z: 'T3)\n             (f: 'T1 -> 'T2 -> 'T3 -> 'TR) : 'TR = f x y z\n\n[<Inline \"+ $x\">]\nlet ( ~+ ) (x: 'T) = X<'T>\n\n[<Inline \"- $x\">]\nlet ( ~- ) (x: 'T) = X<'T>\n\n[<Inline \"~ $x\">]\nlet ( ~~~ ) (x: 'T) = X<'T>\n\n[<Inline \"Math.abs($x)\">]\nlet Abs (x: 'T) = X<'T>\n\n[<Inline \"Math.acos($x)\">]\nlet Acos (x: 'T) = X<'T>\n\n[<Inline \"Math.asin($x)\">]\nlet Asin (x: 'T) = X<'T>\n\n[<Inline \"Math.atan($x)\">]\nlet Atan (x: 'T) = X<'T>\n\n[<Inline \"Math.atan2($x, $y)\">]\nlet Atan2 (x: 'T1) (y: 'T1) = X<'T2>\n\n[<Inline \"$x\">]\nlet Box (x: 'T) = X<obj>\n\n[<Inline \"Math.ceil($x)\">]\nlet Ceiling (x: 'T) = X<'T>\n\n[<Macro(typeof<M.Char>)>]\nlet ToChar (x: 'T) = X<char>\n\n[<Inline>]\nlet Compare<'T> (a: 'T) (b: 'T) = Unchecked.compare a b\n\n[<Inline \"Math.cos($x)\">]\nlet Cos (x: 'T) = X<'T>\n\n[<Inline \"(Math.exp($x)+Math.exp(-$x))/2\">]\nlet Cosh<'T> (x: 'T) = X<'T>\n\n[<Inline \"void ($x[0]--)\">]\nlet Decrement (x: ref<int>) = ()\n\n[<Inline>]\nlet DefaultArg x d =\n    match x with\n    | Some x -> x\n    | None   -> d\n\n[<Inline \"$x\">]\nlet Enum<'T when 'T : enum<int>> (x: 'T) = X<'T>\n\n[<Macro(typeof<M.Conversion>)>]\nlet ToDouble (x: 'T) = X<double>\n\n[<Inline \"Math.exp($x)\">]\nlet inline Exp (x: 'T) = X<'T>\n\nlet FailWith (msg: string) : 'T = raise (exn msg)\n\n[<Macro(typeof<M.Conversion>)>]\nlet ToFloat (x: 'T) = X<float>\n\n[<Inline \"Math.floor($x)\">]\nlet Floor (x: 'T) = X<'T>\n\n[<Inline \"$x[0]\">]\nlet Fst (x: System.Tuple<'T1,'T2>) = X<'T1>\n\n[<Inline>]\nlet Hash<'T when 'T : equality> (x: 'T) = Unchecked.hash x\n\n[<Inline \"$x\">]\nlet Identity (x: 'T) = X<'T>\n\n[<Inline \"void $x\">]\nlet Ignore (x: 'T) = X<unit>\n\n[<Inline \"void ($x[0]++)\">]\nlet Increment (x: ref<int>) = ()\n\n[<Inline \"Infinity\">]\nlet Infinity = Unchecked.defaultof<double>\n\nlet InvalidOp (msg: string) : 'T = raise (System.InvalidOperationException(msg))\n\nlet InvalidArg (arg: string) (msg: string) : 'T = raise (System.ArgumentException(arg, msg))\n\n[<Macro(typeof<M.Conversion>)>]\nlet ToInt (x: 'T) = X<int>\n\n[<Macro(typeof<M.Conversion>)>]\nlet ToSingle (x: 'T) = X<single>\n\n[<Macro(typeof<M.Conversion>)>]\nlet ToInt32 (x: 'T) = X<int32>\n\n[<Inline \"$x\">]\nlet ToEnum<'T> (x: int) = X<'T>\n\n[<Macro(typeof<M.Conversion>)>]\nlet ToInt64 (x: 'T) = X<int64>\n\n[<Inline \"Math.log($x)\">]\nlet Log (x: 'T) = X<'T>\n\n[<Inline \"Math.log($x)/Math.log(10)\">]\nlet Log10 (x: 'T) = X<'T>\n\n[<Inline>]\nlet Max<'T when 'T : comparison> (a: 'T) (b: 'T) =\n    if a > b then a else b\n\n[<Inline>]\nlet Min<'T when 'T : comparison> (a: 'T) (b: 'T) =\n    if a < b then a else b\n\n[<Inline \"Infinity\">]\nlet InfinitySingle = single infinity\n\n[<Inline \"NaN\">]\nlet NaNSingle = single nan\n\n[<Inline \"NaN\">]\nlet NaN = nan\n\n[<Inline \"!$x\">]\nlet Not (x: bool) = X<bool>\n\nlet Pown<'T> (a: 'T) (n: int) =\n    let a = box a :?> double\n    let rec p n =\n        match n with\n        | 1 ->\n            a\n        | n when n % 2 = 0 ->\n            let b = p (n / 2)\n            b * b\n        | n ->\n            a * (p (n - 1))\n    p n\n\n[<Inline \"throw $e\">]\nlet Raise (e: exn) = X<'T>\n\n[<Inline \"[$x]\">]\nlet Ref (x: 'T) = X<ref<'T>>\n\n[<Inline \"Math.round($x)\">]\nlet Round (x: 'T) = X<'T>\n\n[<Inline \"$x\">]\nlet CreateSequence (x: seq<'T>) = X<seq<'T>>\n\nlet Sign<'T> (x: 'T) =\n    match As<int> x with\n    | 0            -> 0\n    | n when n < 0 -> -1\n    | _            -> 1\n\n[<Inline \"Math.sin($x)\">]\nlet Sin (x: 'T) = X<'T>\n\n[<Inline \"(Math.exp($x)-Math.exp(-$x))/2\">]\nlet Sinh (x: 'T) = x\n\n[<Inline \"$x[1]\">]\nlet Snd (x: System.Tuple<'T1,'T2>) = X<'T2>\n\n[<Inline \"Math.sqrt($x)\">]\nlet Sqrt (x: 'T1) = X<'T2>\n\n[<Macro(typeof<M.String>)>]\nlet ToString (x: 'T) = X<string>\n\n[<Inline \"Math.tan($x)\">]\nlet inline Tan (x: 'T) = X<'T>\n\n[<Inline \"(Math.exp(2*$x)-1)/(Math.exp(2*$x)+1)\">]\nlet Tanh (x: 'T) = X<'T>\n\nlet inline Truncate<'T> (x: 'T) =\n    if x <. 0 then Ceiling x else Floor x\n\n[<Inline \"$x\">]\nlet Unbox (x: obj) = X<'T>\n\n[<Inline \"$x == null\">]\nlet IsNull (x: 'T) = X<bool>\n\n[<Inline>]\nlet Using t f =\n    try f t finally (t :> System.IDisposable).Dispose()\n\n[<Name \"KeyValue\">]\nlet KeyValuePattern (kvp: System.Collections.Generic.KeyValuePair<_,_>) =\n    (kvp.Key, kvp.Value)\n\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.Name \"Slice\">]\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Core.Operators+OperatorIntrinsics, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.OperatorIntrinsicsProxy \n\nopen WebSharper.JavaScript\n\n[<Inline \"$s.slice($st,$e)\">]\nlet Slice (s: 'T) (st: int) (e: int) = X<'T>\n\n[<Inline \"$s.slice($st)\">]\nlet SliceStart (s: 'T) (st: int) = X<'T>\n\n[<Name \"string\">]\nlet GetStringSlice (source: string) (start: int option) (finish: int option) =\n    match start, finish with\n    | Some s, Some f -> Slice source s (f + 1)\n    | Some s, None -> SliceStart source s\n    | None, Some f -> Slice source 0 (f + 1)\n    | _ -> \"\"\n\n[<Name \"array\">]\nlet GetArraySlice<'T> (source: 'T[]) (start: int option) (finish: int option) =\n    match start, finish with\n    | Some s, Some f -> Slice source s (f + 1)\n    | Some s, None -> SliceStart source s\n    | None, Some f -> Slice source 0 (f + 1)\n    | _ -> [||]\n\nmodule F = WebSharper.IntrinsicFunctionProxy\n\n[<Name \"setArray\">]\nlet SetArraySlice (dst: _[]) start finish (src:_[]) = \n    let start  = (match start with None -> 0 | Some n -> n) \n    let finish = (match finish with None -> Array.length dst - 1 | Some n -> n) \n    F.SetArraySub dst start (finish - start + 1) src\n\n[<Name \"array2D\">]\nlet GetArraySlice2D (arr: _[,]) start1 finish1 start2 finish2 = \n    let start1  = (match start1 with None -> 0 | Some n -> n) \n    let start2  = (match start2 with None -> 0 | Some n -> n) \n    let finish1 = (match finish1 with None -> F.GetArray2DLength1 arr - 1 | Some n -> n) \n    let finish2 = (match finish2 with None -> F.GetArray2DLength2 arr - 1 | Some n -> n) \n    let len1 = (finish1 - start1 + 1)\n    let len2 = (finish2 - start2 + 1)\n    F.GetArray2DSub arr start1 start2 len1 len2\n\n[<Name \"array2Dfix1\">]\nlet GetArraySlice2DFixed1 (arr: _[,]) fixed1 start2 finish2 = \n    let start2  = (match start2 with None -> 0 | Some n -> n) \n    let finish2 = (match finish2 with None -> F.GetArray2DLength2 arr - 1 | Some n -> n) \n    let len2 = (finish2 - start2 + 1)\n    let dst = JavaScript.Array(len2)\n    for j = 0 to len2 - 1 do \n        F.SetArray dst.Self j (F.GetArray2D arr fixed1 (start2+j))\n    dst.Self\n\n[<Name \"array2Dfix2\">]\nlet GetArraySlice2DFixed2 (arr: _[,]) start1 finish1 fixed2 = \n    let start1  = (match start1 with None -> 0 | Some n -> n) \n    let finish1 = (match finish1 with None -> F.GetArray2DLength1 arr - 1 | Some n -> n) \n    let len1 = (finish1 - start1 + 1)\n    let dst = JavaScript.Array(len1)\n    for i = 0 to len1 - 1 do \n        F.SetArray dst.Self i (F.GetArray2D arr (start1+i) fixed2)\n    dst.Self\n\n[<Name \"setArray2Dfix1\">]\nlet SetArraySlice2DFixed1 (dst: _[,]) fixed1 start2 finish2 (src:_[]) = \n    let start2  = (match start2 with None -> 0 | Some n -> n) \n    let finish2 = (match finish2 with None -> F.GetArray2DLength2 dst - 1 | Some n -> n) \n    let len2 = (finish2 - start2 + 1)\n    for j = 0 to len2 - 1 do\n        F.SetArray2D dst fixed1 (start2+j) (F.GetArray src j)\n\n[<Name \"setArray2Dfix2\">]\nlet SetArraySlice2DFixed2 (dst: _[,]) start1 finish1 fixed2 (src:_[]) = \n    let start1  = (match start1 with None -> 0 | Some n -> n) \n    let finish1 = (match finish1 with None -> F.GetArray2DLength1 dst - 1 | Some n -> n) \n    let len1 = (finish1 - start1 + 1)\n    for i = 0 to len1 - 1 do\n        F.SetArray2D dst (start1+i) fixed2 (F.GetArray src i)\n\n[<Name \"setArray2D\">]\nlet SetArraySlice2D (dst: _[,]) start1 finish1 start2 finish2 (src:_[,]) = \n    let start1  = (match start1 with None -> 0 | Some n -> n) \n    let start2  = (match start2 with None -> 0 | Some n -> n) \n    let finish1 = (match finish1 with None -> F.GetArray2DLength1 dst - 1 | Some n -> n) \n    let finish2 = (match finish2 with None -> F.GetArray2DLength2 dst - 1 | Some n -> n) \n    F.SetArray2DSub dst start1 start2 (finish1 - start1 + 1) (finish2 - start2 + 1) src\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.NameAttribute \"Option\">]\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Core.OptionModule, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.OptionModuleProxy\n\nopen WebSharper.JavaScript\n\n[<Inline>]\nlet Bind f x =\n    match x with\n    | Some x -> f x\n    | None   -> None\n\n[<Inline>]\nlet Contains v o =\n    match o with\n    | Some x -> x = v\n    | None -> false\n\n[<Inline \"$x ? 1 : 0\">]\nlet Count (x: option<_>) = X<int>\n\n[<Inline>]\nlet DefaultValue v o =\n    match o with\n    | Some x -> x \n    | None -> v\n\n[<Inline>]\nlet DefaultWith f o =\n    match o with\n    | Some x -> x \n    | None -> f()\n\n[<Inline>]\nlet Exists p x =\n    match x with\n    | Some x -> p x\n    | None   -> false\n\n[<Name \"filter\">]\nlet Filter f o =\n    match o with\n    | Some x when f x -> o\n    | _ -> None\n\n[<Inline>]\nlet Flatten o =\n    match o with\n    | Some x -> x\n    | None -> None\n\n[<Name \"fold\">]\nlet Fold<'T,'S> (f: 'S -> 'T -> 'S) (s: 'S) (x: option<'T>) : 'S =\n    match x with\n    | Some x -> f s x\n    | None   -> s\n\n[<Name \"foldBack\">]\nlet FoldBack f x s =\n    match x with\n    | Some x -> f x s\n    | None   -> s\n\n[<Inline>]\nlet ForAll p x =\n    match x with\n    | Some x -> p x\n    | None   -> true\n\n[<Inline \"$x.$0\"; Pure>]\nlet GetValue (x: option<'T>) = X<'T>\n\n[<Inline \"$x==null\">]\nlet IsNone (x: option<'T>) = false\n\n[<Inline \"$x!=null\">]\nlet IsSome (x: option<'T>) =  false\n\n[<Inline>]\nlet Iterate p x =\n    match x with\n    | Some x -> p x\n    | None   -> ()\n\n[<Inline>]\nlet Map f x =\n    match x with\n    | Some x -> Some (f x)\n    | None -> None\n\n[<Inline>]\nlet Map2 f x y =\n    match x, y with\n    | Some x, Some y -> Some (f x y)\n    | _ -> None\n\n[<Inline>]\nlet Map3 f x y z =\n    match x, y, z with\n    | Some x, Some y, Some z -> Some (f x y z)\n    | _ -> None\n\n[<Name \"ofNullable\">]\nlet OfNullable (o: System.Nullable<'T>) =\n    if o ==. null then None else Some o.Value                   \n\n[<Name \"ofObj\">]\nlet OfObj o = \n    if o ==. null then None else Some o\n\n[<Inline>]\nlet OrElse v o =\n    match o with\n    | Some x -> o \n    | None -> v\n\n[<Inline>]\nlet OrElseWith f o =\n    match o with\n    | Some x -> o \n    | None -> f()\n\n[<Name \"toArray\">]\nlet ToArray x =\n    match x with\n    | Some x -> [|x|]\n    | None   -> [||]\n\n[<Name \"toList\">]\nlet ToList x =\n    match x with\n    | Some x -> [x]\n    | None   -> []\n\n[<Name \"toNullable\">]\nlet ToNullable o =\n    match o with\n    | Some v -> System.Nullable(v)\n    | _ -> System.Nullable()\n\n[<Name \"toObj\">]\nlet ToObj o = \n    match o with\n    | Some v -> v\n    | None -> null\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.Name \"Queue\">]\nmodule private WebSharper.QueueProxy\n\nopen WebSharper.JavaScript\n\n[<Inline \"$arr.splice($offset,$len)\">]\nlet splice (arr: obj) (offset: int) (len: int) = X<unit>\n\n[<JavaScript>]\nlet Clear (a: obj) =\n    splice a 0 (a :?> obj []).Length\n\n[<JavaScript>]\nlet Contains (a: obj) (el: 'T) =\n    Seq.exists ((=) el) (a :?> seq<'T>)\n\n[<JavaScript>]\nlet CopyTo (a: obj) (array: 'T[]) (index: int) =\n    Array.blit (a :?> 'T []) 0 array index (a :?> 'T[]).Length\n\n[<Proxy(typeof<System.Collections.Generic.Queue<_>>)>]\n[<WebSharper.Name \"WebSharper.Queue\">]\ntype private QueueProxy<'T when 'T : equality>\n\n    [<Inline \"$data\">] private (data: 'T []) =\n\n    [<Inline \"[]\">]\n    private new () = QueueProxy [||]\n\n    [<Inline>]\n    private new (s: seq<'T>) = QueueProxy (Array.ofSeq s)\n\n    member this.Count with [<Inline \"$this.length\">] get () = X<int>\n\n    [<Inline>]\n    member this.Clear() = Clear this\n\n    [<Inline>]\n    member this.Contains(x: 'T) = Contains this x\n\n    [<Inline>]\n    member this.CopyTo(array: 'T [], index: int) = CopyTo this array index\n\n    [<Inline \"$this[0]\">]\n    member this.Peek() = X<'T>\n\n    [<Inline \"$this.shift()\">]\n    member this.Dequeue() = X<'T>\n\n    [<Inline \"$this.push($x)\">]\n    member this.Enqueue(x: 'T) = X<unit>\n\n    [<Inline \"$this.slice(0)\">]\n    member this.ToArray() = data\n\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen WebSharper.JavaScript\n\n[<AutoOpen>]\nmodule RandomHelpers =\n    [<Inline \"Math.floor(Math.random() * 2147483648)\">]\n    let Next() = X<int>\n    \n    [<Inline \"Math.floor(Math.random() * $maxValue)\">]\n    let NextMax (maxValue: int) = X<int>\n\n[<Name \"Random\">]\n[<Proxy(typeof<System.Random>)>]\ntype internal RandomProxy() =\n    member this.Next() = Next()\n\n    member this.Next maxValue =\n        if maxValue < 0 then\n            failwith \"'maxValue' must be greater than zero.\"\n        else NextMax maxValue\n\n    member this.Next (minValue: int, maxValue: int) =\n        if minValue > maxValue then\n            failwith \"'minValue' cannot be greater than maxValue.\"\n        else minValue + NextMax (maxValue - minValue)\n\n    member this.NextBytes (buffer: byte[]) =\n        for i = 0 to buffer.Length - 1 do\n            buffer.[i] <- As (NextMax 256)\n\n    [<Inline \"Math.random()\">]\n    member this.NextDouble() = X<float>\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.NameAttribute \"Result\">]\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Core.ResultModule, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.ResultModuleProxy\n    \nlet Bind f r =\n    match r with\n    | Ok x -> f x\n    | Error e -> Error e\n        \nlet Map f r =\n    match r with\n    | Ok x -> Ok (f x)\n    | Error e -> Error e\n        \nlet MapError f r =\n    match r with\n    | Ok x -> Ok x\n    | Error e -> Error (f e)    \n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Core.CompilerServices.RuntimeHelpers, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.RuntimeHelpersProxy\n\n#nowarn \"40\"\n\nopen WebSharper.JavaScript\n\ntype IE<'T> = System.Collections.Generic.IEnumerator<'T>\n\n[<Inline>]\nlet safeDispose (x: System.IDisposable) =\n    if x <> null then x.Dispose()\n\n[<Name \"WebSharper.Seq.enumFinally\">]\nlet EnumerateThenFinally (s: seq<'T>) (f: unit -> unit) : seq<'T> =\n    Enumerable.Of <| fun () ->\n        let enum = try Enumerator.Get s with e -> f(); raise e\n        Enumerator.NewDisposing () (fun _ -> enum.Dispose(); f()) <| fun e ->\n            if enum.MoveNext() then\n                e.Current <- enum.Current\n                true\n            else\n                false\n\n[<Name \"WebSharper.Seq.enumUsing\">]\nlet EnumerateUsing<'T1,'T2,'T3 when 'T1 :> System.IDisposable\n                                and 'T2 :> seq<'T3>>\n        (x: 'T1) (f: 'T1 -> 'T2) : seq<'T3> =\n\n    Enumerable.Of <| fun () ->\n        let enum = try Enumerator.Get (f x) with e -> x.Dispose(); raise e\n        Enumerator.NewDisposing () (fun _ -> enum.Dispose(); x.Dispose()) <| fun e ->\n            if enum.MoveNext() then\n                e.Current <- enum.Current\n                true\n            else\n                false\n\n[<Name \"WebSharper.Seq.enumWhile\">]\nlet EnumerateWhile (f: unit -> bool) (s: seq<'T>) : seq<'T> =\n    Enumerable.Of (fun () ->\n        let rec next (en: Enumerator.T<IE<_>,'T>) =\n            match en.State with\n            | null ->\n                if f () then\n                    en.State <- Enumerator.Get s\n                    next en\n                else\n                    false\n            | e ->\n                if e.MoveNext() then\n                    en.Current <- e.Current\n                    true\n                else\n                    e.Dispose()\n                    en.State <- null\n                    next en\n        Enumerator.NewDisposing null (fun en -> safeDispose en.State) next)\n\n[<Name \"WebSharper.Control.createEvent\">]\nlet CreateEvent<'D, 'A when 'D : delegate<'A, unit> and 'D :> System.Delegate> \n        (add: 'D -> unit) \n        (remove: 'D -> unit)\n        (create: (obj -> 'A -> unit) -> 'D) : IEvent<'D, 'A> =\n    { new IEvent<'D, 'A> with\n        member this.AddHandler h = add h\n        member this.RemoveHandler h = remove h\n        member this.Subscribe (r: System.IObserver<'A>) =     \n            let h = create (fun _ args -> r.OnNext(args))\n            add h\n            { new System.IDisposable with member this.Dispose() = remove h }\n    }\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.Name \"Seq\">]\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Collections.SeqModule, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.SeqModuleProxy\n\nopen WebSharper.JavaScript\nopen WebSharper.CollectionInternals\n\n[<Inline>]\nlet safeDispose (x: System.IDisposable) =\n    if x <> null then x.Dispose()\n\n[<Name \"allPairs\">]\nlet AllPairs (source1: seq<_>) (source2: seq<_>) =\n    let cached = Seq.cache source2\n    source1 |> Seq.collect (fun x -> cached |> Seq.map (fun y -> x,y))\n\n[<Name \"append\">]\nlet Append (s1: seq<'T>) (s2: seq<'T>) : seq<'T> =\n    Enumerable.Of (fun () ->\n        let e1 = Enumerator.Get s1\n        let first = ref true\n        Enumerator.NewDisposing e1 (fun x -> safeDispose x.State) (fun x ->\n            if x.State.MoveNext() then\n                x.Current <- x.State.Current\n                true\n            else \n                safeDispose x.State\n                x.State <- null\n                if !first then\n                    first := false\n                    x.State <- Enumerator.Get s2\n                    if x.State.MoveNext() then\n                        x.Current <- x.State.Current\n                        true\n                    else\n                        x.State.Dispose()\n                        x.State <- null\n                        false\n                else \n                    false)) \n\n[<Name \"average\">]\nlet Average<'T> (s: seq<'T>) : 'T =\n    let (count, sum) =\n        Seq.fold\n            (fun (n, s) x -> (n + 1, s + As<float> x))\n            (0, 0.)\n            s\n    if count = 0 then\n        invalidArg \"source\" \"The input sequence was empty.\"\n    else\n        As<'T> (sum / As<float> count)\n\n[<Name \"averageBy\">]\nlet AverageBy<'T,'U> (f: 'T -> 'U) (s: seq<'T>) : 'U =\n    let (count, sum) =\n        Seq.fold\n            (fun (n, s) x -> (n + 1, s + As<float> (f x)))\n            (0, 0.)\n            s\n    if count = 0 then\n        invalidArg \"source\" \"The input sequence was empty.\"\n    else\n        As<'U> (sum / As<float> count)\n\n[<Name \"cache\">]\nlet Cache<'T> (s: seq<'T>) : seq<'T> =\n    let cache = JavaScript.Array<'T>()\n    let o  = ref (Enumerator.Get s)\n    Enumerable.Of <| fun () ->\n        let next (e: Enumerator.T<_,_>) =\n            if e.State < cache.Length then\n                e.Current <- cache.[e.State]\n                e.State   <- e.State + 1\n                true\n            else\n                let en = !o\n                if en = null then false\n                elif en.MoveNext() then\n                    e.State   <- e.State + 1\n                    e.Current <- en.Current\n                    cache.Push(e.Current) |> ignore\n                    true\n                else\n                    en.Dispose()\n                    o := null\n                    false\n        Enumerator.New 0 next\n\n/// IEnumerable is not supported.\n[<Inline \"$i\">]\nlet Cast<'T> (i: System.Collections.IEnumerable) = X<seq<'T>>\n\n[<Inline>]\nlet Contains (el: 'T) (s: seq<'T>) =\n    SeqContains el s\n\n[<Name \"choose\">]\nlet Choose (f: 'T -> option<'U>) (s: seq<'T>) : seq<'U> =\n    s\n    |> Seq.collect (fun x ->\n        match f x with\n        | Some v -> [v]\n        | None   -> [])\n\n[<Inline>]\nlet ChunkBySize (size: int) (s: seq<'T>) = SeqChunkBySize size s\n\n[<Name \"collect\">]\nlet Collect f s = Seq.concat (Seq.map f s)\n\n[<Name \"compareWith\">]\nlet CompareWith  (f: 'T -> 'T -> int) (s1: seq<'T>) (s2: seq<'T>) : int =\n    use e1 = Enumerator.Get s1\n    use e2 = Enumerator.Get s2\n    let mutable r = 0\n    let mutable loop = true\n    while loop && r = 0 do\n        match e1.MoveNext(), e2.MoveNext() with\n        | true, false ->\n            r <- 1\n        | false, true ->\n            r <- -1\n        | false, false ->\n            loop <- false\n        | true, true ->\n            r <- f e1.Current e2.Current\n    r\n\n[<Name \"concat\">]\nlet Concat (ss: seq<#seq<'T>>) : seq<'T> =\n    Enumerable.Of (fun () ->\n        let outerE = Enumerator.Get ss\n        let rec next (st: Enumerator.T<Enumerator.IE<'T>,'T>) =\n            match st.State with\n            | null ->\n                if outerE.MoveNext() then\n                    st.State <- Enumerator.Get outerE.Current\n                    next st\n                else\n                    outerE.Dispose()\n                    false\n            | innerE ->\n                if innerE.MoveNext() then\n                    st.Current <- innerE.Current\n                    true\n                else\n                    (st :> System.IDisposable).Dispose()\n                    st.State <- null\n                    next st\n        Enumerator.NewDisposing null (fun st -> \n            safeDispose st.State \n            safeDispose outerE) \n            next)\n\n[<Name \"countBy\">]\nlet CountBy (f: 'T -> 'K) (s: seq<'T>) : seq<'K * int> =\n    Seq.delay <| fun () ->\n        ArrayCountBy f (Array.ofSeq s) |> Seq.ofArray\n\n[<Name \"delay\">]\nlet Delay<'T> (f: unit -> seq<'T>) : seq<'T> =\n    Enumerable.Of (fun () -> Enumerator.Get(f()))\n\n[<Name \"distinct\">]\nlet Distinct<'T when 'T : equality> (s: seq<'T>) : seq<'T> =\n    Seq.distinctBy id s\n\n[<Name \"distinctBy\">]\nlet DistinctBy<'T,'K when 'K : equality>\n        (f: 'T -> 'K) (s: seq<'T>) : seq<'T> =\n    Enumerable.Of <| fun () ->\n        let o  = Enumerator.Get s\n        let seen = System.Collections.Generic.HashSet<'K>()\n        Enumerator.NewDisposing () (fun _ -> o.Dispose()) <| fun e ->\n            if o.MoveNext() then\n                let mutable cur = o.Current\n                let mutable has = seen.Add(f cur)\n                while not has && o.MoveNext() do\n                    cur <- o.Current\n                    has <- seen.Add(f cur)\n                if has then\n                    e.Current <- cur\n                    true\n                else\n                    false\n            else\n                false\n\n[<Name \"splitInto\">]\nlet SplitInto count (s: seq<'T>) =\n    if count <= 0 then failwith \"Count must be positive\"\n    Seq.delay (fun () -> ArraySplitInto count (Array.ofSeq s) |> Seq.ofArray)   \n\n[<Inline>]\nlet Empty<'T> : seq<'T> = As [||]\n\n[<Name \"exactlyOne\">]\nlet ExactlyOne<'T> (s: seq<'T>) =\n    use e = Enumerator.Get s\n    if e.MoveNext() then\n        let x = e.Current\n        if e.MoveNext() then\n            invalidOp \"Sequence contains more than one element\"\n        else x\n    else invalidOp \"Sequence contains no elements\"\n\n[<Inline>]\nlet Except (itemsToExclude: seq<'T>) (s: seq<'T>) =\n    SeqExcept itemsToExclude s\n\n[<Name \"exists\">]\nlet Exists p (s: seq<_>) =\n    use e = Enumerator.Get s\n    let mutable r = false\n    while not r && e.MoveNext() do\n        r <- p e.Current\n    r\n\n[<Name \"exists2\">]\nlet Exists2 p (s1: seq<_>) (s2: seq<_>) =\n    use e1 = Enumerator.Get s1\n    use e2 = Enumerator.Get s2\n    let mutable r = false\n    while not r && e1.MoveNext() && e2.MoveNext() do\n        r <- p e1.Current e2.Current\n    r\n\n[<Name \"filter\">]\nlet Filter (f: 'T -> bool) (s: seq<'T>) =\n    Enumerable.Of <| fun () ->\n        let o = Enumerator.Get s\n        Enumerator.NewDisposing () (fun _ -> o.Dispose()) <| fun e ->\n            let mutable loop = o.MoveNext()\n            let mutable c    = o.Current\n            let mutable res  = false\n            while loop do\n                if f c then\n                    e.Current <- c\n                    res       <- true\n                    loop      <- false\n                else\n                    if o.MoveNext() then\n                        c <- o.Current\n                    else\n                        loop <- false\n            res\n\n[<Name \"find\">]\nlet Find p (s: seq<_>) =\n    match Seq.tryFind p s with\n    | Some x -> x\n    | None   -> failwith \"KeyNotFoundException\"\n\n[<Name \"findIndex\">]\nlet FindIndex p (s: seq<_>) =\n    match Seq.tryFindIndex p s with\n    | Some x -> x\n    | None   -> failwith \"KeyNotFoundException\"\n\n[<Name \"fold\">]\nlet Fold<'T,'S> (f: 'S -> 'T -> 'S) (x: 'S) (s: seq<'T>) : 'S =\n    let mutable r = x\n    use e = Enumerator.Get s\n    while e.MoveNext() do\n        r <- f r e.Current\n    r\n\n[<Name \"forall\">]\nlet ForAll p s =\n    not (Seq.exists (fun x -> not (p x)) s)\n\n[<Name \"forall2\">]\nlet ForAll2 p s1 s2 =\n    not (Seq.exists2 (fun x y -> not (p x y)) s1 s2)\n\n[<Name \"groupBy\">]\nlet GroupBy (f: 'T -> 'K when 'K : equality) (s: seq<'T>) : seq<'K * seq<'T>> =\n    Seq.delay <| fun () ->\n        ArrayGroupBy f (Array.ofSeq s) |> As\n\n[<Name \"head\">]\nlet Head (s: seq<'T>) : 'T =\n    use e = Enumerator.Get s\n    if e.MoveNext() then e.Current else InsufficientElements()\n\n[<Name \"init\">]\nlet Initialize (n: int) (f: int -> 'T) : seq<'T> =\n    Seq.take n (Seq.initInfinite f)\n\n[<Name \"initInfinite\">]\nlet InitializeInfinite (f: int -> 'T) : seq<'T> =\n    Enumerable.Of <| fun () ->\n        Enumerator.New 0 <| fun e ->\n            e.Current <- f e.State\n            e.State   <- e.State + 1\n            true\n\n[<Name \"isEmpty\">]\nlet IsEmpty (s: seq<'T>) : bool =\n    use e = Enumerator.Get s\n    not (e.MoveNext())\n\n[<Name \"iter\">]\nlet Iterate p (s: seq<_>) =\n    use e = Enumerator.Get s\n    while e.MoveNext() do\n        p e.Current\n\n[<Name \"iter2\">]\nlet Iterate2 p (s1: seq<_>) (s2: seq<_>) =\n    use e1 = Enumerator.Get s1\n    use e2 = Enumerator.Get s2\n    while e1.MoveNext() && e2.MoveNext() do\n        p e1.Current e2.Current\n\n[<Name \"iteri\">]\nlet IterateIndexed p (s: seq<_>) =\n    let mutable i = 0\n    use e = Enumerator.Get s\n    while e.MoveNext() do\n        p i e.Current\n        i <- i + 1\n\n[<Inline>]\nlet Last (s: seq<_>) =\n    SeqLast s\n\n[<Name \"length\">]\nlet Length (s: seq<_>) =\n    let mutable i = 0\n    use e = Enumerator.Get s\n    while e.MoveNext() do\n        i <- i + 1\n    i\n\n[<Name \"map\">]\nlet Map (f: 'T -> 'U) (s: seq<'T>) : seq<'U> =\n    Enumerable.Of <| fun () ->\n        let en = Enumerator.Get s\n        Enumerator.NewDisposing () (fun _ -> en.Dispose()) <| fun e ->\n            if en.MoveNext() then\n                e.Current <- f en.Current\n                true\n            else\n                false\n\n[<Name \"mapi\">]\nlet MapIndexed (f: int -> 'T -> 'U) (s: seq<'T>) : seq<'U> =\n    Seq.map2 f (Seq.initInfinite id) s\n\n[<Name \"map2\">]\nlet Map2 (f: 'T -> 'U -> 'V) (s1: seq<'T>) (s2: seq<'U>) : seq<'V> =\n    Enumerable.Of <| fun () ->\n        let e1 = Enumerator.Get s1\n        let e2 = Enumerator.Get s2\n        Enumerator.NewDisposing () (fun _ -> e1.Dispose(); e2.Dispose()) <| fun e ->\n            if e1.MoveNext() && e2.MoveNext() then\n                e.Current <- f e1.Current e2.Current\n                true\n            else\n                false\n\n[<Name \"maxBy\">]\nlet MaxBy (f: 'T -> 'U) (s: seq<'T>) : 'T =\n    Seq.reduce (fun x y -> if f x >= f y then x else y) s\n\n[<Name \"minBy\">]\nlet MinBy (f: 'T -> 'U) (s: seq<'T>) : 'T =\n    Seq.reduce (fun x y -> if f x <= f y then x else y) s\n\n[<Name \"max\">]\nlet Max (s: seq<'T>) : 'T =\n    Seq.reduce (fun x y -> if x >= y then x else y) s\n\n[<Name \"min\">]\nlet Min (s: seq<'T>) : 'T =\n    Seq.reduce (fun x y -> if x <= y then x else y) s\n\n[<Name \"nth\">]\nlet Get index (s: seq<'T>) =\n    if index < 0 then\n        failwith \"negative index requested\"\n    let mutable pos = -1\n    use e = Enumerator.Get s\n    while pos < index do\n        if not (e.MoveNext()) then\n            InsufficientElements()\n        pos <- pos + 1\n    e.Current\n\n[<Inline>]\nlet Item index (s: seq<'T>) = Get index s\n\n[<Inline \"$a\">]\n[<Name \"ofArray\">]\nlet OfArray (a: 'T[]) = X<seq<'T>>\n\n[<Inline \"$l\">]\n[<Name \"ofList\">]\nlet OfList (l: list<'T>) = X<seq<'T>>\n\n[<Name \"pairwise\">]\nlet Pairwise (s: seq<'T>) : seq<'T * 'T> =\n    Seq.windowed 2 s\n    |> Seq.map (fun x -> (x.[0], x.[1]))\n\n[<Name \"pick\">]\nlet Pick p (s: seq<_>) =\n    match Seq.tryPick p s with\n    | Some x -> x\n    | None   -> failwith \"KeyNotFoundException\"\n\n[<Name \"readOnly\">]\nlet ReadOnly (s: seq<'T>) : seq<'T> =\n    Enumerable.Of (fun () -> Enumerator.Get s)\n\n[<Name \"reduce\">]\nlet Reduce (f: 'T -> 'T -> 'T) (source: seq<'T>) : 'T =\n    use e = Enumerator.Get source\n    if not (e.MoveNext()) then\n        failwith \"The input sequence was empty\"\n    let mutable r = e.Current\n    while e.MoveNext() do\n        r <- f r e.Current\n    r\n\n[<Name \"scan\">]\nlet Scan<'T,'S> (f: 'S -> 'T -> 'S) (x: 'S) (s: seq<'T>) : seq<'S> =\n    Enumerable.Of <| fun () ->\n        let en = Enumerator.Get s\n        Enumerator.NewDisposing false (fun _ -> en.Dispose()) <| fun e ->\n            if e.State then\n                if en.MoveNext() then\n                    e.Current <- f e.Current en.Current\n                    true\n                else\n                    false\n            else\n                e.Current <- x\n                e.State <- true\n                true\n\n[<Inline \"[$x]\">]\n[<Name \"singleton\">]\nlet Singleton<'T> (x: 'T) = X<seq<'T>>\n\n[<Name \"skip\">]\nlet Skip (n: int) (s: seq<'T>) : seq<'T> =\n    Enumerable.Of (fun () ->\n        let o = Enumerator.Get s\n        Enumerator.NewDisposing true (fun _ -> o.Dispose()) (fun e ->\n            if e.State then\n                for i = 1 to n do\n                    if not (o.MoveNext()) then\n                        InsufficientElements()\n                e.State <- false\n            if o.MoveNext() then\n                e.Current <- o.Current\n                true\n            else\n                false))\n\n[<Name \"skipWhile\">]\nlet SkipWhile (f: 'T -> bool) (s: seq<'T>) : seq<'T> =\n    Enumerable.Of (fun () ->\n        let o = Enumerator.Get s\n        Enumerator.NewDisposing true (fun _ -> o.Dispose()) (fun e ->\n            if e.State then\n                let mutable go = true\n                let mutable empty = false\n                while go do\n                    if o.MoveNext() then\n                        if not (f o.Current) then go <- false \n                    else \n                        go <-false\n                        empty <- true\n                e.State <- false\n                if empty then \n                    false \n                else\n                    e.Current <- o.Current\n                    true\n            else\n                if o.MoveNext() then\n                    e.Current <- o.Current\n                    true\n                else\n                    false))\n\n[<Name \"sort\">]\nlet Sort<'T when 'T : comparison> (s: seq<'T>) =\n    Seq.sortBy id s\n\n[<Name \"sortBy\">]\nlet SortBy<'T, 'U when 'U: comparison>\n        (f: 'T -> 'U) (s: seq<'T>) : seq<'T> =\n    Seq.delay (fun () ->\n        let array = Array.ofSeq s\n        Array.sortInPlaceBy f array\n        array :> _)\n\n[<Name \"sortByDescending\">]\nlet SortByDescending<'T, 'U when 'U: comparison>\n        (f: 'T -> 'U) (s: seq<'T>) : seq<'T> =\n    Seq.delay (fun () ->\n        let array = Array.ofSeq s\n        ArraySortInPlaceByDescending f array\n        array :> _)\n\n[<Name \"sortDescending\">]\nlet SortDescending<'T when 'T : comparison> (s: seq<'T>) =\n    SortByDescending id s\n\n[<Name \"sum\">]\nlet Sum<'T> (s: seq<'T>) : 'T =\n    box (Seq.fold (fun s x -> s + (box x :?> _)) 0. s) :?> _\n\n[<Name \"sumBy\">]\nlet SumBy<'T,'U> (f: 'T -> 'U) (s: seq<'T>) : 'U =\n    box (Seq.fold (fun s x -> s + (box (f x) :?> _)) 0. s) :?> _\n\n[<Name \"take\">]\nlet Take (n: int) (s: seq<'T>) : seq<'T> =\n    if n < 0 then\n        InputMustBeNonNegative()\n    Enumerable.Of (fun () ->\n        let e = ref (Enumerator.Get s)\n        Enumerator.NewDisposing 0 (fun _ -> safeDispose !e) (fun o ->\n            o.State <- o.State + 1\n            if o.State > n then false else\n            let en = !e\n            if en = null then InsufficientElements()\n            elif en.MoveNext() then\n                o.Current <- en.Current\n                if o.State = n then\n                    en.Dispose()\n                    e := null\n                true\n            else\n                en.Dispose()\n                e := null\n                InsufficientElements()\n        )\n    )\n\n[<Name \"takeWhile\">]\nlet TakeWhile (f: 'T -> bool) (s: seq<'T>) : seq<'T> =\n    seq {\n        use e = Enumerator.Get s\n        while e.MoveNext() && f e.Current do\n            yield e.Current\n    }\n\n[<Inline>]\nlet ToArray (s: seq<'T>) =\n    Array.ofSeq s\n\n[<Inline>]\nlet ToList (s: seq<'T>) = List.ofSeq s\n\n[<Name \"truncate\">]\nlet Truncate (n: int) (s: seq<'T>) : seq<'T> =\n    seq {\n        use e = Enumerator.Get s\n        let i = ref 0\n        while e.MoveNext() && !i < n do\n            incr i\n            yield e.Current\n    }\n\n[<Name \"tryFind\">]\nlet TryFind ok (s: seq<_>) =\n    use e = Enumerator.Get s\n    let mutable r = None\n    while r.IsNone && e.MoveNext() do\n        let x = e.Current\n        if ok x then\n            r <- Some x\n    r\n\n[<Inline>]\nlet TryFindBack ok (s: seq<_>) =\n    ArrayTryFindBack ok (Array.ofSeq s) \n\n[<Inline>]\nlet TryHead (s: seq<'T>) = SeqTryHead s\n\n[<Inline>]\nlet TryItem i (s: seq<'T>) = SeqTryItem i s\n\n[<Inline>]\nlet TryLast (s: seq<'T>) =  SeqTryLast s\n\n[<Name \"findBack\">]\nlet FindBack p (s: seq<_>) =\n    match TryFindBack p s with\n    | Some x -> x\n    | None   -> failwith \"KeyNotFoundException\"\n\n[<Name \"tryFindIndex\">]\nlet TryFindIndex ok (s: seq<_>) =\n    use e = Enumerator.Get s\n    let mutable loop = true\n    let mutable i = 0\n    while loop && e.MoveNext() do\n        let x = e.Current\n        if ok x then\n            loop <- false\n        else\n            i <- i + 1\n    if loop then None else Some i\n\n[<Inline>]\nlet TryFindIndexBack ok (s: seq<_>) =\n    ArrayTryFindIndexBack ok (Array.ofSeq s) \n\n[<Name \"findIndexBack\">]\nlet FindIndexBack p (s: seq<_>) =\n    match TryFindIndexBack p s with\n    | Some x -> x\n    | None   -> failwith \"KeyNotFoundException\"\n\n[<Name \"tryPick\">]\nlet TryPick f (s: seq<_>) =\n    use e = Enumerator.Get s\n    let mutable r = None\n    while r = None && e.MoveNext() do\n        r <- f e.Current\n    r\n\n[<Name \"unfold\">]\nlet Unfold<'S, 'T> (f: 'S -> option<'T * 'S>) (s: 'S) : seq<'T> =\n    Enumerable.Of <| fun () ->\n        Enumerator.New s <| fun e ->\n            match f e.State with\n            | Some (t, s) ->\n                e.Current <- t\n                e.State  <- s\n                true\n            | None ->\n                false\n\n[<Name \"windowed\">]\nlet Windowed (windowSize: int) (s: seq<'T>) : seq<'T []> =\n    if windowSize <= 0 then\n        failwith \"The input must be positive.\"\n    seq {\n        use e = Enumerator.Get s\n        let q = new System.Collections.Generic.Queue<'T>()\n        while q.Count < windowSize && e.MoveNext() do\n            q.Enqueue e.Current\n        if q.Count = windowSize then\n            yield q.ToArray()\n            while e.MoveNext() do\n                ignore (q.Dequeue())\n                q.Enqueue e.Current\n                yield q.ToArray()\n    }\n\n[<Name \"zip\">]\nlet Zip (s1: seq<'T>) (s2: seq<'U>) =\n    Seq.map2 (fun x y -> x, y) s1 s2\n\n[<Name \"map3\">]\nlet Map3 f (s1: seq<_>) (s2: seq<_>) (s3: seq<_>) =\n    Enumerable.Of <| fun () ->\n        let e1 = Enumerator.Get s1\n        let e2 = Enumerator.Get s2\n        let e3 = Enumerator.Get s3\n        Enumerator.NewDisposing () (fun _ -> e1.Dispose(); e2.Dispose(); e3.Dispose()) <| fun e ->\n            if e1.MoveNext() && e2.MoveNext() && e3.MoveNext() then\n                e.Current <- f e1.Current e2.Current e3.Current\n                true\n            else\n                false\n\n[<Name \"zip3\">]\nlet Zip3 (s1: seq<'T>) (s2: seq<'U>) (s3: seq<'V>) : seq<'T * 'U * 'V> =\n    Map3 (fun x y z -> x, y, z) s1 s2 s3\n\n[<Name \"fold2\">]\nlet Fold2<'T1,'T2,'S> (f: 'S -> 'T1 -> 'T2 -> 'S)\n                        (s: 'S)\n                        (s1: seq<'T1>)\n                        (s2: seq<'T2>) : 'S =\n    Array.fold2 f s (Array.ofSeq s1) (Array.ofSeq s2)\n\n[<Name \"foldBack\">]\nlet FoldBack f (s: seq<_>) state =\n    Array.foldBack f (Array.ofSeq s) state\n\n[<Name \"foldBack2\">]\nlet FoldBack2 f (s1: seq<_>) (s2: seq<_>) s =\n    Array.foldBack2 f (Array.ofSeq s1) (Array.ofSeq s2) s\n\n[<Name \"iteri2\">]\nlet IterateIndexed2 f (s1: seq<_>) (s2: seq<_>) =\n    let mutable i = 0\n    use e1 = Enumerator.Get s1\n    use e2 = Enumerator.Get s2\n    while e1.MoveNext() && e2.MoveNext() do\n        f i e1.Current e2.Current\n        i <- i + 1\n\n[<Name \"mapi2\">]\nlet MapIndexed2 f (s1: seq<_>) (s2: seq<_>) =\n    Map3 f (Seq.initInfinite id) s1 s2\n\n[<Name \"mapFold\">]\nlet MapFold<'T,'S,'R> f zero s =\n    ArrayMapFold<'T,'S,'R> f zero (Seq.toArray s)\n    |> As<seq<'R> * 'S>\n\n[<Name \"mapFoldBack\">]\nlet MapFoldBack<'T,'S,'R> f s zero =\n    ArrayMapFoldBack<'T,'S,'R> f (Seq.toArray s) zero\n    |> As<seq<'R> * 'S>\n\n[<Name \"permute\">]\nlet Permute f (s: seq<_>) =\n    Seq.delay (fun () -> Seq.ofArray (Array.permute f (Array.ofSeq s)))\n\n[<Name \"reduceBack\">]\nlet ReduceBack f (s: seq<_>) =\n    Array.reduceBack f (Array.ofSeq s)\n\n[<Name \"replicate\">]\nlet Replicate size value =\n    if size < 0 then InputMustBeNonNegative()\n    seq { for i in 0 .. size - 1 -> value }\n\n[<Name \"rev\">]\nlet Reverse (s: seq<'T>) =\n    Seq.delay (fun () -> Array.rev (Seq.toArray s) |> Array.toSeq)\n    \n[<Name \"scanBack\">]\nlet ScanBack f (l: seq<_>) s =\n    Seq.delay (fun () -> Seq.ofArray (Array.scanBack f (Array.ofSeq l) s))\n\n[<Name \"indexed\">]\nlet Indexed (s : seq<'T>) : seq<int * 'T> =\n    Seq.mapi (fun a b -> (a, b)) s\n\n[<Name \"sortWith\">]\nlet SortWith f (s: seq<_>) =\n    Seq.delay (fun () -> \n        let a = Array.ofSeq s\n        Array.sortInPlaceWith f a\n        Seq.ofArray a)\n\n[<Name \"tail\">]\nlet Tail<'T> (s : seq<'T>) : seq<'T> =\n    Seq.skip 1 s\n\n[<Inline>]\nlet Where (predicate : 'T -> bool) (s : seq<'T>) : seq<'T> =\n    Filter predicate s\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.Name \"Stack\">]\nmodule private WebSharper.StackProxy\n\nopen WebSharper.JavaScript\n\n[<Inline \"$arr.splice($offset,$len)\">]\nlet splice (arr: obj) (offset: int) (len: int) = X<unit>\n\n[<JavaScript>]\nlet Clear (stack: obj) =\n    splice stack 0 (stack :?> obj []).Length\n\n[<JavaScript>]\nlet Contains (stack: obj) (el: 'T) =\n    Seq.exists ((=) el) (stack :?> 'T[])\n    \n[<JavaScript>]\nlet CopyTo (stack: obj) (array: 'T[]) (index: int) =\n    Array.blit array 0 array index (stack :?> 'T[]).Length\n\n[<Proxy(typeof<System.Collections.Generic.Stack<_>>)>]\n[<Name \"WebSharper.Stack\">]\ntype private StackProxy<'T when 'T : equality> =\n\n    [<Inline \"[].concat($s).reverse()\">]\n    private new (s: 'T []) = {}\n\n    [<Inline \"[]\">]\n    new () = {}\n\n    [<Inline>]\n    private new (s: seq<'T>) = StackProxy (Array.ofSeq s)\n\n    member this.Count with [<Inline \"$this.length\">] get () = X<int>\n\n    [<Inline>]\n    member this.Clear() = Clear this\n\n    [<Inline>]\n    member this.Contains(x: 'T) : bool = Contains this x\n\n    [<Inline>]\n    member this.CopyTo(array: 'T [], index) = CopyTo this array index\n\n    [<Inline \"$this[0]\">]\n    member this.Peek() = X<'T>\n\n    [<Inline \"$this.shift()\">]\n    member this.Pop() = X<'T>\n\n    [<Inline \"$this.unshift($x)\">]\n    member this.Push(x: 'T) = X<unit>\n\n    [<Inline \"$this.slice(0)\">]\n    member this.ToArray() = X<'T[]>\n\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n[<WebSharper.Name \"Strings\">]\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Core.StringModule, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.StringProxy\n\nopen WebSharper.JavaScript\n\nmodule M = WebSharper.Macro\n\nlet Compare (x: string) (y: string) = compare x y\n\nlet CopyTo (s: string) (o: int) (d: char []) (off: int) (ct: int) =\n    Array.blit (s.ToCharArray()) o d off ct\n\n[<Direct \"$x.substring($x.length - $s.length) == $s\">]\nlet EndsWith (x: string) (s: string) = X<bool>\n\n[<Direct \"$s.indexOf($c,$i)\">]\nlet IndexOf (s: string) (c: char) (i: int) = X<int>\n\n[<Direct \"$x.substring(0,$index-1)+$s+$x.substring($index)\">]\nlet Insert (x: string) (index: int) (s: string) = X<string>\n\n[<Direct \"$x == null || $x == ''\">]\nlet IsNullOrEmpty (x: string) = X<bool>\n\n[<Direct \"\"\"$x == null || /^\\s*$/.test($x)\"\"\">]\nlet IsNullOrWhiteSpace (x: string) = X<bool>\n\n[<Direct \"$s.lastIndexOf($c,$i)\">]\nlet LastIndexOf (s: string) (c: char) (i: int) = X<int>\n\n[<Direct \"$n>$s.length?Array($n-$s.length+1).join($c)+$s:$s\">]\nlet PadLeftWith (s: string) (n: int) (c: char) = X<string>\n\nlet PadLeft (s: string) (n: int) =\n    PadLeftWith s n ' '\n\n[<Direct \"$n>$s.length?$s+Array($n-$s.length+1).join($c):$s\">]\nlet PadRightWith (s: string) (n: int) (c: char) = X<string>\n\nlet PadRight (s: string) (n: int) =\n    PadRightWith s n ' '\n\n[<Direct \"$x.substring(0,$ix) + $x.substring($ix+$ct)\">]\nlet Remove (x: string) (ix: int) (ct: int) = X<string>\n\n[<Direct \"$string.replace($search,$replace)\">]\nlet ReplaceOnce string search replace = X<string>\n\nlet Replace (subject: string) (search: string) (replace: string) =\n    let rec replaceLoop (subj: string) =\n        let index = subj.IndexOf(search)\n        if index <> -1 then\n            let replaced = ReplaceOnce subj search replace\n            let nextStartIndex = index + replace.Length\n            (replaced.Substring(0, index + replace.Length)) +\n                (replaceLoop (replaced.Substring(nextStartIndex)))\n        else subj\n    replaceLoop subject\n\nlet ReplaceChar (s: string) (oldC: char) (newC: char) =\n    Replace s (string oldC) (string newC)\n\n[<Direct \"$s.substr($ix,$ct)\">]\nlet Substring (s: string) (ix: int) (ct: int) = X<string>\n\n[<Direct \"$t.substring(0,$s.length) == $s\">]\nlet StartsWith (t: string) (s: string) = X<bool>\n\nlet ToCharArray (s: string) = Array.init s.Length (fun x -> s.[x])\n\nlet ToCharArrayRange (s: string) (startIndex: int) (length: int) =\n    Array.init length (fun i -> s.[startIndex + i])\n\n[<Direct @\"$s.replace(/^\\s+/,'').replace(/\\s+$/,'')\">]\nlet Trim (s: string) = X<string>\n\n[<Direct @\"$s.replace(/^\\s+/,'')\">]\nlet TrimStartWS (s: string) = X<string>\n\nlet TrimStart (s: string) (t: char[]) =\n    if t = null || Array.isEmpty t then\n        TrimStartWS s\n    else\n        let mutable i = 0\n        let mutable go = true\n        while i < s.Length && go do\n            let c = s.[i]\n            if t |> Array.exists ((=) c) then\n                i <- i + 1 \n            else go <- false\n        s.Substring(i)\n\n[<Direct @\"$s.replace(/\\s+$/,'')\">]\nlet TrimEndWS (s: string) = X<string>\n\nlet TrimEnd (s: string) (t: char[]) =\n    if t = null || Array.isEmpty t then\n        TrimEndWS s\n    else \n        let mutable i = s.Length - 1\n        let mutable go = true\n        while i >= 0 && go do\n            let c = s.[i]\n            if t |> Array.exists ((=) c) then\n                i <- i - 1 \n            else go <- false\n        s.Substring(0, i + 1)\n\n[<Direct \"$values.join($sep)\">]\nlet Join (sep: string) (values: string []) = X<string>\n\n[<Direct \"$str.split($pat)\">]\nlet SplitWith (str: string) (pat: obj) = X<string[]>\n\n[<Inline \"new RegExp($pat)\">]\nlet MakeRegexp (pat: string) = X<obj>\n\n[<Direct @\"$s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&')\">]\nlet RegexEscape (s: string) = X<string>\n\nlet Split (s: string) (pat: obj) (opts: System.StringSplitOptions) =\n    let res = SplitWith s pat\n    if opts ===. System.StringSplitOptions.RemoveEmptyEntries then\n        Array.filter (fun x -> x !==. \"\") res\n    else\n        res\n\nlet SplitChars (s: string) (sep: char[]) (opts: System.StringSplitOptions) =\n    let re = \"[\" + RegexEscape (new System.String(sep)) + \"]\"\n    Split s (MakeRegexp re) opts\n\nlet SplitStrings (s: string) (sep: string[]) (opts: System.StringSplitOptions) =\n    let re = String.concat \"|\" (Array.map RegexEscape sep)\n    Split s (MakeRegexp re) opts\n\nlet Filter f (s: string) =\n    System.String.Concat(s |> Seq.choose (fun c -> if f c then Some (string c) else None) |> Array.ofSeq)\n\n[<Inline \"$text.replace($pattern, $replace)\">]\nlet ReplaceString (pattern: RegExp) (replace: 'obj) (text: string) = X<string>\n\nlet SFormat (format: string) (args: obj[]) =\n    let pattern = RegExp(\"{(0|[1-9]\\d*)(?:,(-?[1-9]\\d*|0))?(?::(.*?))?}\", \"g\")\n    format\n    |> ReplaceString pattern (FuncWithArgs(fun (_, i, w) ->\n        let r = string args.[JS.Plus i]\n\n        if w <> JS.Undefined then\n            let w1 = JS.Plus w\n            let w2 = abs w1\n\n            if w2 > r.Length then\n                if w1 > 0 then r.PadLeft(w2)\n                else r.PadRight(w2)\n            else r\n        else r\n    ))\n\n[<Proxy(typeof<string>)>]\ntype private StringProxy =\n\n    [<Inline \"''\">]\n    new () = {}\n\n    [<Inline \"$chars.join('')\">]\n    new (chars: char []) = {}\n\n    member this.Chars  with [<Inline \"$this[$pos]\">]\n                            get (pos: int) = X<char>\n\n    [<Inline \"$this\">]\n    member this.Clone() = this :> obj\n\n    [<Inline>]\n    static member Compare(x: string, y: string) =\n        Unchecked.compare x y\n\n    [<Inline>]\n    member this.CompareTo(s: string) =\n        Unchecked.compare (this :> obj) (s :> obj)\n\n    [<Inline>]\n    static member Concat(strings: string seq) =\n        Join \"\" (Array.ofSeq strings)\n\n    [<Inline \"$strings.join('')\">]\n    static member Concat([<System.ParamArray>] strings: string[]) = X<string>\n\n    [<Inline \"$this.indexOf($s) != -1\">]\n    member this.Contains(s: string) = X<bool>\n\n    [<Inline>]\n    member this.CopyTo(s: int, d: char [], off: int, ct: int) =\n        CopyTo (As this) s d off ct\n\n    static member Empty with [<Inline \"''\">] get () = X<string>\n\n    [<Inline>]\n    member this.EndsWith(other: string) = EndsWith (As this) other\n\n    [<Inline \"$x === $y\">]\n    static member Equals(x: string, y: string) = X<bool>\n\n    [<Inline>]\n    member this.GetEnumerator() = Enumerator.Get (unbox<seq<char>> this) |> As<System.CharEnumerator>\n\n    [<Inline \"$this.indexOf($s)\">]\n    member this.IndexOf(s: string) = X<int>\n\n    [<Inline \"$this.indexOf($c)\">]\n    member this.IndexOf(c: char) = X<int>\n\n    [<Inline \"$this.indexOf($s,$i)\">]\n    member this.IndexOf(s: string, i: int) = X<int>\n\n    [<Inline>]\n    member this.IndexOf(c: char, i: int) = IndexOf (As this) c i\n\n    [<Inline>]\n    static member IsNullOrEmpty(x: string) = IsNullOrEmpty x\n\n    [<Inline>]\n    static member IsNullOrWhiteSpace(x: string) = IsNullOrWhiteSpace x\n\n    member this.Item\n        with    [<Inline \"$this[$pos]\">]\n                get (pos: int) = X<char>\n\n    [<Inline>]\n    static member Join(sep: string, values: string seq) =\n        Join sep (Array.ofSeq values)\n\n    [<Inline>]\n    static member Join(sep: string, [<System.ParamArray>] values: string[]) =\n        Join sep values\n\n    [<Inline \"$this.lastIndexOf($s)\">]\n    member this.LastIndexOf(s: string) = X<int>\n\n    [<Inline \"$this.lastIndexOf($c)\">]\n    member this.LastIndexOf(c: char) = X<int>\n\n    [<Inline \"$this.lastIndexOf($s,$i)\">]\n    member this.LastIndexOf(s: string, i: int) = X<int>\n\n    [<Inline>]\n    member this.LastIndexOf(c: char, i: int) =\n        LastIndexOf (As this) c i\n\n    member this.Length with [<Inline \"$this.length\">]\n                            get () = X<int>\n\n    [<Inline>]\n    member this.PadLeft(i: int) =\n        PadLeft (As this) i\n\n    [<Inline>]\n    member this.PadLeft(i: int, c: char) =\n        PadLeftWith (As this) i c\n\n    [<Inline>]\n    member this.PadRight(i: int) =\n        PadRight (As this) i\n\n    [<Inline>]\n    member this.PadRight(i: int, c: char) =\n        PadRightWith (As this) i c\n\n    [<Inline \"$this.substring(0,$ix)\">]\n    member this.Remove(ix: int) = X<string>\n\n    [<Inline>]\n    member this.Remove(ix: int, count: int) = Remove (As this) ix count\n\n    [<Inline>]\n    member this.ToCharArray() = ToCharArray (As this)\n\n    [<Inline>]\n    member this.Replace(subj: string, repl: string) =\n        Replace (As this) subj repl\n\n    [<Inline>]\n    member this.Replace(subj: char, repl: char) =\n        ReplaceChar (As this) subj repl\n\n    [<Inline>]\n    member this.Split([<System.ParamArray>] sep: char[]) =\n        SplitChars (As this) sep  System.StringSplitOptions.None\n\n    [<Inline>]\n    member this.Split(sep: char[], opts: System.StringSplitOptions) =\n        SplitChars (As this) sep opts\n\n    [<Inline>]\n    member this.Split(sep: string[], opts: System.StringSplitOptions) =\n        SplitStrings (As this) sep opts\n\n    [<Inline>]\n    member this.StartsWith(s: string) =\n        StartsWith (As this) s\n\n    [<Inline \"$this.substring($ix)\">]\n    member this.Substring(ix: int) = X<string>\n\n    [<Inline>]\n    member this.Substring(ix: int, ct: int) =\n        Substring (As this) ix ct\n\n    [<Inline>]\n    member this.ToCharArray(i: int, l: int) =\n        ToCharArrayRange (As this) i l\n\n    [<Inline \"$this.toLowerCase()\">]\n    member this.ToLower() = X<string>\n\n    [<Inline \"$this.toUpperCase()\">]\n    member this.ToUpper() = X<string>\n\n    [<Inline>]\n    member this.Trim() = Trim (As this)\n\n    [<Inline>]\n    member this.TrimStart(t: char[]) = TrimStart (As this) t\n\n    [<Inline>]\n    member this.TrimEnd(t: char[]) = TrimEnd (As this) t\n\n    [<Inline \"$a + $b\">]\n    static member (+) (a: string, b: string) = X<string>\n\n    [<Inline>]\n    static member (+) (a: obj, b: string) = string a + b \n\n    [<Inline>]\n    static member (+) (a: string, b: obj) = a + string b\n\n    [<Inline \"$a === $b\">]\n    static member op_Equality(a: string, b: string) = X<bool>\n\n    [<Inline \"$a !== $b\">]\n    static member op_Inequality(a: string, b: string) = X<bool>\n\n    [<Macro(typeof<M.StringFormat>)>]\n    [<Inline>]\n    static member Format(format: string, [<System.ParamArray>] arguments: obj []) = SFormat format arguments\n\n    [<Macro(typeof<M.StringFormat>)>]\n    [<Inline>]\n    static member Format(format: string, arg0: obj): string = SFormat format [|arg0|]\n\n    [<Macro(typeof<M.StringFormat>)>]\n    [<Inline>]\n    static member Format(format: string, arg0: obj, arg1: obj): string = SFormat format [|arg0; arg1|]\n\n    [<Macro(typeof<M.StringFormat>)>]\n    [<Inline>]\n    static member Format(format: string, arg0: obj, arg1: obj, arg2: obj): string = SFormat format [|arg0; arg1; arg2|]\n\nlet protect (s : string) =\n    if s = null then \"\" else s\n\n[<Inline \"$strings.join($sep)\">]\nlet join (strings: string[]) (sep: string) = X<string>\n\n[<Name \"collect\">]\nlet Collect (f: char -> string) (s: string) : string =\n    System.String.Concat(Array.init s.Length (fun i -> f s.[i]))\n\n[<Name \"concat\">]\nlet Concat (separator: string) (strings: seq<string>) : string =\n    join (Seq.toArray strings) separator\n\n[<Name \"exists\">]\nlet Exists (f: char -> bool) (s: string) : bool =\n    Seq.exists f (protect s)\n\n[<Name \"forall\">]\nlet ForAll (f: char -> bool) (s: string) : bool =\n    Seq.forall f (protect s)\n\n[<Name \"init\">]\nlet Initialize (count: int) (f: int -> string) : string =\n    System.String.Concat(Array.init count f)\n\n[<Name \"iter\">]\nlet Iterate (f: char -> unit) (s: string) : unit =\n    Seq.iter f (protect s)\n\n[<Name \"iteri\">]\nlet IterateIndexed (f: int -> char -> unit) (s: string) : unit =\n    Seq.iteri f (protect s)\n\n[<Name \"length\">]\nlet Length (s: string) : int =\n    (protect s).Length\n\n[<Name \"map\">]\nlet Map (f: char -> char) (s: string) : string =\n    Collect (fun x -> string (f x)) (protect s)\n\n[<Name \"mapi\">]\nlet MapIndexed (f: int -> char -> char) (s: string) : string =\n    System.String.Concat (Seq.toArray (Seq.mapi (fun i x -> string (f i x)) s))\n\n[<Name \"replicate\">]\nlet Replicate (count: int) (s: string) : string =\n    Initialize count (fun _ -> s)\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen WebSharper.JavaScript\n\nopen System.Threading\nopen System.Threading.Tasks\n\n[<Proxy(typeof<Task>); Name \"Task\">]\ntype private TaskProxy(action: System.Action, token: CT, status, exc) =\n    [<Name \"status\">]\n    let mutable status = status\n    [<Name \"continuations\">]\n    let continuations = [||] : TaskProxy[]\n    [<Name \"exc\">]\n    let mutable exc = exc : System.AggregateException\n\n    abstract Execute : unit -> unit\n    default this.Execute() = action.Invoke()\n\n    member this.Exception = exc\n\n    member this.IsCanceled = \n        status = TaskStatus.Canceled\n\n    member this.IsCompleted = \n        status = TaskStatus.RanToCompletion || status = TaskStatus.Faulted || status = TaskStatus.Canceled\n\n    member this.IsFaulted =\n        status = TaskStatus.Faulted\n\n    member this.Status = status\n\n    new (action) = TaskProxy(action, CT.None, TaskStatus.Created, null)\n\n    new (action, ct) = TaskProxy(action, ct, TaskStatus.Created, null)\n    \n    member this.OnCompleted(cont : unit -> unit) =\n        if this.IsCompleted then \n            cont()\n        else \n            if this.Status = TaskStatus.Created then this.Start()\n            this.ContinueWith(fun (_: Task) -> cont()) |> ignore\n\n    member this.RunContinuations() =\n        for c in continuations do\n            c.StartContinuation()    \n\n    member this.ContinueWith(action: System.Action<Task>) =\n        this.ContinueWith(action, CT.None)\n\n    member this.ContinueWith(action: System.Action<Task>, ct) =\n        let res = TaskProxy((fun () -> action.Invoke (As<Task> this)), ct, TaskStatus.WaitingForActivation, null)\n        if this.IsCompleted then\n            res.StartContinuation()     \n        else\n            continuations.JS.Push res |> ignore\n        As<Task> res\n\n    [<Inline>]\n    member this.ContinueWith(func: System.Func<Task,'T>) =\n        this.ContinueWith(func, CT.None)\n\n    member this.ContinueWith(func: System.Func<Task,'T>, ct) =\n        let res = TaskProxy<'T>((fun () -> func.Invoke (As<Task> this)), ct, TaskStatus.WaitingForActivation, null, JS.Undefined)\n        if this.IsCompleted then\n            res.StartContinuation()     \n        else\n            continuations.JS.Push res |> ignore\n        As<Task<'T>> res\n\n    member this.StartContinuation() =\n        if status = TaskStatus.WaitingForActivation then\n            status <- TaskStatus.WaitingToRun\n            Concurrency.fork (fun () -> \n                if status = TaskStatus.WaitingToRun then\n                    status <- TaskStatus.Running\n                    try\n                        this.Execute()\n                        status <- TaskStatus.RanToCompletion\n                    with e ->\n                        exc <- System.AggregateException(e)\n                        status <- TaskStatus.Faulted\n                    this.RunContinuations()\n            )\n\n    member this.Start() =\n        if status = TaskStatus.Created then\n            status <- TaskStatus.WaitingToRun\n            Concurrency.fork (fun () -> \n                status <- TaskStatus.Running\n                try\n                    this.Execute()\n                    status <- TaskStatus.RanToCompletion\n                with\n                | :? OCE as e when e.CancellationToken = token ->\n                    Console.Log(\"Task cancellation caught:\", e)\n                    exc <- System.AggregateException(e)\n                    status <- TaskStatus.Canceled\n                | e ->\n                    Console.Log(\"Task error caught:\", e)\n                    exc <- System.AggregateException(e)\n                    status <- TaskStatus.Faulted\n                this.RunContinuations()\n            )\n        else\n            invalidOp \"Task not in initial state\"\n        \n    static member FromCanceled ct = \n        As<Task> (TaskProxy(null, ct, TaskStatus.Canceled, null)) \n\n    static member FromCanceled(ct: CT) = \n        As<Task<_>> (TaskProxy<_>(null, ct, TaskStatus.Canceled, null, As null)) \n\n    static member FromException (exc: exn) =\n        As<Task> (TaskProxy(null, CT.None, TaskStatus.Faulted, System.AggregateException(exc)))\n\n    static member FromException (exc: exn) =\n        As<Task<_>> (TaskProxy<_>(null, CT.None, TaskStatus.Faulted, System.AggregateException(exc), As null))\n\n    static member FromResult (res: 'T) = \n        As<Task<'T>> (TaskProxy<'T>(null, CT.None, TaskStatus.RanToCompletion, null, res)) \n\n    [<Inline>]\n    static member Run(action : System.Action) =\n       TaskProxy.Run(action, CT.None)\n        \n    static member Run(action : System.Action, ct) =\n        let res = TaskProxy(action, ct, TaskStatus.Created, null)\n        res.Start()\n        As<Task> res\n\n    [<Inline>]\n    static member Run(func : System.Func<Task>) =\n        TaskProxy.Run(func, CT.None)\n\n    static member Run(func : System.Func<Task>, ct: CT) =\n        let task = func.Invoke()\n        if ct.IsCancellationRequested then TaskProxy.FromCanceled ct : Task else\n        if task.Status = TaskStatus.Created then\n            task.Start()\n        task\n\n    [<Inline>]\n    static member Run(func : System.Func<'T>) =\n        TaskProxy.Run(func, CT.None)\n\n    static member Run(func : System.Func<'T>, ct) =\n        let res = TaskProxy<'T>(func, ct, TaskStatus.Created, null, JS.Undefined)\n        res.Start()\n        As<Task<'T>> res   \n\n    [<Inline>]\n    static member Run(func : System.Func<Task<'T>>) =\n        TaskProxy.Run(func, CT.None)\n\n    static member Run(func : System.Func<Task<'T>>, ct: CT) =\n        let task = func.Invoke()\n        if ct.IsCancellationRequested then TaskProxy.FromCanceled<'T> ct else\n        if task.Status = TaskStatus.Created then\n            task.Start()\n        task\n\n    static member Delay(time: int) =   \n        Async.StartAsTask (Async.Sleep time) :> Task\n             \n    static member Delay(time: int, ct) =        \n        Async.StartAsTask (Async.Sleep time, cancellationToken = ct) :> Task\n\n    [<Inline>]\n    static member Delay(time: System.TimeSpan) =        \n        TaskProxy.Delay(As<int> time)\n             \n    [<Inline>]\n    static member Delay(time: System.TimeSpan, ct) =        \n        TaskProxy.Delay(As<int> time, ct)\n\n    static member WhenAny(tasks: Task[]) =\n        let tcs = System.Threading.Tasks.TaskCompletionSource<_>()\n        for t in tasks do t.ContinueWith (fun t -> tcs.TrySetResult t |> ignore) |> ignore\n        tcs.Task\n            \n    [<Inline>]                         \n    static member WhenAny(tasks: seq<Task>) = TaskProxy.WhenAny(Array.ofSeq tasks)\n\n    static member WhenAny(tasks: Task<'T>[]) =\n        let tcs = System.Threading.Tasks.TaskCompletionSource<Task<'T>>()\n        for t in tasks do t.ContinueWith (fun t -> tcs.TrySetResult t |> ignore) |> ignore\n        tcs.Task\n            \n    [<Inline>]                         \n    static member WhenAny(tasks: seq<Task<'T>>) = TaskProxy.WhenAny(Array.ofSeq tasks)\n\n    static member WhenAll(tasks: Task[]) =\n        let target = tasks.Length\n        let completed = ref 0\n        let tcs = System.Threading.Tasks.TaskCompletionSource<_>()\n        for i = 0 to target - 1 do\n            tasks.[i].ContinueWith (fun t -> \n                if t.IsFaulted then\n                    tcs.TrySetException t.Exception |> ignore\n                elif t.IsCanceled then\n                    tcs.TrySetCanceled() |> ignore\n                else\n                    incr completed\n                    if !completed = target then tcs.TrySetResult() |> ignore \n            ) |> ignore\n        tcs.Task :> Task\n\n    [<Inline>]                         \n    static member WhenAll(tasks: seq<Task>) = TaskProxy.WhenAll(Array.ofSeq tasks)\n\n    static member WhenAll(tasks: Task<'T>[]) =\n        let target = tasks.Length\n        let completed = ref 0\n        let results = JavaScript.Array(target)\n        let tcs = System.Threading.Tasks.TaskCompletionSource<_>()\n        for i = 0 to target - 1 do\n            tasks.[i].ContinueWith (fun (t: Task<'T>) -> \n                if t.IsFaulted then\n                    tcs.TrySetException t.Exception |> ignore\n                elif t.IsCanceled then\n                    tcs.TrySetCanceled() |> ignore\n                else\n                    incr completed\n                    results.[i] <- t.Result\n                    if !completed = target then tcs.SetResult results.Self\n            ) |> ignore\n        tcs.Task\n\n    [<Inline>]                         \n    static member WhenAll(tasks: seq<Task<'T>>) = TaskProxy.WhenAll(Array.ofSeq tasks)\n\n//    // TODO : return type System.Runtime.CompilerServices.YieldAwaitable \n//    static member Yield() =\n//        Async.Sleep 0 |> Async.StartAsTask  \n\nand [<Proxy(typeof<Task<_>>); Name \"Task1\">] private TaskProxy<'T>(func: System.Func<'T>, token: CT, status, exc, result) =\n    inherit TaskProxy(null, token, status, exc)\n    \n    [<Name \"result\">]\n    let mutable result = result\n\n    member this.Result = result\n\n    override this.Execute () =\n        result <- func.Invoke()\n\n    [<Inline>]\n    member this.ContinueWith(action: System.Action<Task<'T>>) =\n        this.ContinueWith(As<System.Action<Task>> action)\n\n    [<Inline>]\n    member this.ContinueWith(action: System.Action<Task<'T>>, ct) =\n        this.ContinueWith(As<System.Action<Task>> action, ct)\n\n    [<Inline>]\n    member this.ContinueWith<'R>(func: System.Func<Task<'T>, 'R>) =\n        this.ContinueWith(As<System.Func<Task, 'R>> func) \n\n    [<Inline>]\n    member this.ContinueWith<'R>(func: System.Func<Task<'T>, 'R>, ct) =\n        this.ContinueWith(As<System.Func<Task, 'R>> func, ct) \n\n[<Proxy(typeof<TaskCompletionSource<_>>)>]\n[<Name \"TaskCompletionSource\">]\ntype private TaskCompletionSourceProxy<'T>() =\n    let task = new TaskProxy<'T>(null, CT.None, TaskStatus.WaitingForActivation, null, JS.Undefined)\n\n    member this.Task = As<Task<'T>> task\n\n    member this.SetCanceled() =\n        if task.IsCompleted then\n            failwith \"Task already completed.\"\n        task?status <- TaskStatus.Canceled\n        task.RunContinuations()\n\n    member this.SetException(exc: exn) =\n        if task.IsCompleted then\n            failwith \"Task already completed.\"\n        task?status <- TaskStatus.Faulted\n        task?exc <- System.AggregateException(exc)\n        task.RunContinuations()\n\n    member this.SetException(exs : seq<exn>) =\n        this.SetException(System.AggregateException(exs))\n\n    member this.SetResult(res: 'T) =\n        if task.IsCompleted then\n            failwith \"Task already completed.\"\n        task?status <- TaskStatus.RanToCompletion\n        task?result <- res \n        task.RunContinuations()\n\n    member this.TrySetCanceled() =\n        if not task.IsCompleted then\n            task?status <- TaskStatus.Canceled\n            task.RunContinuations()\n            true\n        else false\n\n    member this.TrySetCanceled(ct: CT) =\n        if not task.IsCompleted then\n            task?status <- TaskStatus.Canceled\n            task.RunContinuations()\n            true\n        else false\n\n    member this.TrySetException(exc: exn) =\n        if not task.IsCompleted then\n            task?status <- TaskStatus.Faulted\n            task?exc <- System.AggregateException(exc)\n            task.RunContinuations()\n            true\n        else false\n\n    member this.TrySetException(exs : seq<exn>) =\n        this.TrySetException(System.AggregateException(exs))\n\n    member this.TrySetResult(res: 'T) =        \n        if not task.IsCompleted then\n            task?status <- TaskStatus.RanToCompletion\n            task?result <- res \n            task.RunContinuations()\n            true\n        else false\n    ", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\n/// Implements generic comparison, equality and hashing.\n[<WebSharper.Name \"Unchecked\">]\n[<WebSharper.Proxy\n    \"Microsoft.FSharp.Core.Operators+Unchecked, \\\n     FSharp.Core, Culture=neutral, \\\n     PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule private WebSharper.UncheckedProxy\n\nopen WebSharper.JavaScript\n\n[<Inline \"$a instanceof Array\">]\nlet isArray (a: obj) = X<bool>\n\n[<Inline \"$a instanceof Date\">]\nlet isDate (a: obj) = X<bool>\n\nlet rec compareArrays (a: obj []) (b: obj []) =\n    if a.Length < b.Length   then -1\n    elif a.Length > b.Length then 1\n    else\n        let mutable cmp = 0\n        let mutable i = 0\n        while cmp = 0 && i < a.Length do\n            cmp <- Unchecked.compare a.[i] b.[i]\n            i <- i + 1\n        cmp\n\n[<Inline \"$d.getTime()\">]\nlet getTime (d: obj) : int = X\n\nlet rec compareDates (a: obj) (b: obj) =\n    compare (getTime a) (getTime b)\n\n/// Compares two values generically.\nlet Compare<'T> (a: 'T) (b: 'T) : int =\n    let objCompare (a: obj) (b: obj) =\n        let cmp = ref 0\n        JS.ForEach a (fun k ->\n            if not (JS.HasOwnProperty a k) then\n                false\n            elif not (JS.HasOwnProperty b k) then\n                cmp := 1; true\n            else\n                cmp := Unchecked.compare a?(k) b?(k); !cmp <> 0)\n        if !cmp = 0 then\n            JS.ForEach b (fun k ->\n                if not (JS.HasOwnProperty b k) then\n                    false\n                elif not (JS.HasOwnProperty a k) then\n                    cmp := -1; true\n                else false)\n        !cmp\n    if a ===. b then 0 else\n        match JS.TypeOf a with\n        | JS.Undefined ->\n            match JS.TypeOf b with\n            | JS.Undefined -> 0\n            | _ -> -1\n        | JS.Function ->\n            failwith \"Cannot compare function values.\"\n        | JS.Boolean | JS.Number | JS.String ->\n            if a <. b then -1 else 1\n        | JS.Object ->\n            if a ===. null then -1\n            elif b ===. null then 1\n            elif JS.In \"CompareTo\" a then (As<System.IComparable<_>> a).CompareTo(b)\n            elif JS.In \"CompareTo0\" a then (As<System.IComparable> a).CompareTo(b)\n            elif isArray a && isArray b then compareArrays (As a) (As b)\n            elif isDate a && isDate b then compareDates a b\n            else objCompare (As a) (As b)\n\n/// Produces an undefined value.\n[<Macro(typeof<Macro.DefaultOf>)>]\n[<Inline \"undefined\">]\nlet DefaultOf<'T> = X<'T>\n\nlet arrayEquals (a: obj []) (b: obj []) =\n    if a.Length = b.Length then\n        let mutable eq = true\n        let mutable i = 0\n        while eq && i < a.Length do\n            if not (Unchecked.equals a.[i] b.[i]) then\n                eq <- false\n            i <- i + 1\n        eq\n    else\n        false\n\nlet dateEquals a b =\n    getTime a ===. getTime b\n\n[<Inline \"$a.Equals($b)\">]\nlet private equals (a: obj) (b: obj) = X<bool>\n\n/// Tests if two values are equal.\nlet Equals (a: 'T) (b: 'T) : bool =\n    let objEquals (a: obj) (b: obj) =\n        let eqR = ref true\n        JS.ForEach a (fun k ->\n            eqR := not (JS.HasOwnProperty a k) || JS.HasOwnProperty b k && Unchecked.equals a?(k) b?(k)\n            not !eqR)\n        if !eqR then\n            JS.ForEach b (fun k ->\n                eqR := not (JS.HasOwnProperty b k) || JS.HasOwnProperty a k\n                not !eqR)\n        !eqR\n    if a ===. b then true else\n        match JS.TypeOf a with\n        | JS.Object ->\n            if a ===. null || a ===. JS.Undefined || b ===. null || b ===. JS.Undefined then false\n            elif JS.In \"Equals\" a then equals a b\n            elif isArray a && isArray b then arrayEquals (As a) (As b)\n            elif isDate a && isDate b then dateEquals a b\n            else objEquals (As a) (As b)\n        | JS.Function ->\n            if JS.In \"$Func\" a then\n                a?``$Func`` ===. b?``$Func`` && a?``$Target`` ===. b?``$Target``\n            elif JS.In \"$Invokes\" a && JS.In \"$Invokes\" b then\n                arrayEquals a?``$Invokes`` b?``$Invokes``  \n            else false\n        | _ ->\n            false\n\nlet hashMix (x: int) (y: int) : int =\n    (x <<< 5) + x + y\n\nlet hashArray (o: obj []) =\n    let mutable h = -34948909\n    for i in 0 .. o.Length - 1 do\n        h <- hashMix h (Unchecked.hash o.[i])\n    h\n\nlet hashString (s: string) : int =\n    if s ===. null then 0 else\n        let mutable hash = 5381\n        for i = 0 to s.Length - 1 do\n            hash <- hashMix hash (int s.[i])\n        hash\n\n[<Inline \"$o.GetHashCode()\">]\nlet getHashCode(o: obj) = X<int>\n\nlet hashObject (o: obj) =\n    if JS.In \"GetHashCode\" o then getHashCode o else\n        let (++) = hashMix\n        let h = ref 0\n        JS.ForEach o (fun key ->\n            h := !h ++ hashString key ++ Unchecked.hash ((?) o key)\n            false)\n        !h\n\n/// Computes the hash of an object.\nlet Hash<'T> (o: 'T) : int =\n    match JS.TypeOf o with\n    | JS.Undefined -> 0\n    | JS.Function  -> 0\n    | JS.Boolean   -> if As o then 1 else 0\n    | JS.Number    -> As o\n    | JS.String    -> hashString (As o)\n    | JS.Object    -> if o ==. null then 0\n                      elif isArray o then hashArray (As o)\n                      else hashObject o\n\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2016 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper\n\nopen WebSharper.JavaScript\n\nmodule M = WebSharper.Macro\n\n[<JavaScript>]\n[<Name \"Numeric\">]\ntype internal N =\n    static member Parse<'T>(s: string, min: 'T, max: 'T, overflowMsg) =\n        let x : float = JS.Plus s\n        if x !==. (x -. (x %. 1)) then\n            raise (System.FormatException \"Input string was not in a correct format.\")\n        elif (x <. min) || (x >. max) then\n            raise (System.OverflowException overflowMsg)\n        else As<'T> x\n\n    static member TryParse<'T>(s: string, min: 'T, max: 'T, r: byref<'T>) =\n        let x : float = JS.Plus s\n        let ok = x ===. (x -. (x %. 1)) && (x >=. min) && (x <=. max)\n        if ok then r <- As<'T> x\n        ok\n\n[<Macro(typeof<M.NumericMacro>)>]\n[<Proxy(typeof<System.Byte>)>]\ntype internal NB =\n\n    [<Name \"WebSharper.Numeric.ParseByte\">]\n    static member Parse(s: string) : System.Byte =\n        N.Parse(s, System.Byte.MinValue, System.Byte.MaxValue, \"Value was either too large or too small for an unsigned byte.\")\n\n    [<Name \"WebSharper.Numeric.TryParseByte\">]\n    static member TryParse(s: string, r: byref<System.Byte>) : bool =\n        N.TryParse(s, System.Byte.MinValue, System.Byte.MaxValue, &r)\n\n[<Macro(typeof<M.NumericMacro>)>]\n[<Proxy(typeof<System.SByte>)>]\ntype internal NSB =\n\n    [<Name \"WebSharper.Numeric.ParseSByte\">]\n    static member Parse(s: string) : System.SByte =\n        N.Parse(s, System.SByte.MinValue, System.SByte.MaxValue, \"Value was either too large or too small for a signed byte.\")\n\n    [<Name \"WebSharper.Numeric.TryParseSByte\">]\n    static member TryParse(s: string, r: byref<System.SByte>) : bool =\n        N.TryParse(s, System.SByte.MinValue, System.SByte.MaxValue, &r)\n\n[<Macro(typeof<M.NumericMacro>)>]\n[<Proxy(typeof<System.Int16>)>]\n[<Name \"Int16\">]\ntype internal NI16 =\n\n    [<Name \"WebSharper.Numeric.ParseInt16\">]\n    static member Parse(s: string) : System.Int16 =\n        N.Parse(s, System.Int16.MinValue, System.Int16.MaxValue, \"Value was either too large or too small for an Int16.\")\n\n    [<Name \"WebSharper.Numeric.TryParseInt16\">]\n    static member TryParse(s: string, r: byref<System.Int16>) : bool =\n        N.TryParse(s, System.Int16.MinValue, System.Int16.MaxValue, &r)\n\n[<Macro(typeof<M.NumericMacro>)>]\n[<Proxy(typeof<System.Int32>)>]\n[<Name \"Int32\">]\ntype internal NI32 =\n\n    [<Name \"WebSharper.Numeric.ParseInt32\">]\n    static member Parse(s: string) : System.Int32 =\n        N.Parse(s, System.Int32.MinValue, System.Int32.MaxValue, \"Value was either too large or too small for an Int32.\")\n\n    [<Name \"WebSharper.Numeric.TryParseInt32\">]\n    static member TryParse(s: string, r: byref<System.Int32>) : bool =\n        N.TryParse(s, System.Int32.MinValue, System.Int32.MaxValue, &r)\n\n[<Macro(typeof<M.NumericMacro>)>]\n[<Proxy(typeof<System.UInt16>)>]\n[<Name \"UInt16\">]\ntype internal NUI16 =\n\n    [<Name \"WebSharper.Numeric.ParseUInt16\">]\n    static member Parse(s: string) : System.UInt16 =\n        N.Parse(s, System.UInt16.MinValue, System.UInt16.MaxValue, \"Value was either too large or too small for an UInt16.\")\n\n    [<Name \"WebSharper.Numeric.TryParseUInt16\">]\n    static member TryParse(s: string, r: byref<System.UInt16>) : bool =\n        N.TryParse(s, System.UInt16.MinValue, System.UInt16.MaxValue, &r)\n\n[<Macro(typeof<M.NumericMacro>)>]\n[<Proxy(typeof<System.UInt32>)>]\n[<Name \"UInt32\">]\ntype internal NUI32 =\n\n    [<Name \"WebSharper.Numeric.ParseUInt32\">]\n    static member Parse(s: string) : System.UInt32 =\n        N.Parse(s, System.UInt32.MinValue, System.UInt32.MaxValue, \"Value was either too large or too small for an UInt32.\")\n\n    [<Name \"WebSharper.Numeric.TryParseUInt32\">]\n    static member TryParse(s: string, r: byref<System.UInt32>) : bool =\n        N.TryParse(s, System.UInt32.MinValue, System.UInt32.MaxValue, &r)\n\n[<Macro(typeof<M.NumericMacro>)>]\n[<Proxy(typeof<System.Int64>)>]\n[<Name \"Int64\">]\ntype internal NI64 =\n\n    [<Name \"WebSharper.Numeric.ParseInt64\">]\n    static member Parse(s: string) : System.Int64 =\n        N.Parse(s, System.Int64.MinValue, System.Int64.MaxValue, \"Value was either too large or too small for an Int64.\")\n\n    [<Name \"WebSharper.Numeric.TryParseInt64\">]\n    static member TryParse(s: string, r: byref<System.Int64>) : bool =\n        N.TryParse(s, System.Int64.MinValue, System.Int64.MaxValue, &r)\n\n[<Macro(typeof<M.NumericMacro>)>]\n[<Proxy(typeof<System.UInt64>)>]\n[<Name \"UInt64\">]\ntype internal NUI64 =\n\n    [<Name \"WebSharper.Numeric.ParseUInt64\">]\n    static member Parse(s: string) : System.UInt64 =\n        N.Parse(s, System.UInt64.MinValue, System.UInt64.MaxValue, \"Value was either too large or too small for an UInt64.\")\n\n    [<Name \"WebSharper.Numeric.TryParseUInt64\">]\n    static member TryParse(s: string, r: byref<System.UInt64>) : bool =\n        N.TryParse(s, System.UInt64.MinValue, System.UInt64.MaxValue, &r)\n\n[<Macro(typeof<M.NumericMacro>)>]\n[<Proxy(typeof<System.Single>)>]\ntype internal NS =\n\n    [<Inline \"Math.abs($0) === Infinity\">]\n    static member IsInfinity(f: single) = X<bool>\n\n    [<Inline \"isNaN($0)\">]\n    static member IsNaN(f: single) = X<bool>\n\n    [<Inline \"$0 === -Infinity\">]\n    static member IsNegativeInfinity (f: single) = X<bool>\n\n    [<Inline \"$0 === Infinity\">]\n    static member IsPositiveInfinity (f: single) = X<bool>\n\n[<Macro(typeof<M.NumericMacro>)>]\n[<Proxy(typeof<System.Double>)>]\ntype internal ND =\n\n    [<Inline \"Math.abs($0) === Infinity\">]\n    static member IsInfinity(f: double) = X<bool>\n\n    [<Inline \"isNaN($0)\">]\n    static member IsNaN(f: double) = X<bool>\n\n    [<Inline \"$0 === -Infinity\">]\n    static member IsNegativeInfinity (f: double) = X<bool>\n\n    [<Inline \"$0 === Infinity\">]\n    static member IsPositiveInfinity (f: double) = X<bool>\n\n[<Proxy(typeof<System.Boolean>)>]\ntype internal B = \n    [<Inline>]\n    static member op_LogicalNot(a: bool) = not a\n"],
"names": [],
"mappings": "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"
}
